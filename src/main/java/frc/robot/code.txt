package frc.robot.annotations;

import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

import edu.wpi.first.util.sendable.Sendable;
import edu.wpi.first.util.sendable.SendableBuilder;
import frc.robot.Constants;


public class AnnotatedClass implements Sendable {

  /**
   * Process annotations the class, call this before any annotated variables are referenced
   * 
   * @param start Reference to the current class type, e.g. AnnotatedClass.class
   */
  public static <T> void processAnnotations(Class<T> start) {
    processClass(start, 0);
  }

  private static <T> void processClass(Class<T> start, int depth) {

    /* Bail out if we're recursing a bit much, in case something breaks */
    if (depth > 10) {
      return;
    }

    /* Start with our class */
    processFields(start);

    var classes = start.getDeclaredClasses();
    for (Class<?> c : classes) {
      processClass(c, depth + 1);
    }
  }

  private static <T> void processFields(Class<T> start) {
    Field[] fields = start.getFields();

    for (var field : fields) {
      if (double.class.isAssignableFrom(field.getType())) {
        processDouble(field);
      }

      var ntPub = field.getAnnotation(NTPublish.class);
      if (ntPub != null) {
        String path = new String();
        path += field.getDeclaringClass().getSimpleName();
        path += "/";
        path += field.getName();
        fieldsToTrack.put(path, field);
      }
    }
  }

  private static Map<String, Field> fieldsToTrack = new HashMap<>();

  private static void processDouble(Field field) {
    try {
      var mrd = field.getAnnotation(MultiRobotDouble.class);
      if (mrd != null) {
        switch (Constants.getMode()) {
          case SIM:
          case SIM_REPLAY:
            field.setDouble(null, mrd.sim());
            break;
          case REAL:
            field.setDouble(null, mrd.real());
        }
      }
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    }
  }

  public AnnotatedClass() {}

  @Override
  public void initSendable(SendableBuilder b) {
    System.out.println("Init sendable");
    for (Map.Entry<String, Field> entry : fieldsToTrack.entrySet()) {
      var name = entry.getKey();
      var field = entry.getValue();
      var c = field.getType();

      if (double.class.isAssignableFrom(c)) {
        b.addDoubleProperty(name, () -> {
          try {
            return field.getDouble(null);
          } catch (Exception e) {
            return 0;
          }
        }, (double d) -> {
          try {
            field.setDouble(null, d);
          } catch (Exception e) {
          }
        });
      }

      if (String.class.isAssignableFrom(c)) {
        b.addStringProperty(name, () -> {
          try {
            return (String) field.get(null);
          } catch (Exception e) {
            return "";
          }
        }, (String d) -> {
          try {
            field.set(null, d);
          } catch (Exception e) {
          }
        });
      }
    }
  }
}
package frc.robot.annotations;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/**
 * Set a double based on the type of robot currently running.
 */
@Retention(RetentionPolicy.RUNTIME)
public @interface MultiRobotDouble {
  double sim();

  double real();
}
package frc.robot.annotations;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/**
 * Publish this variable to NetworkTables, requires instantiating the class and calling putData on it due to a reliance on Sendable. Will auto update bidirectionally.
 */
@Retention(RetentionPolicy.RUNTIME)
public @interface NTPublish {}
package frc.robot.auton;

import java.util.HashMap;
import java.util.Map;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.PrintCommand;
import frc.robot.subsystems.Grabber;
import frc.robot.subsystems.Subsystems;
import frc.robot.subsystems.arm.Arm;
import frc.robot.subsystems.drive.Swerve;
import frc.robot.subsystems.wrist.Wrist;

public class AutonChooser {
  private HashMap<String, Command> autons;
  private Swerve swerve;//necessary to create PPSwerveCommand instances
  private SendableChooser<Command> chooser;
  private final String defaultChoice = "N4 Place Then Dock";
  private Wrist wrist;
  private Arm arm;
  private Grabber grabber;

  public AutonChooser(Swerve swerve, Arm arm, Wrist wrist, Grabber grabber) {
    this.swerve = swerve;
    this.arm = arm;
    this.wrist = wrist;
    this.grabber = grabber;
    this.chooser = new SendableChooser<>();
    this.autons = new HashMap<>();

    initializeAutons();
    populateChooser();
    setDefaultAuton();
    SmartDashboard.putData(chooser);
  }

  public void populateChooser() {
    for (Map.Entry<String, Command> auton : autons.entrySet()) {
      chooser.addOption(auton.getKey(), auton.getValue());
    }
  }

  public void setDefaultAuton() {
    if (autons.containsKey(defaultChoice)) {//set default
      chooser.setDefaultOption(defaultChoice, autons.get(defaultChoice));
    } else {//Otherwise, set default to first choice
      DriverStation.reportError("Default Auton Not Defined", false);
      if (autons.size() > 0) {
        Map.Entry<String, Command> firstAuton = autons.entrySet().iterator().next();
        chooser.setDefaultOption(firstAuton.getKey(), firstAuton.getValue());
      } else {
        DriverStation.reportError("No Autons Defined", false);

      }
    }
  }

  public Command getSelectedAuton() {
    Command selectedAuton = chooser.getSelected();
    if (selectedAuton == null) {
      DriverStation.reportError("Selected Auton is null", false);
      if (autons.size() > 0) {
        Map.Entry<String, Command> firstAuton = autons.entrySet().iterator().next();
        selectedAuton = firstAuton.getValue();
      } else {
        DriverStation.reportError("No Autons Defined", false);
        selectedAuton = new PrintCommand("No Auton Selected");
      }
    }
    return selectedAuton;
  }

  public void initializeAutons() {//Here we define auton choices
    Subsystems s = new Subsystems(swerve, wrist, arm, grabber);

    Command InertN4PlaceThenDock = AutonPaths.InertN4PlaceThenDock(s);
    Command InertN1PlaceThenExplore = AutonPaths.InertN1PlaceThenExplore(s);
    Command InertN9PlaceThenExplore = AutonPaths.InertN9PlaceThenExplore(s);
    Command justPlace = AutonPaths.InertN1Place(s);
    Command doubleCone = AutonPaths.InertN12ConePrime(s);
    Command InertN1Safe2Cone = AutonPaths.InertN1SafeTwoCone(s);
    Command N92Cone = AutonPaths.InertN92Cone(s);
    Command InertN4GrabThenDock = AutonPaths.InertN4GrabThenDock(s);

    autons.put("BUMP 2 cone", N92Cone);
    autons.put("2 cone", doubleCone);
    autons.put("NO BUMP Place Then Move", InertN1PlaceThenExplore);
    autons.put("N4 Place Then Dock", InertN4PlaceThenDock);
    autons.put("BUMP Place Then Move", InertN9PlaceThenExplore);
    autons.put("Just Place", justPlace);
    autons.put("NO BUMP Safe two cone", InertN1Safe2Cone);
    autons.put("Middle Go over station and grab, then dock", InertN4GrabThenDock);
  }
}
package frc.robot.auton;

import org.littletonrobotics.junction.Logger;
import com.pathplanner.lib.PathConstraints;
import com.pathplanner.lib.PathPlanner;
import com.pathplanner.lib.PathPlannerTrajectory;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.DriverStation.Alliance;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.ParallelRaceGroup;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import edu.wpi.first.wpilibj2.command.WaitCommand;
import frc.robot.Constants;
import frc.robot.commands.arm.StowArm;
import frc.robot.commands.wrist.AltWristControl;
import frc.robot.subsystems.Grabber;
import frc.robot.subsystems.Subsystems;
import frc.robot.subsystems.drive.Swerve;
import frc.robot.util.CustomProxy;

public class AutonHelper {

  //format:off
  /* Places a cone on the grid
   * ASSUPTIONS: Cone being held, arm in correct position, alt mode corresponds to setting wrist to 0deg, and default sets it to 90deg
   */
  public static Command getPlaceConeCommand(Subsystems s) {
    return new AltWristControl(s.wrist).raceWith(new SequentialCommandGroup(new WaitCommand(0.5), // Wait for wrist to rotate before dropping cone
        getGrabberOpenCommand(s.grabber))).andThen(new WaitCommand(0.5), // Wait for grabber and gravity to drop cone
            getGrabberCloseCommand(s.grabber));
  }

  public static Command getGroundPickUpCommand(Subsystems s) {
    return new SequentialCommandGroup(getGrabberOpenCommand(s.grabber), new WaitCommand(0.25),
        new AltWristControl(s.wrist).raceWith(
            new SequentialCommandGroup(new WaitCommand(1), getGrabberCloseCommand(s.grabber), new WaitCommand(1))),
        new WaitCommand(1));
  }

  public static Command stowAnd(Subsystems s, Command... commands) {
    return new ParallelRaceGroup(new SequentialCommandGroup(commands), new SequentialCommandGroup( // Start moving the arm 1 second into the path following
        new WaitCommand(1), new StowArm(s.arm, s.wrist)));
  }

  public static Command getGrabberOpenCommand(Grabber grabber) {
    return new InstantCommand(() -> {
      grabber.open();
    }, grabber);
  }

  public static Command getGrabberCloseCommand(Grabber grabber) {
    return new InstantCommand(() -> {
      grabber.close();
    }, grabber);
  }

  public static PathPlannerTrajectory getPathByName(String pathName, PathConstraints constraints) {
    return getPathByName(pathName, constraints, false);
  }

  public static PathPlannerTrajectory getPathByName(String pathName, PathConstraints constraints, boolean reversed) {
    //just curious what it will give us
    Logger.getInstance().recordOutput("Auton/Event Name", DriverStation.getEventName());
    if (DriverStation.getAlliance() == Alliance.Red) {
      var overridePath = PathPlanner.loadPath(Constants.AUTON.EVENT_NAME + "_Red_" + pathName, constraints, reversed);
      if (overridePath != null) {
        Logger.getInstance().recordOutput("Auton/Last Loaded Path", Constants.AUTON.EVENT_NAME + "_Red_" + pathName);
        return overridePath;
      }
    } else {
      var overridePath = PathPlanner.loadPath(Constants.AUTON.EVENT_NAME + "_Blue_" + pathName, constraints, reversed);
      if (overridePath != null) {
        Logger.getInstance().recordOutput("Auton/Last Loaded Path", Constants.AUTON.EVENT_NAME + "_Blue_" + pathName);
        return overridePath;
      }
    }
    /* Both alliances */
    var path = PathPlanner.loadPath(Constants.AUTON.EVENT_NAME + "_" + pathName, constraints, reversed);
    if (path != null) {
      Logger.getInstance().recordOutput("Auton/Last Loaded Path", Constants.AUTON.EVENT_NAME + "_" + pathName);
      return path;
    }

    /* Actual path */
    path = PathPlanner.loadPath(pathName, constraints, reversed);
    if (path == null) {
      DriverStation.reportError("Failed to load path: " + pathName, true);
    }

    Logger.getInstance().recordOutput("Auton/Last Loaded Path", pathName);
    return path;
  }

  public static Command getCommandForPath(String pathName, boolean resetOdometry, PathConstraints constraints,
      Swerve swerve) {
    return getCommandForPath(pathName, resetOdometry, constraints, swerve, false);
  }

  public static Command getCommandForPath(String pathName, boolean resetOdometry, PathConstraints constraints,
      Swerve swerve, boolean reversed) {
    return new CustomProxy(() -> {
      //   var path = PathPlanner.loadPath(pathName, constraints);
      var path = getPathByName(pathName, constraints, reversed);
      return swerve.followTrajectoryCommand(path, resetOdometry, true);
    });
  }

  public static Command setInitPose(Subsystems s, String pathName) {
    return new InstantCommand(() -> {
      PathPlannerTrajectory path = PathPlanner.loadPath(pathName, Constants.AUTON.SLOW_CONSTRAINTS);
      path = PathPlannerTrajectory.transformTrajectoryForAlliance(path, DriverStation.getAlliance());
      var initPose = path.getInitialPose();
      s.swerve.setPose(initPose);
    });
  }
}
//format:on
package frc.robot.auton;

import java.util.HashMap;
import com.pathplanner.lib.PathConstraints;
import com.pathplanner.lib.commands.FollowPathWithEvents;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.ParallelCommandGroup;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import edu.wpi.first.wpilibj2.command.WaitCommand;
import frc.robot.Constants;
import frc.robot.commands.arm.SetArmPose;
import frc.robot.commands.arm.SetArmPose.ArmPose;
import frc.robot.commands.drive.AutoBalDriveToPivot;
import frc.robot.commands.drive.AutoBalance;
import frc.robot.commands.drive.rotateTo;
import frc.robot.subsystems.Subsystems;
import frc.robot.util.CustomProxy;

// format: off
public class AutonPaths {
  /* Places cone in high node, goes to GP1 to pick up a cube, places it in low hybrid node
   * ASSUMPTIONS: Cone preloaded, arm already inside robot, in inert pos, pos constants correct
   */

  private static PathConstraints defaultConstraints = Constants.AUTON.MID_CONSTRAINTS;

  public static Command InertN4PlaceThenDock(Subsystems s) {
    return new SequentialCommandGroup(AutonHelper.setInitPose(s, "InertN4-StartN4"),

        // Move forward
        new SetArmPose(s.arm, ArmPose.HIGH_NODE),

        AutonHelper.getCommandForPath("InertN4-StartN4", true, defaultConstraints, s.swerve),

        // place game piece
        AutonHelper.getPlaceConeCommand(s),

        AutonHelper.stowAnd(s,
            AutonHelper.getCommandForPath("StartN4-PrepareDock", false, Constants.AUTON.DOCK_CONSTRAINTS, s.swerve),
            new AutoBalDriveToPivot(s.swerve).andThen(new AutoBalance(s.swerve))));
  }

  public static Command InertN1Place(Subsystems s) {
    return new SequentialCommandGroup(AutonHelper.setInitPose(s, "InertN4-StartN4"),

        // Move forward
        new SetArmPose(s.arm, ArmPose.HIGH_NODE),

        AutonHelper.getCommandForPath("InertN4-StartN4", true, defaultConstraints, s.swerve),

        // place game piece
        AutonHelper.getPlaceConeCommand(s));
  }

  public static Command InertN1PlaceThenExplore(Subsystems s) {
    return new SequentialCommandGroup(AutonHelper.setInitPose(s, "InertN1-StartN1"),

        // Move forward
        new SetArmPose(s.arm, ArmPose.HIGH_NODE),

        AutonHelper.getCommandForPath("InertN1-StartN1", true, defaultConstraints, s.swerve),

        // place game piece
        AutonHelper.getPlaceConeCommand(s),

        AutonHelper.stowAnd(s, AutonHelper.getCommandForPath("StartN1-Explore", false, defaultConstraints, s.swerve)));
  }

  public static Command InertN9PlaceThenExplore(Subsystems s) {
    return new SequentialCommandGroup(AutonHelper.setInitPose(s, "InertN9-StartN9"),

        // Move forward
        new SetArmPose(s.arm, ArmPose.HIGH_NODE),

        AutonHelper.getCommandForPath("InertN9-StartN9", true, defaultConstraints, s.swerve),

        // place game piece
        AutonHelper.getPlaceConeCommand(s),

        AutonHelper.stowAnd(s, AutonHelper.getCommandForPath("StartN9-Explore", false, defaultConstraints, s.swerve)));
  }

  public static Command InertN1SafeTwoCone(Subsystems s) {
    return new SequentialCommandGroup(AutonHelper.setInitPose(s, "InertN1-StartN1"),
        AutonHelper.setInitPose(s, "InertN1-StartN1"),
        // Move forward
        new SetArmPose(s.arm, ArmPose.HIGH_NODE),

        AutonHelper.getCommandForPath("InertN1-StartN1", true, defaultConstraints, s.swerve),

        // place game piece
        AutonHelper.getPlaceConeCommand(s),

        new ParallelCommandGroup(
            AutonHelper.getCommandForPath("StartN1-GamePiece1-No-Turn", false, Constants.AUTON.DOUBLE_CONE, s.swerve),
            new SequentialCommandGroup( // Start moving the arm 1 second into the path following
                new WaitCommand(1), new SetArmPose(s.arm, ArmPose.FLOOR))),
        new rotateTo(s.swerve, Rotation2d.fromDegrees(0)),

        AutonHelper.getGroundPickUpCommand(s),

        new rotateTo(s.swerve, Rotation2d.fromDegrees(180)),

        AutonHelper.stowAnd(s,
            AutonHelper.getCommandForPath("GamePiece1-InertN3-No-Turn", false, defaultConstraints, s.swerve))

    // places cone
    // new SetArmPose(s.arm, ArmPose.HIGH_NODE),

    // AutonHelper.getCommandForPath("InertN3-StartN3", false, defaultConstraints, s.swerve),

    // AutonHelper.getPlaceConeCommand(s)
    );
  }

  /* NOT USED FOR WAYNE STATE (add back later)----------------------------------------------------------------------- */

  public static Command InertN4GrabThenDock(Subsystems s) {
    return new SequentialCommandGroup(AutonHelper.setInitPose(s, "InertN4-StartN4"),

        // Move forward
        new SetArmPose(s.arm, ArmPose.HIGH_NODE),

        AutonHelper.getCommandForPath("InertN4-StartN4", true, defaultConstraints, s.swerve),

        // place game piece
        AutonHelper.getPlaceConeCommand(s),

        new CustomProxy(() -> {
          var path = AutonHelper.getPathByName("StartN4-ExploreOverStation-GamePiece2", defaultConstraints);
          var pathCommand = AutonHelper.getCommandForPath("StartN4-ExploreOverStation-GamePiece2", false,
              defaultConstraints, s.swerve);
          HashMap<String, Command> eventMap = new HashMap<>();
          eventMap.put("stow_arm", new SetArmPose(s.arm, ArmPose.FLOOR));

          return new FollowPathWithEvents(pathCommand, path.getMarkers(), eventMap);
        }),

        AutonHelper.getGroundPickUpCommand(s), new SetArmPose(s.arm, ArmPose.INSIDE_ROBOT),

        AutonHelper.stowAnd(s,
            AutonHelper.getCommandForPath("ExploreOverStation-Dock", false, defaultConstraints, s.swerve)),

        new AutoBalDriveToPivot(s.swerve).andThen(new AutoBalance(s.swerve)));
  }

  public static Command InertN12ConePrime(Subsystems s) {
    return new SequentialCommandGroup(AutonHelper.setInitPose(s, "InertN1-StartN1"),

        // Move forward
        new SetArmPose(s.arm, ArmPose.HIGH_NODE),

        AutonHelper.getCommandForPath("InertN1-StartN1", true, defaultConstraints, s.swerve),

        // place game piece
        AutonHelper.getPlaceConeCommand(s),

        new ParallelCommandGroup(
            AutonHelper.getCommandForPath("StartN1-GamePiece1-Prime", false, defaultConstraints, s.swerve),
            new SequentialCommandGroup( // Start moving the arm 1 second into the path following
                new WaitCommand(1), new SetArmPose(s.arm, ArmPose.FLOOR))),

        AutonHelper.getGroundPickUpCommand(s), new SetArmPose(s.arm, ArmPose.INSIDE_ROBOT),

        AutonHelper.stowAnd(s,
            AutonHelper.getCommandForPath("GamePiece1-Inert3-Prime", false, defaultConstraints, s.swerve))

    // new SetArmPose(s.arm, ArmPose.HIGH_NODE),

    // AutonHelper.getCommandForPath("InertN3-StartN3", true, defaultConstraints, s.swerve),

    // // place game piece
    // AutonHelper.getPlaceConeCommand(s)
    );
  }

  public static Command InertN92Cone(Subsystems s) {
    return new SequentialCommandGroup(AutonHelper.setInitPose(s, "InertN9-StartN9"),

        // Move forward
        new SetArmPose(s.arm, ArmPose.HIGH_NODE),

        AutonHelper.getCommandForPath("InertN9-StartN9", true, defaultConstraints, s.swerve),

        // place game piece
        AutonHelper.getPlaceConeCommand(s),

        new CustomProxy(() -> {
          var path = AutonHelper.getPathByName("StartN9-GamePiece1", defaultConstraints);
          var pathCommand = AutonHelper.getCommandForPath("StartN9-GamePiece1", false, defaultConstraints, s.swerve);
          HashMap<String, Command> eventMap = new HashMap<>();
          eventMap.put("arm_toggle", new SetArmPose(s.arm, ArmPose.FLOOR));

          return new FollowPathWithEvents(pathCommand, path.getMarkers(), eventMap);
        }),

        new rotateTo(s.swerve, Rotation2d.fromDegrees(0)), AutonHelper.getGroundPickUpCommand(s),
        new rotateTo(s.swerve, Rotation2d.fromDegrees(180)),

        new CustomProxy(() -> {
          var path = AutonHelper.getPathByName("GamePiece1-StartN9", defaultConstraints);
          var pathCommand = AutonHelper.getCommandForPath("GamePiece1-StartN9", false, defaultConstraints, s.swerve);
          HashMap<String, Command> eventMap = new HashMap<>();
          eventMap.put("arm_toggle", new SetArmPose(s.arm, ArmPose.INSIDE_ROBOT));

          return new FollowPathWithEvents(pathCommand, path.getMarkers(), eventMap);
        }));

    // place game piece
    // AutonHelper.getPlaceConeCommand(s));
  }
  // public static CommandBase InertN4ExploreOverStationDock(Subsystems s) {
  //   return new SequentialCommandGroup(setInitPose(s, "InertN4-StartN4"), new SetArmPose(s.arm, ArmPose.HIGH_NODE),
  //       getCommandForPath("InertN4-StartN4", true, defaultConstraints, s.swerve),

  //       getPlaceConeCommand(s),

  //       stowAnd(s,
  //           getCommandForPath("StartN4-ExploreOverStation", false, defaultConstraints, s.swerve),
  //           getCommandForPath("ExploreOverStation-Dock", false, defaultConstraints, s.swerve),
  //           new AutoBalDriveToPivot(s.swerve).andThen(new AutoBalance(s.swerve))
  // );
  // }

  // public static CommandBase InertN1PlaceThenDock(Subsystems s) {
  //   return new SequentialCommandGroup(
  //       // Move forward
  //       // new ParallelCommandGroup(
  //       new SetArmPose(s.arm, ArmPose.HIGH_NODE),
  //       getCommandForPath("InertN1-StartN1", true, defaultConstraints, s.swerve),
  //       // ),

  //       // place game piece
  //       getPlaceConeCommand(s),

  //       // Go to charging station
  //       stowAnd(s, getCommandForPath("StartN1-Explore-PrepareDock", false, defaultConstraints, s.swerve),
  //           new AutoBalDriveToPivot(s.swerve).andThen(new AutoBalance(s.swerve)));
  // }

  // public static CommandBase InertN1TwoConePath(Subsystems s) {
  //   return new SequentialCommandGroup(
  //     setInitPose(s, "InertN1-StartN1"),
  //       // Move forward
  //       new SetArmPose(s.arm, ArmPose.HIGH_NODE),
  //       getCommandForPath("InertN1-StartN1", true, defaultConstraints, s.swerve),

  //       // place game piece
  //       getPlaceConeCommand(s),

  //       // Go get game piece
  //       new ParallelCommandGroup(new SetArmPose(s.arm, ArmPose.FLOOR),
  //         getCommandForPath("StartN1-GamePiece1", false, defaultConstraints, s.swerve)
  //       ),

  //       // pick up game piece
  //       getGroundPickUpCommand(s),


  //       // go back to grid node 3 inert
  //       new ParallelCommandGroup(
  //           getCommandForPath("GamePiece1-StartN3", false, defaultConstraints, s.swerve),
  //           new WaitCommand(1).andThen(new SetArmPose(s.arm, ArmPose.HIGH_NODE))),

  //       // Place game piece
  //       getPlaceConeCommand(s));
  // }

  // public static CommandBase InertN9TwoConePath(Subsystems s) {
  //   return new SequentialCommandGroup(
  //     setInitPose(s, "InertN9-StartN9"),
  //       // Move forward
  //       new SetArmPose(s.arm, ArmPose.HIGH_NODE),
  //       getCommandForPath("InertN9-StartN9", true, defaultConstraints, s.swerve),

  //       // place game piece
  //       getPlaceConeCommand(s),

  //       // Go get game piece
  //       stowAnd(s, getCommandForPath("StartN9-GamePiece9", false, defaultConstraints, s.swerve)),

  //       // pick up game piece
  //       getGroundPickUpCommand(s),

  //       // go back to grid node 3 inert
  //       new ParallelCommandGroup(
  //           getCommandForPath("GamePiece9-StartN7", false, defaultConstraints, s.swerve),
  //           new SetArmPose(s.arm, ArmPose.HIGH_NODE)),

  //       // Place game piece
  //       getPlaceConeCommand(s));
  // }

  // public static CommandBase InertN9PlaceThenDock(Subsystems s) {
  //   return new SequentialCommandGroup(
  //       // Move forward
  //       // new ParallelCommandGroup(
  //       new SetArmPose(s.arm, ArmPose.HIGH_NODE),
  //       getCommandForPath("InertN9-StartN9", true, defaultConstraints, s.swerve),
  //       // ),

  //       // place game piece
  //       getPlaceConeCommand(s),

  //       // Go to charging station
  //       stowAnd(s, getCommandForPath("StartN9-Explore-PrepareDock", false, defaultConstraints, s.swerve)),

  //       new AutoBalDriveToPivot(s.swerve).andThen(new AutoBalance(s.swerve)

  //   );
  // }

  // public static CommandBase InertN1GrabThenDock(Subsystems s) {
  //   return new SequentialCommandGroup(
  //       // Move forward
  //       new SetArmPose(s.arm, ArmPose.HIGH_NODE),
  //       getCommandForPath("InertN1-StartN1", true, defaultConstraints, s.swerve),

  //       // place game piece
  //       getPlaceConeCommand(s),

  //       // Go get game piece
  //       stowAnd(s, getCommandForPath("StartN1-GamePiece1", false, defaultConstraints, s.swerve)),

  //       // pick up game piece
  //       getGroundPickUpCommand(s),

  //       // go back to grid node 3 inert
  //       new ParallelCommandGroup(
  //           getCommandForPath("GamePiece1-PrepareDock", false, defaultConstraints, s.swerve),
  //           new SetArmPose(s.arm, ArmPose.INSIDE_ROBOT)),

  //       // run autobalance 
  //       new AutoBalDriveToPivot(s.swerve).andThen(new AutoBalance(s.swerve));

  // }

  // public static CommandBase InertN9GrabThenDock(Subsystems s) {
  //   return new SequentialCommandGroup(
  //       // Move forward
  //       new SetArmPose(s.arm, ArmPose.HIGH_NODE),
  //       getCommandForPath("InertN9-StartN9", true, defaultConstraints, s.swerve),

  //       // place game piece
  //       getPlaceConeCommand(s),

  //       // Go get game piece
  //       stowAnd(s, getCommandForPath("StartN9-GamePiece9", false, defaultConstraints, s.swerve)),

  //       // pick up game piece
  //       getGroundPickUpCommand(s),

  //       // go back to grid node 3 inert
  //       new ParallelCommandGroup(
  //           getCommandForPath("GamePiece9-PrepareDock", false, defaultConstraints, s.swerve),
  //           new SetArmPose(s.arm, ArmPose.INSIDE_ROBOT)),

  //       new AutoBalDriveToPivot(s.swerve).andThen(new AutoBalance(s.swerve));

  // }

  // public static CommandBase InertN9StraightToDock(Subsystems s) {
  //   return new SequentialCommandGroup(
  //       // Move forward
  //       new SetArmPose(s.arm, ArmPose.HIGH_NODE),
  //       getCommandForPath("InertN9-StartN9", true, defaultConstraints, s.swerve),

  //       // place game piece
  //       getPlaceConeCommand(s),

  //       //go to autobalance pose
  //       stowAnd(s, getCommandForPath("InertN9-PrepareDock", false, defaultConstraints, s.swerve)),

  //       // run autobalance here
  //       new AutoBalDriveToPivot(s.swerve).andThen(new AutoBalance(s.swerve));
  // }

  // public static CommandBase InertN1StraightToDock(Subsystems s) {
  //   return new SequentialCommandGroup(
  //       // Move forward
  //       new SetArmPose(s.arm, ArmPose.HIGH_NODE),
  //       getCommandForPath("InertN1-StartN1", true, defaultConstraints, s.swerve),

  //       // place game piece
  //       getPlaceConeCommand(s),

  //       //go to autobalance pose
  //       stowAnd(s, getCommandForPath("InertN1-PrepareDock", false, defaultConstraints, s.swerve)),

  //       // run autobalance here
  //       new AutoBalDriveToPivot(s.swerve).andThen(new AutoBalance(s.swerve));
  // }
}

// format: on
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.auton;

import com.pathplanner.lib.PathConstraints;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Transform2d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.ProxyCommand;
import frc.robot.Constants;
import frc.robot.subsystems.drive.Swerve;
import frc.robot.util.MoreMath;

public class TestPlaceThenDock extends ProxyCommand {
  /** Creates a new TestPlaceThenDock. */
  public TestPlaceThenDock(Swerve s) {
    super(() -> {

      var defaultPath = AutonHelper.getPathByName("StartN4-PrepareDock", Constants.AUTON.DOCK_CONSTRAINTS);
      // defaultPath = PathPlannerTrajectory.transformTrajectoryForAlliance(defaultPath, DriverStation.getAlliance());
      var startPose = defaultPath.getInitialPose();
      var endPose = MoreMath.deepCopyPose(startPose);

      var x = SmartDashboard.getNumber("DOCK TESTING/test x", 0);
      var vel = SmartDashboard.getNumber("DOCK TESTING/test vel", 0);
      var acc = SmartDashboard.getNumber("DOCK TESTING/test acc", 0);

      var translation = new Translation2d(x, 0);
      endPose = new Pose2d(endPose.getTranslation().plus(translation), endPose.getRotation());
      var end = endPose;

      var constraints = new PathConstraints(vel, acc);

      return new InstantCommand(() -> {
        s.setPose(startPose);
      }, s).andThen(new ProxyCommand(() -> {
        return s.goTo(end, constraints);
      }));
    });
  }

  public static void initDockTestingTelemetry() {
    var defaultVel = Constants.AUTON.DOCK_CONSTRAINTS.maxVelocity;
    var defaultAcc = Constants.AUTON.DOCK_CONSTRAINTS.maxAcceleration;

    var path = AutonHelper.getPathByName("StartN4-PrepareDock", Constants.AUTON.DOCK_CONSTRAINTS);

    var startPose = path.getInitialPose();
    var endPose = path.getEndState().poseMeters;
    var transform = new Transform2d(startPose, endPose);

    var translation = transform.getTranslation();

    var defaultX = translation.getX();

    SmartDashboard.putNumber("DOCK TESTING/default x", defaultX);
    SmartDashboard.putNumber("DOCK TESTING/default vel", defaultVel);
    SmartDashboard.putNumber("DOCK TESTING/default acc", defaultAcc);

    SmartDashboard.putNumber("DOCK TESTING/test x", defaultX);
    SmartDashboard.putNumber("DOCK TESTING/test vel", defaultVel);
    SmartDashboard.putNumber("DOCK TESTING/test acc", defaultAcc);
  }
}
package frc.robot;

/**
 * Automatically generated file containing build version information.
 */
public final class BuildConstants {
  public static final String MAVEN_GROUP = "";
  public static final String MAVEN_NAME = "2023Robot";
  public static final String VERSION = "unspecified";
  public static final int GIT_REVISION = 326;
  public static final String GIT_SHA = "1ee5c6649146302bc51528cf19eaf1c3ff7828fa";
  public static final String GIT_DATE = "2023-03-18T18:12:31Z";
  public static final String GIT_BRANCH = "apriltag-dependent";
  public static final String BUILD_DATE = "2023-03-18T18:15:16Z";
  public static final long BUILD_UNIX_TIME = 1679177716882L;
  public static final int DIRTY = 0;

  private BuildConstants(){}
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.arm;

import edu.wpi.first.math.MathUtil;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.Constants;
import frc.robot.controllers.Controllers;
import frc.robot.subsystems.arm.Arm;
import frc.robot.subsystems.arm.Arm.ArmControlMode;

public class JoystickArmControl extends CommandBase {
  private Arm arm;

  /** Creates a new JoystickArmControl. */
  public JoystickArmControl(Arm arm) {
    // Use addRequirements() here to declare subsystem dependencies.
    this.arm = arm;
    addRequirements(arm);
  }

  // Called when the command is initially scheduled.
  @Override
  public void initialize() {
    // arm.setPoseGoal(arm.getPose());
    // arm.resetPIDs();
  }

  // Called every time the scheduler runs while the command is scheduled.
  @Override
  public void execute() {
    double pov = Controllers.operatorController.getPOVAngle();
    double axis = Controllers.operatorController.getArmAxis();
    double armPose = arm.getPose();

    SmartDashboard.putNumber("Arm/Axis", axis);
    SmartDashboard.putNumber("Arm/pov", pov);
    axis = Math.pow(axis, 3);

    double armvel = axis * Constants.ARM.VELOCITY;
    if (pov != -1) {
      double posvel = 0;
      if (pov > 90 && pov < 270) {
        posvel = 15;
      } else if (pov > 270 || pov < 90) {
        posvel = -15;
      }
      if (armPose < 90 && armPose > -90) {
        posvel *= -1;
      }
      armvel += posvel;
    }

    if(MathUtil.applyDeadband(armvel, 0.1) != 0){
      arm.setControlMode(ArmControlMode.VEL);
      arm.setVelGoal(armvel);
    }else{
      arm.setControlMode(ArmControlMode.POS);
    }
  }

  // Called once the command ends or is interrupted.
  @Override
  public void end(boolean interrupted) {
    arm.setVelGoal(0);
  }

  // Returns true when the command should end.
  @Override
  public boolean isFinished() {
    return false;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.arm;

import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.Constants;
import frc.robot.controllers.Controllers;
import frc.robot.subsystems.arm.Arm;
import frc.robot.subsystems.arm.Arm.ArmControlMode;

public class SetArmPose extends CommandBase {
  private Arm arm;
  private ArmPose armPose;

  public enum ArmPose {
    FLOOR(-65), HIGH_NODE(4.58), MID_NODE(-15.46), LOW_NODE(-61.87), FEEDER_STATION(-184), INSIDE_ROBOT(-110);

    public double val;

    private ArmPose(double val) {
      this.val = val;
    }

  }

  /**
   * Sets arm to a given pose
   * 
   * @param armPose Desired arm pose
   */
  public SetArmPose(Arm arm, ArmPose armPose) {
    // Use addRequirements() here to declare subsystem dependencies.
    this.arm = arm;
    this.armPose = armPose;
    addRequirements(arm);
  }

  // Called when the command is initially scheduled.
  @Override
  public void initialize() {
    arm.setControlMode(ArmControlMode.POS);
    arm.setPoseGoal(armPose.val);
  }

  // Called once the command ends or is interrupted.
  @Override
  public void end(boolean interrupted) {}

  // Returns true when the command should end.
  @Override
  public boolean isFinished() {
    if (Controllers.operatorController.setArmByJoystick().getAsBoolean()) {
      return true;
    }

    double goal = armPose.val;
    double currentPose = arm.getPose();
    double poseError = goal - currentPose;
    poseError = Math.abs(poseError);
    return poseError < Constants.ARM.POSE_TOLERANCE;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.arm;

import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import frc.robot.commands.arm.SetArmPose.ArmPose;
import frc.robot.commands.wrist.DefaultWristControl;
import frc.robot.commands.wrist.ManualWristControl;
import frc.robot.subsystems.arm.Arm;
import frc.robot.subsystems.wrist.Wrist;
import frc.robot.subsystems.wrist.WristState;

public class StowArm extends SequentialCommandGroup {
  /** Creates a new StowArm. */
  public StowArm(Arm arm, Wrist wrist) {
    super(
      new SetArmPose(arm, ArmPose.INSIDE_ROBOT).raceWith(new DefaultWristControl(wrist)), 
      new ManualWristControl(wrist, WristState.RIGHT));
    // Use addRequirements() here to declare subsystem dependencies.
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.arm;

import edu.wpi.first.math.trajectory.TrapezoidProfile;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.Constants.ARM;
import frc.robot.subsystems.Grabber;
import frc.robot.subsystems.arm.Arm;
import frc.robot.subsystems.leds.LedState;
import frc.robot.subsystems.leds.Leds;
import frc.robot.subsystems.wrist.Wrist;
import frc.robot.subsystems.wrist.WristState;

public class Throw extends CommandBase {
  private static final double waitTime = 1;
  private static final double wristTolerance =5;
  private static final double armTolerance = 2;
  private Arm arm;
  private Wrist wrist;
  private Grabber grabber;
  private ThrowState releaseState;
  private ThrowState initState;
  private ThrowState finalState;
  private int phase;
  private ThrowState lastState;
  private boolean waiting;
  private double lastTime;
  private Leds leds;

  /** Creates a new Throw. */
  public Throw(Arm arm, Wrist wrist, Grabber grabber, Leds leds, ThrowState releaseState) {
    this.arm = arm;
    this.wrist = wrist;
    this.grabber=grabber;
    this.leds=leds;
    this.releaseState = releaseState;
    addRequirements(arm, wrist, grabber, leds);
  }

  @Override
  public void initialize() {
    //calc init state

    //calculate min distance for arm to reach release state
    // v^2=2ax
    // x = v^2/(2a)
    var currentPose=arm.getPose(); // remove
    var accSign = Math.signum(releaseState.armSpeed);
    var acc = accSign * ARM.ARM_CONSTRAINTS.maxAcceleration / 20;
    var deltaPose = Math.pow(releaseState.armSpeed,2)/(2*acc);

    var initArmPose = releaseState.armPose - deltaPose;
    this.initState = new ThrowState(initArmPose,0,this.releaseState.wristPose);

    this.finalState = new ThrowState(this.releaseState.armPose, 0, this.releaseState.wristPose);

    this.phase=1;

    this.lastState=new ThrowState(arm.getPose(), 0, wrist.getPose());
    leds.setState(LedState.WHITE);

    SmartDashboard.putBoolean("throw/on?", true);

    logState(initState, "init");
    logState(releaseState, "release");
    logState(finalState, "final");


    this.lastTime=-1;
    this.waiting=false;
  }

  // Called every time the scheduler runs while the command is scheduled.
  @Override
  public void execute() {
    SmartDashboard.putNumber("throw/phase", phase);
    switch(phase){
      case 1:
      setThrowState(this.initState);
      if(reached(this.initState)){ 
        phase++;
        this.lastState=getCurrentState();
      }
      break;
      case 2:
      setThrowState(this.releaseState);
      leds.setState(LedState.GREEN);
      if(reached(this.releaseState)){ 
        phase++;
        this.lastState=getCurrentState();
        grabber.open();
        logState(getCurrentState(), "empirical");
      }
      break;
      case 3:
      var currentTime = Timer.getFPGATimestamp();
      leds.setState(LedState.ORANGE);
      if(!waiting){
        lastTime = currentTime;
        waiting=true;
      }else if(currentTime - lastTime > waitTime){
        this.lastState=getCurrentState();
        phase++;
      }
      break;
      case 4:
      setThrowState(this.finalState);
      leds.setState(LedState.WHITE);
      grabber.close();
      if(reached(this.finalState)){ 
        phase++;
        this.lastState=getCurrentState();
      }
      break;
    }
  }

  private void setThrowState(ThrowState state){
    var armGoal = new TrapezoidProfile.State(state.armPose, state.armSpeed);
    this.arm.setPoseGoal(armGoal);
    
    var wristGoal = WristState.getStateWithGoal(state.wristPose);
    this.wrist.setGoal(wristGoal);
  }

  private boolean reached(ThrowState state) {
    boolean armPast;
    var armClose = Math.abs(arm.getPose() - state.armPose) < armTolerance;
    
    var currentArmPose = arm.getPose();//remove
    var moveDir = Math.signum(state.armPose - lastState.armPose);
    if(moveDir>0){
      armPast = arm.getPose() > state.armPose;
    }else{
      armPast = arm.getPose() < state.armPose;
    }

    var armReached = armPast || armClose;
    var wristReached = Math.abs(state.wristPose - wrist.getPose()) < wristTolerance;

    return wristReached && armReached;
  }

  private ThrowState getCurrentState(){
    return new ThrowState(arm.getPose(), arm.getVel(), wrist.getPose());
  }

  @Override
  public void end(boolean interrupted){
    SmartDashboard.putBoolean("throw/on?", false);
    this.arm.setPoseGoal(this.arm.getPose());
  }

  public void logState(ThrowState state, String path){
    SmartDashboard.putNumber("throw/" + path + "/arm pose", state.armPose);
    SmartDashboard.putNumber("throw/" + path + "/arm speed", state.armSpeed);
    SmartDashboard.putNumber("throw/" + path + "/wrist pose", state.wristPose);
  }

  // Returns true when the command should end.
  @Override
  public boolean isFinished() {
    return phase==5;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.arm;

/** Add your docs here. */
public class ThrowState{
    public double wristPose;
    public double armSpeed;
    public double armPose;

    public ThrowState(double armPose, double armSpeed, double wristPose){
      this.armPose=armPose;
      this.armSpeed=armSpeed;
      this.wristPose=wristPose;
    }
  }
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.drive;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.ProxyCommand;
import frc.robot.Constants.FIELD_CONSTANTS;
import frc.robot.Constants.AUTO_ALIGN.FEEDER;
import frc.robot.Constants.AUTO_ALIGN.GRID;
import frc.robot.subsystems.arm.Arm;
import frc.robot.subsystems.drive.Swerve;
import frc.robot.util.MoreMath;

public class AutoAlign extends ProxyCommand {
  public AutoAlign(Swerve swerve, Arm arm) {
    super(() -> {
      return proxy(swerve, arm);
    });
  }

  public static Command proxy(Swerve swerve, Arm arm) {
    if (inCommunity(swerve.getPose())) {
      return new GridAlign(swerve, arm);
    } else if (inFeederArea(swerve.getPose())) {
      return new FeederAlign(swerve, arm);
    } else {
      return new InstantCommand();
    }

  }

  private static boolean inCommunity(Pose2d pose) {
    return pose.getX() < GRID.COMMUNITY_THRESHOLD;
  }

  private static boolean inFeederArea(Pose2d pose) {
    var xCheck = MoreMath.within(pose.getX(), FEEDER.MIN_X, FEEDER.MAX_X);
    var yCheck = MoreMath.within(pose.getY(), FEEDER.MIN_Y, FEEDER.MAX_Y);
    if (!MoreMath.isBlue()) {
      yCheck = MoreMath.within(pose.getY(), FIELD_CONSTANTS.WIDTH - FEEDER.MIN_Y, FIELD_CONSTANTS.WIDTH - FEEDER.MAX_Y);
    }
    return xCheck && yCheck;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.drive;

import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.Constants.AUTON;
import frc.robot.subsystems.drive.Swerve;

public class AutoBalance extends CommandBase {
  // assumes already on chargin station.
  private Swerve swerve;
  private PIDController balancePid = AUTON.AUTO_BALANCE_PID;

  /** Creates a new AutoBalance. */
  public AutoBalance(Swerve swerve) {
    this.swerve = swerve;
    addRequirements(swerve);
    SmartDashboard.putData("AutoBalancePID", balancePid);
    // Use addRequirements() here to declare subsystem dependencies.
  }

  // Called when the command is initially scheduled.
  @Override
  public void initialize() {
    balancePid.reset();
    balancePid.setTolerance(1.5);
  }

  // Called every time the scheduler runs while the command is scheduled.
  @Override
  public void execute() {
    double pitch = swerve.getPitch();
    double roll = swerve.getRoll();

    var vx = balancePid.calculate(roll, 0);

    swerve.drive(new ChassisSpeeds(vx, 0, 0));

  }

  // Called once the commak nd ends or is interrupted.
  @Override
  public void end(boolean interrupted) {
    swerve.setX();
  }

  // Returns true when the command should end.
  @Override
  public boolean isFinished() {
    return false;
  }
}
package frc.robot.commands.drive;

import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.Constants.AUTON;
import frc.robot.subsystems.drive.Swerve;

public class AutoBalDriveToPivot extends CommandBase {
  private Swerve swerve;

  /** Creates a new AutoBalance. */
  public AutoBalDriveToPivot(Swerve swerve) {
    this.swerve = swerve;
    // Use addRequirements() here to declare subsystem dependencies.
    addRequirements(swerve);
  }

  // Called when the command is initially scheduled.
  @Override
  public void initialize() {}

  // Called every time the scheduler runs while the command is scheduled.
  @Override
  public void execute() {
    swerve.drive(new ChassisSpeeds(Math.signum(swerve.getPitch()) * AUTON.AUTO_BALANCE_VEL, 0, 0)); // 2.5 m/s
  }

  // Called once the commak nd ends or is interrupted.
  @Override
  public void end(boolean interrupted) {
    swerve.drive(new ChassisSpeeds(0, 0, 0));
  }

  // Returns true when the command should end.
  @Override
  public boolean isFinished() {
    double roll = swerve.getRoll();
    if (roll < AUTON.AUTO_BALANCE_PIVOT_ROLL) {
      return true;
    }
    return false;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.drive;

import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import com.pathplanner.lib.PathPlanner;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import frc.robot.Constants.AUTO_ALIGN.FEEDER;
import frc.robot.commands.arm.SetArmPose;
import frc.robot.commands.arm.SetArmPose.ArmPose;
import frc.robot.controllers.Controllers;
import frc.robot.subsystems.arm.Arm;
import frc.robot.subsystems.drive.Swerve;
import frc.robot.util.MoreMath;

public class FeederAlign extends SequentialCommandGroup {
  /** Creates a new FeederAlign. */
  public FeederAlign(Swerve swerve, Arm arm) {
    if (isYAligned(swerve) && isArmRaised(arm) && isClose(swerve) && isRotated(swerve)) {
      addCommands(simpleAlign(swerve, arm));
    } else {
      // still needs some more work
      // addCommands(prepThenGoToDest(swerve, arm));
      addCommands(new InstantCommand());
    }
  }

  private static Command prepThenGoToDest(Swerve swerve, Arm arm) {

    var startPose = swerve.getPose();
    var prepPose = getPrepPose(startPose);
    var destPose = getDestPose(startPose);

    var startHeading = MoreMath.calcHeading(startPose, prepPose);
    var startPoint = MoreMath.createPathPoint(startPose, startHeading);

    var prepHeading = MoreMath.calcHeading(prepPose, destPose);
    var prepPoint = MoreMath.createPathPoint(prepPose, prepHeading);

    var destHeading = prepHeading;
    var destPoint = MoreMath.createPathPoint(destPose, destHeading);

    var startToPrepTraj = PathPlanner.generatePath(FEEDER.CONSTRAINTS, startPoint, prepPoint);
    var startToPrepCommand = swerve.followTrajectoryCommand(startToPrepTraj, false, true);

    var prepToDestTraj = PathPlanner.generatePath(FEEDER.CONSTRAINTS, prepPoint, destPoint);
    var prepToDestCommand = swerve.followTrajectoryCommand(prepToDestTraj, false, true);

    var rotateCommand = new rotateTo(swerve, Rotation2d.fromDegrees(180));

    var raiseArmCommand = new SetArmPose(arm, ArmPose.FEEDER_STATION);

    return new SequentialCommandGroup(startToPrepCommand, rotateCommand, raiseArmCommand, prepToDestCommand);
  }

  private static Command simpleAlign(Swerve swerve, Arm arm) {
    var startPose = swerve.getPose();
    var endPose = getDestPose(startPose);
    var traj = MoreMath.createStraightPath(startPose, endPose, FEEDER.CONSTRAINTS);

    var trajCommand = swerve.followTrajectoryCommand(traj, false, true);
    var armCommand = new SetArmPose(arm, ArmPose.FEEDER_STATION);

    return trajCommand.alongWith(armCommand);
  }

  private static boolean isYAligned(Swerve swerve) {
    var currentPose = swerve.getPose();
    var destPose = getDestPose(currentPose);

    var yDist = Math.abs(destPose.getY() - currentPose.getY());

    if (yDist < FEEDER.Y_THRESHOLD) {
      return true;
    }
    return false;
  }

  private static boolean isArmRaised(Arm arm) {
    var currentArmPose = arm.getPose();
    var desiredArmPose = ArmPose.FEEDER_STATION.val;

    var armDist = Math.abs(currentArmPose - desiredArmPose);

    return armDist < FEEDER.ARM_THRESHOLD;
  }

  private static boolean isRotated(Swerve swerve) {
    var currentPose = swerve.getPose();
    var destPose = getDestPose(currentPose);

    var destRad = destPose.getRotation().getRadians();
    var currentRad = currentPose.getRotation().getRadians();

    var closestDestRad = MoreMath.getClosestRad(currentRad, destRad);

    var radDist = Units.radiansToDegrees(Math.abs(closestDestRad - currentRad));

    return radDist < FEEDER.ROT_THRESHOLD;
  }

  private static boolean isClose(Swerve swerve) {
    var currentPose = swerve.getPose();
    var destPose = getDestPose(swerve.getPose());

    return destPose.getTranslation().getDistance(currentPose.getTranslation()) < 1;
  }

  private static boolean isLeft(Pose2d pose) {
    return Controllers.driverController.getAutoLeft().getAsBoolean() == MoreMath.isBlue();
  }

  private static Pose2d getPrepPose(Pose2d pose) {
    Pose2d prepPose;
    if (isLeft(pose)) {
      prepPose = FEEDER.LEFT_PREP_POSE;
    } else {
      prepPose = FEEDER.RIGHT_PREP_POSE;
    }
    prepPose = MoreMath.transformByAlliance(prepPose);
    return prepPose;
  }

  private static Pose2d getDestPose(Pose2d pose) {
    Pose2d destPose;
    if (isLeft(pose)) {
      destPose = FEEDER.LEFT_DEST_POSE;
    } else {
      destPose = FEEDER.RIGHT_DEST_POSE;
    }
    destPose = MoreMath.transformByAlliance(destPose);
    return destPose;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.drive;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import frc.robot.Constants.AUTO_ALIGN.GRID;
import frc.robot.commands.arm.SetArmPose;
import frc.robot.commands.arm.SetArmPose.ArmPose;
import frc.robot.commands.drive.Nodes.NodeX;
import frc.robot.commands.drive.Nodes.NodeY;
import frc.robot.controllers.Controllers;
import frc.robot.subsystems.arm.Arm;
import frc.robot.subsystems.drive.Swerve;
import frc.robot.util.MoreMath;

public class GridAlign extends SequentialCommandGroup {
  public GridAlign(Swerve swerve, Arm arm) {
    addCommands(simpleAlign(swerve, arm));
  }


  public static Command simpleAlign(Swerve swerve, Arm arm) {
    var destPose = getDestPose(swerve, arm);
    var desiredArmPose = getDesiredArmPose(arm);

    var pathCommand = swerve.goTo(destPose, GRID.CONSTRAINTS);
    var armCommand = new SetArmPose(arm, desiredArmPose);
    return pathCommand.alongWith(armCommand);
  }

  public static Pose2d getDestPose(Swerve swerve, Arm arm) {
    /* Assuming they have a range of 1-3 */
    var x = getDesiredNodeX(arm).x;
    var y = getDesiredNodeY(swerve).getY();

    return new Pose2d(x, y, Rotation2d.fromDegrees(180));
  }

  public static NodeX getDesiredNodeX(Arm arm) {
    var desiredArmPose = getDesiredArmPose(arm);
    switch (desiredArmPose) {
      case HIGH_NODE:
        return NodeX.HIGH;
      case MID_NODE:
        return NodeX.MID;
      case LOW_NODE:
        return NodeX.LOW;
      default:
        return NodeX.HIGH;
    }
  }

  public static ArmPose getDesiredArmPose(Arm arm) {
    ArmPose[] armPoses = {ArmPose.LOW_NODE, ArmPose.MID_NODE, ArmPose.HIGH_NODE};

    var smallestDist = Double.POSITIVE_INFINITY;
    ArmPose closestArmPose = ArmPose.HIGH_NODE;

    for (var armPose : armPoses) {
      var dist = Math.abs(armPose.val - arm.getPose());
      if (dist < smallestDist) {
        smallestDist = dist;
        closestArmPose = armPose;
      }
    }
    return closestArmPose;
  }

  public static NodeY getDesiredNodeY(Swerve swerve) {
    var indexDelta = 0;
    if (Controllers.driverController.getAutoLeft().getAsBoolean()) {
      indexDelta = -1;
    } else if (Controllers.driverController.getAutoCenter().getAsBoolean()) {
      indexDelta = 0;
    } else if (Controllers.driverController.getAutoRight().getAsBoolean()) {
      indexDelta = 1;
    }

    //I hate mirrored fields
    if (!MoreMath.isBlue()) {
      indexDelta *= -1;
    }

    var closestCenterNodeIndex = getClosestCenterNode(swerve.getPose()).index;
    var nodeY = NodeY.getByIndex(closestCenterNodeIndex + indexDelta);
    return nodeY;
  }

  public static NodeY getClosestCenterNode(Pose2d currentPose) {
    NodeY[] centerNodes = {NodeY.N2, NodeY.N5, NodeY.N8};

    var smallestDist = Double.POSITIVE_INFINITY;
    NodeY closestNode = NodeY.getByIndex(1);

    for (var centerNode : centerNodes) {
      var dist = Math.abs(centerNode.getY() - currentPose.getY());
      if (dist < smallestDist) {
        smallestDist = dist;
        closestNode = centerNode;
      }
    }
    return closestNode;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.drive;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import frc.robot.util.MoreMath;

/** Add your docs here. */
public class Nodes {
  public static enum NodeY {
    // format: off
    // no bump -> bump
    N1(1, 4.93), N2(2, 4.41), N3(3, 3.85), N4(4, 3.32), N5(5, 2.76), N6(6, 2.175), N7(7, 1.63), N8(8, 1.083), N9(9,
        0.544);
    // format: on

    private final double y;
    public final int index;

    NodeY(int index, double y) {
      this.index = index;
      this.y = y;
    }

    public static NodeY getByIndex(int index) {
      for (var node : NodeY.values()) {
        if (node.index == index) {
          return node;
        }
      }
      return null;
    }

    public double getY() {
      var transformedY = MoreMath.transformByAlliance(new Pose2d(0, this.y, new Rotation2d())).getY();
      return transformedY;
    }
  }
  public static enum NodeX {
    LOW(1, 2.15), MID(2, 2.05), HIGH(3, 1.9);

    public final double x;
    public final int index;

    NodeX(int index, double x) {
      this.index = index;
      this.x = x;
    }

    public static NodeX getByIndex(int index) {
      for (var node : NodeX.values()) {
        if (node.index == index) {
          return node;
        }
      }
      return null;
    }
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.drive.obsolete;

import com.pathplanner.lib.PathPlanner;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import frc.robot.commands.arm.SetArmPose;
import frc.robot.commands.arm.SetArmPose.ArmPose;
import frc.robot.commands.drive.rotateTo;
import frc.robot.subsystems.arm.Arm;
import frc.robot.subsystems.drive.Swerve;
import frc.robot.util.CustomProxy;
import frc.robot.util.MoreMath;
import frc.robot.Constants.FIELD_CONSTANTS;
import frc.robot.Constants.AUTO_ALIGN.FEEDER;

public class AlignToFeederStation extends CustomProxy {

  public AlignToFeederStation(Swerve swerve, Arm arm) {
    super(() -> {
      return proxy(swerve, arm);
    }, swerve, arm);
  }

  private static Command proxy(Swerve swerve, Arm arm) {
    if (!inFeederArea(swerve)) {
      return new InstantCommand();
    }

    if (isYAligned(swerve) && isArmRaised(arm) && isClose(swerve) && isRotated(swerve)) {
      return simpleAlign(swerve, arm);
    } else {
      return prepThenGoToDest(swerve, arm);
    }
  }

  private static Command prepThenGoToDest(Swerve swerve, Arm arm) {

    var startPose = swerve.getPose();
    var prepPose = FEEDER.LEFT_PREP_POSE;
    var destPose = FEEDER.LEFT_DEST_POSE;

    prepPose = MoreMath.transformByAlliance(prepPose);
    destPose = MoreMath.transformByAlliance(destPose);

    var startHeading = MoreMath.calcHeading(startPose, prepPose);
    var startPoint = MoreMath.createPathPoint(startPose, startHeading);

    var prepHeading = MoreMath.calcHeading(prepPose, destPose);
    var prepPoint = MoreMath.createPathPoint(prepPose, prepHeading);

    var destHeading = prepHeading;
    var destPoint = MoreMath.createPathPoint(destPose, destHeading);

    var startToPrepTraj = PathPlanner.generatePath(FEEDER.CONSTRAINTS, startPoint, prepPoint);
    var startToPrepCommand = swerve.followTrajectoryCommand(startToPrepTraj, false, true);

    var prepToDestTraj = PathPlanner.generatePath(FEEDER.CONSTRAINTS, prepPoint, destPoint);
    var prepToDestCommand = swerve.followTrajectoryCommand(prepToDestTraj, false, true);

    var rotateCommand = new rotateTo(swerve, Rotation2d.fromDegrees(180));

    var raiseArmCommand = new SetArmPose(arm, ArmPose.FEEDER_STATION);

    return new SequentialCommandGroup(startToPrepCommand, rotateCommand, raiseArmCommand, prepToDestCommand);
  }

  private static Command simpleAlign(Swerve swerve, Arm arm) {
    var startPose = swerve.getPose();
    var endPose = FEEDER.LEFT_DEST_POSE;
    var traj = MoreMath.createStraightPath(startPose, endPose, FEEDER.CONSTRAINTS);

    var trajCommand = swerve.followTrajectoryCommand(traj, false, true);
    var armCommand = new SetArmPose(arm, ArmPose.FEEDER_STATION);

    return trajCommand.alongWith(armCommand);
  }

  private static boolean inFeederArea(Swerve swerve) {
    var currentPose = swerve.getPose();
    var xCheck = MoreMath.within(currentPose.getX(), FEEDER.MIN_X, FEEDER.MAX_X);
    var yCheck = MoreMath.within(currentPose.getY(), FEEDER.MIN_Y, FEEDER.MAX_Y);
    if (!MoreMath.isBlue()) {
      yCheck = MoreMath.within(currentPose.getY(), FIELD_CONSTANTS.WIDTH - FEEDER.MIN_Y,
          FIELD_CONSTANTS.WIDTH - FEEDER.MAX_Y);
    }
    return xCheck && yCheck;
  }

  private static boolean isYAligned(Swerve swerve) {
    var currentPose = swerve.getPose();
    var destPose = FEEDER.LEFT_DEST_POSE;

    destPose = MoreMath.transformByAlliance(destPose);

    var yDist = Math.abs(destPose.getY() - currentPose.getY());

    if (yDist < FEEDER.Y_THRESHOLD) {
      return true;
    }
    return false;
  }

  private static boolean isArmRaised(Arm arm) {
    var currentPose = arm.getPose();
    var destPose = ArmPose.FEEDER_STATION.val;

    var armDist = Math.abs(currentPose - destPose);

    return armDist < FEEDER.ARM_THRESHOLD;
  }

  private static boolean isRotated(Swerve swerve) {
    var currentPose = swerve.getPose();
    var destPose = FEEDER.LEFT_DEST_POSE;

    destPose = MoreMath.transformByAlliance(destPose);

    var destRad = destPose.getRotation().getRadians();
    var currentRad = currentPose.getRotation().getRadians();

    var closestDestRad = MoreMath.getClosestRad(currentRad, destRad);

    var radDist = Units.radiansToDegrees(Math.abs(closestDestRad - currentRad));

    return radDist < FEEDER.ROT_THRESHOLD;
  }

  private static boolean isClose(Swerve swerve) {
    var currentPose = swerve.getPose();
    var destPose = FEEDER.LEFT_DEST_POSE;

    destPose = MoreMath.transformByAlliance(destPose);

    return destPose.getTranslation().getDistance(currentPose.getTranslation()) < 1;
  }
}

/* This is what we call "code hoarding" */
//   public static Command rotateThenRaiseWhileMove(Swerve swerve, Arm arm) {
//     Supplier<Command> lambda = () -> {
//       var constraints = new PathConstraints(2, 1);

//       var startPose = swerve.getPose();
//       var midPose = AUTO_ALIGN.FEEDER_PREP_POSE;
//       var endPose = AUTO_ALIGN.FEEDER_DEST_POSE;

//       midPose = MoreMath.transformByAlliance(midPose);
//       endPose = MoreMath.transformByAlliance(endPose);

//       var startHeading = midPose.getTranslation().minus(startPose.getTranslation()).getAngle();
//       var startPoint = new PathPoint(startPose.getTranslation(), startHeading, startPose.getRotation());

//       var midHeading = endPose.getTranslation().minus(midPose.getTranslation()).getAngle();
//       var midPoint = new PathPoint(midPose.getTranslation(), midHeading, midPose.getRotation(), 2);

//       var endHeading = midHeading;
//       var endPoint = new PathPoint(endPose.getTranslation(), endHeading, endPose.getRotation());

//       var traj = PathPlanner.generatePath(constraints, startPoint, midPoint, endPoint);
//       // traj = PathPlannerTrajectory.transformTrajectoryForAlliance(traj, DriverStation.getAlliance());

//       return swerve.silentFollowTrajectoryCommand(traj, false, true);
//     };

//     return new rotateTo(swerve, Rotation2d.fromDegrees(180))
//         .andThen(new ProxyCommand(lambda).alongWith(new SetArmPose(arm, ArmPose.FEEDER_STATION)));
//   }

//   public static Command raiseWhileMoveSlowerOption(Swerve swerve, Arm arm) {
//     var startPose = swerve.getPose();
//     var midPose = Constants.AUTO_ALIGN.FEEDER_PREP_POSE;
//     var endPose = Constants.AUTO_ALIGN.FEEDER_DEST_POSE;

//     var startHeading = midPose.getTranslation().minus(startPose.getTranslation()).getAngle();
//     var startPoint = new PathPoint(startPose.getTranslation(), startHeading, startPose.getRotation());

//     var midHeading = endPose.getTranslation().minus(midPose.getTranslation()).getAngle();
//     var midPoint = new PathPoint(midPose.getTranslation(), midHeading, midPose.getRotation());

//     var endHeading = midHeading;
//     var endPoint = new PathPoint(endPose.getTranslation(), endHeading, endPose.getRotation());

//     var slowerConstraints = new PathConstraints(0.5, 0.25);

//     var traj1 = PathPlanner.generatePath(AUTO_ALIGN.FEEDER_CONSTRAINTS, startPoint, midPoint);
//     var traj2 = PathPlanner.generatePath(slowerConstraints, midPoint, endPoint);

//     traj1 = PathPlannerTrajectory.transformTrajectoryForAlliance(traj1, DriverStation.getAlliance());
//     traj2 = PathPlannerTrajectory.transformTrajectoryForAlliance(traj2, DriverStation.getAlliance());

//     return swerve.followTrajectoryCommand(traj1, false, false).andThen(
//         new SetArmPose(arm, ArmPose.FEEDER_STATION).alongWith(swerve.followTrajectoryCommand(traj2, false, true)));
//   }

//   public static Command raiseAndMoveOption(Swerve swerve, Arm arm) {
//     var constraints = new PathConstraints(2, 1);
//     var eventMarkers = Collections.singletonList(new EventMarker(Collections.singletonList("raise arm"), 1));

//     var startPose = swerve.getPose();
//     var midPose = AUTO_ALIGN.FEEDER_PREP_POSE;
//     var endPose = AUTO_ALIGN.FEEDER_DEST_POSE;

//     var startHeading = midPose.getTranslation().minus(startPose.getTranslation()).getAngle();
//     var startPoint = new PathPoint(startPose.getTranslation(), startHeading, startPose.getRotation());

//     var midHeading = endPose.getTranslation().minus(midPose.getTranslation()).getAngle();
//     var midPoint = new PathPoint(midPose.getTranslation(), midHeading, midPose.getRotation(), 0.5);

//     var endHeading = midHeading;
//     var endPoint = new PathPoint(endPose.getTranslation(), endHeading, endPose.getRotation());

//     var traj = PathPlanner.generatePath(constraints, eventMarkers, startPoint, midPoint, endPoint);
//     traj = PathPlannerTrajectory.transformTrajectoryForAlliance(traj, DriverStation.getAlliance());

//     Map<String, Command> eventMap = Collections.singletonMap("raise arm", new SetArmPose(arm, ArmPose.FEEDER_STATION));

//     return new FollowPathWithEvents(swerve.followTrajectoryCommand(traj, false, true), eventMarkers, eventMap);
//   }

//   public static Command raiseThenMoveOption(Swerve swerve, Arm arm) {
//     var startPose = swerve.getPose();
//     if (Math.abs(startPose.getRotation().getDegrees()) > 150) {
//       return raiseWhileMovingSuboption(swerve, arm);
//     } else {
//       return raiseThenMoveSuboption(swerve, arm);
//     }
//   }

//   public static Command raiseWhileMovingSuboption(Swerve swerve, Arm arm) {
//     var startPose = swerve.getPose();
//     var midPose = Constants.AUTO_ALIGN.FEEDER_PREP_POSE;
//     var endPose = Constants.AUTO_ALIGN.FEEDER_DEST_POSE;

//     var startHeading = midPose.getTranslation().minus(startPose.getTranslation()).getAngle();
//     var startPoint = new PathPoint(startPose.getTranslation(), startHeading, startPose.getRotation());

//     var midHeading = endPose.getTranslation().minus(midPose.getTranslation()).getAngle();
//     var midPoint = new PathPoint(midPose.getTranslation(), midHeading, midPose.getRotation());

//     var endHeading = midHeading;
//     var endPoint = new PathPoint(endPose.getTranslation(), endHeading, endPose.getRotation());

//     var traj = PathPlanner.generatePath(AUTO_ALIGN.FEEDER_CONSTRAINTS, startPoint, midPoint, endPoint);

//     traj = PathPlannerTrajectory.transformTrajectoryForAlliance(traj, DriverStation.getAlliance());

//     return swerve.followTrajectoryCommand(traj, false, true).alongWith(new SetArmPose(arm, ArmPose.FEEDER_STATION));
//   }

//   public static Command raiseThenMoveSuboption(Swerve swerve, Arm arm) {
//     var startPose = swerve.getPose();
//     var midPose = Constants.AUTO_ALIGN.FEEDER_PREP_POSE;
//     var endPose = Constants.AUTO_ALIGN.FEEDER_DEST_POSE;

//     var startHeading = midPose.getTranslation().minus(startPose.getTranslation()).getAngle();
//     var startPoint = new PathPoint(startPose.getTranslation(), startHeading, startPose.getRotation());

//     var midHeading = endPose.getTranslation().minus(midPose.getTranslation()).getAngle();
//     var midPoint = new PathPoint(midPose.getTranslation(), midHeading, midPose.getRotation());

//     var endHeading = midHeading;
//     var endPoint = new PathPoint(endPose.getTranslation(), endHeading, endPose.getRotation());

//     var traj1 = PathPlanner.generatePath(AUTO_ALIGN.FEEDER_CONSTRAINTS, startPoint, midPoint);
//     var traj2 = PathPlanner.generatePath(AUTO_ALIGN.FEEDER_CONSTRAINTS, midPoint, endPoint);

//     traj1 = PathPlannerTrajectory.transformTrajectoryForAlliance(traj1, DriverStation.getAlliance());
//     traj2 = PathPlannerTrajectory.transformTrajectoryForAlliance(traj2, DriverStation.getAlliance());

//     return swerve.followTrajectoryCommand(traj1, false, true).andThen(new SetArmPose(arm, ArmPose.FEEDER_STATION))
//         .andThen(swerve.followTrajectoryCommand(traj2, false, true));
//   }

// }
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.drive.obsolete;

import com.pathplanner.lib.PathConstraints;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import frc.robot.Constants.AUTO_ALIGN.GRID;
import frc.robot.commands.arm.SetArmPose;
import frc.robot.commands.arm.SetArmPose.ArmPose;
import frc.robot.commands.drive.Nodes.NodeX;
import frc.robot.commands.drive.Nodes.NodeY;
import frc.robot.controllers.Controllers;
import frc.robot.subsystems.arm.Arm;
import frc.robot.subsystems.drive.Swerve;
import frc.robot.util.CustomProxy;
import frc.robot.util.MoreMath;

public class AlignToGrid extends CustomProxy {
  /** Creates a new AlignToGrid. */
  public static PathConstraints constraints = new PathConstraints(2, 1);

  public AlignToGrid(Swerve swerve, Arm arm) {
    super(() -> {
      return proxy(swerve, arm);
    });
  }

  public static Command proxy(Swerve swerve, Arm arm) {
    if (isArmRaised(arm) && isRotated(swerve) && isClose(swerve)) {
      return simpleAlign(swerve, arm);
    } else {
      return new InstantCommand();
    }
  }

  private static Command simpleAlign(Swerve swerve, Arm arm) {
    var destPose = getDesiredNodePose();
    var pathCommand = swerve.goTo(destPose, GRID.CONSTRAINTS);

    var destArmPose = getDesiredArmPose();
    var armCommand = new SetArmPose(arm, destArmPose);

    return pathCommand.alongWith(armCommand);
  }

  private static boolean isArmRaised(Arm arm) {
    var currentPose = arm.getPose();
    var destPose = getDesiredArmPose().val;

    var armDist = Math.abs(currentPose - destPose);

    return armDist < GRID.ARM_THRESHOLD;
  }

  private static boolean isRotated(Swerve swerve) {
    var currentPose = swerve.getPose();
    var destPose = getDesiredNodePose();

    destPose = MoreMath.transformByAlliance(destPose);

    var destRad = destPose.getRotation().getRadians();
    var currentRad = currentPose.getRotation().getRadians();

    var closestDestRad = MoreMath.getClosestRad(currentRad, destRad);

    var radDist = Units.radiansToDegrees(Math.abs(closestDestRad - currentRad));

    return radDist < GRID.ROT_THRESHOLD;
  }

  private static boolean isClose(Swerve swerve) {
    var currentPose = swerve.getPose();
    var destPose = getDesiredNodePose();

    destPose = MoreMath.transformByAlliance(destPose);

    return destPose.getTranslation().getDistance(currentPose.getTranslation()) < GRID.DIST_THRESHOLD;
  }
  // public static Command proxy(Swerve swerve, Arm arm) {
  //   var nodePose = getDesiredNodePose();
  //   var currentPose = swerve.getPose();

  //   if (onChargingStation(currentPose) || inOpponentLoadingZone(currentPose) || farAway(currentPose)) {
  //     return new InstantCommand();
  //   }

  //   var startLeaf = new PointLeaf(swerve.getPose());
  //   var nodeLeaf = PointLeaf.createTree(nodePose);

  //   var leavesTraj = new ArrayList<PointLeaf>();
  //   leavesTraj.add(0, nodeLeaf);
  //   leavesTraj.add(0, nodeLeaf.getClosestChild(startLeaf));

  //   while (leavesTraj.get(0) != startLeaf) {
  //     var firstLeaf = leavesTraj.get(0);
  //     var closestChild = firstLeaf.getClosestChild(startLeaf);

  //     if (closestChild == null) {
  //       leavesTraj.add(0, startLeaf);
  //       continue;
  //     }

  //     var startLeafDist = firstLeaf.getDistance(startLeaf);
  //     var closestChildDist = firstLeaf.getDistance(closestChild);

  //     if (startLeafDist < closestChildDist) {
  //       leavesTraj.add(0, startLeaf);
  //     } else {
  //       leavesTraj.add(0, closestChild);
  //     }
  //   }

  //   var paths = leavesTrajToPaths(leavesTraj);

  //   var command = pathsToCommand(swerve, arm, paths, nodePose);
  //   return command;
  // }

  public static Pose2d getDesiredNodePose() {
    /* Assuming they have a range of 1-3 */
    var chosenGrid = Controllers.alignController.getChosenGrid();
    var chosenY = Controllers.alignController.getChosenY();
    var chosenX = Controllers.alignController.getChosenX();

    chosenGrid--;

    var yIndex = chosenGrid * 3 + chosenY;
    var yVal = NodeY.getByIndex(yIndex).getY();

    var xIndex = chosenX;
    var xVal = NodeX.getByIndex(xIndex).x;

    return new Pose2d(xVal, yVal, Rotation2d.fromDegrees(180));
  }

  public static ArmPose getDesiredArmPose() {
    var chosenX = Controllers.alignController.getChosenX();
    if (chosenX == 1) {
      return ArmPose.LOW_NODE;
    } else if (chosenX == 2) {
      return ArmPose.MID_NODE;
    } else {
      return ArmPose.HIGH_NODE;
    }
  }

  // public static Command pathsToCommand(Swerve swerve, Arm arm, ArrayList<PathPlannerTrajectory> paths, Pose2d endPose) {
  //   Command command = new InstantCommand();
  //   for (var i = 0; i < paths.size() - 1; i++) {
  //     command = command.andThen(swerve.followTrajectoryCommand(paths.get(i), false, true));
  //   }
  //   command = command.andThen(swerve.followTrajectoryCommand(paths.get(paths.size() - 1), false, true)
  //       .alongWith(new SetArmPose(arm, getDesiredArmPose())));

  //   return command;
  // }

  // public static ArrayList<PathPlannerTrajectory> leavesTrajToPaths(ArrayList<PointLeaf> leavesTraj) {
  //   var paths = new ArrayList<PathPlannerTrajectory>();
  //   for (int i = 1; i < leavesTraj.size(); i++) {
  //     var lastPose = leavesTraj.get(i - 1).pose;
  //     var currentPose = leavesTraj.get(i).pose;

  //     var heading = currentPose.getTranslation().minus(lastPose.getTranslation()).getAngle();

  //     var lastPoint = new PathPoint(lastPose.getTranslation(), heading, lastPose.getRotation());
  //     var currentPoint = new PathPoint(currentPose.getTranslation(), heading, currentPose.getRotation());
  //     var path = PathPlanner.generatePath(constraints, lastPoint, currentPoint);
  //     // path = PathPlannerTrajectory.transformTrajectoryForAlliance(path, DriverStation.getAlliance());
  //     paths.add(path);
  //   }
  //   return paths;
  // }

  // public static List<PathPoint> trajLeavesToPoints(ArrayList<PointLeaf> leavesTraj) {
  //   var pointsTraj = new ArrayList<PathPoint>();

  //   for (var i = 0; i < leavesTraj.size(); i++) {
  //     var leaf = leavesTraj.get(i);
  //     var heading = getHeading(i, leavesTraj, pointsTraj);
  //     var point = new PathPoint(leaf.pose.getTranslation(), heading, leaf.pose.getRotation());
  //     pointsTraj.add(point);
  //   }

  //   return pointsTraj;
  // }

  // public static Rotation2d getHeading(int index, ArrayList<PointLeaf> leavesTraj, ArrayList<PathPoint> pointsTraj) {
  //   var prevPoint = index - 1 < 0 ? null : pointsTraj.get(index - 1);
  //   var currentLeaf = leavesTraj.get(index);
  //   var nextLeaf = index + 1 >= leavesTraj.size() ? null : leavesTraj.get(index + 1);

  //   if (nextLeaf == null) {
  //     return currentLeaf.pose.getTranslation().minus(prevPoint.position).getAngle();
  //   } else if (prevPoint == null) {
  //     return nextLeaf.pose.getTranslation().minus(currentLeaf.pose.getTranslation()).getAngle();
  //   } else {
  //     return nextLeaf.pose.getTranslation().minus(prevPoint.position).getAngle();
  //   }
  // }

  // public static boolean onChargingStation(Pose2d pose) {
  //   var xCheck = pose.getX() < 4.45 && pose.getX() > 3.342;
  //   var yCheck = pose.getY() < 3.7 && pose.getX() > 1.875;
  //   if (DriverStation.getAlliance() == DriverStation.Alliance.Red) {
  //     yCheck = pose.getY() > (Constants.FIELD_CONSTANTS.WIDTH - 3.7)
  //         && pose.getY() < (Constants.FIELD_CONSTANTS.WIDTH - 1.875);
  //   }

  //   return xCheck && yCheck;
  // }

  // public static boolean inOpponentLoadingZone(Pose2d pose) {
  //   var xCheck = pose.getX() < 6.309;
  //   var yCheck = pose.getY() > 5.877;

  //   if (DriverStation.getAlliance() == DriverStation.Alliance.Red) {
  //     yCheck = pose.getY() < (Constants.FIELD_CONSTANTS.WIDTH - 5.877);
  //   }
  //   return xCheck && yCheck;
  // }

  // public static boolean farAway(Pose2d pose) {
  //   return pose.getX() > 7.233;
  // }
}
package frc.robot.commands.drive.obsolete;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.wpilibj.DriverStation;
import frc.robot.util.MoreMath;

public class PointLeaf {
  Pose2d pose;
  final List<PointLeaf> children;

  public PointLeaf(Pose2d pose, PointLeaf... children) {
    this.pose = pose;
    this.children = Arrays.asList(children);
  }

  public PointLeaf(Pose2d pose, PointLeaf child) {
    this.pose = pose;
    this.children = Collections.singletonList(child);
  }

  public PointLeaf(Pose2d pose) {
    this.pose = pose;
    this.children = Collections.emptyList();
  }

  public double getDistance(PointLeaf other) {
    return this.pose.getTranslation().getDistance(other.pose.getTranslation());
  }

  public void transformByAlliance() {
    if (DriverStation.getAlliance() == DriverStation.Alliance.Blue)
      return;

    this.pose = MoreMath.transformByAlliance(this.pose);
    for (var child : children) {
      child.transformByAlliance();
    }
  }

  public PointLeaf getClosestChild(PointLeaf other) {
    PointLeaf closestChild = null;
    var closestDistance = 1000d;

    for (PointLeaf child : children) {
      var currentDistance = child.getDistance(other);

      if (currentDistance < closestDistance) {
        closestChild = child;
        closestDistance = currentDistance;
      }
    }

    return closestChild;
  }

  public static PointLeaf createTree(Pose2d endPose) {
    var rot = Rotation2d.fromDegrees(180);

    var level1Left = new PointLeaf(new Pose2d(5.5, 4.7, rot));
    var level1Right = new PointLeaf(new Pose2d(5.5, 0.8, rot));

    var level2Left = new PointLeaf(new Pose2d(2.3, 4.67, rot), level1Left);
    var level2Right = new PointLeaf(new Pose2d(2.3, 0.8, rot), level1Right);

    var level3 = new PointLeaf(new Pose2d(2.3, endPose.getY(), rot), level2Left, level2Right);
    var endNode = new PointLeaf(endPose, level3);

    endNode.transformByAlliance();
    return endNode;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.drive;

import edu.wpi.first.math.MathUtil;
import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.drive.Swerve;
import frc.robot.util.MoreMath;

public class rotateTo extends CommandBase {
  private double angle;
  private Swerve swerve;
  private PIDController rotPIDCnt = new PIDController(5d, 0d, 0d);
  private Rotation2d rotGoal;
  private double optimizedRotGoal;
  private int satisfactionNumber;


  /** Creates a new rotateTo. */
  public rotateTo(Swerve swerve, Rotation2d rot) {
    this.swerve = swerve;
    this.rotGoal = rot;

    // Use addRequirements() here to declare subsystem dependencies
    addRequirements(swerve);
  }

  // Called when the command is initially scheduled.
  @Override
  public void initialize() {
    this.satisfactionNumber = 0;
    var ctsGyroAngle = swerve.getCtsGyroRotWithOffset().getRadians();
    this.optimizedRotGoal = MoreMath.getClosestRad(ctsGyroAngle, rotGoal.getRadians());
  }

  // Called every time the scheduler runs while the command is scheduled.
  @Override
  public void execute() {
    var ctsGyroAngle = swerve.getCtsGyroRotWithOffset().getRadians();

    var rotSpd = rotPIDCnt.calculate(ctsGyroAngle, optimizedRotGoal);
    rotSpd = MathUtil.clamp(rotSpd, -3.5, 3.5);

    swerve.driveFieldRelative(new ChassisSpeeds(0, 0, rotSpd));
  }

  // Called once the command ends or is interrupted.
  @Override
  public void end(boolean interrupted) {
    swerve.drive(new ChassisSpeeds());
  }

  // Returns true when the command should end.
  @Override
  public boolean isFinished() {
    var ctsGyroAngle = swerve.getCtsGyroRotWithOffset().getRadians();

    if (Math.abs(ctsGyroAngle - optimizedRotGoal) < 0.05) {
      satisfactionNumber++;
    } else {
      satisfactionNumber = 0;
    }

    return satisfactionNumber > 5;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.drive;

import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.drive.Swerve;

public class SteerMotorDebug extends CommandBase {//Currently only affects FL Steer Motor
  private Swerve swerveSubsystem;

  /** Creates a new SteerMotorDebug. */
  public SteerMotorDebug(Swerve swerve) {
    this.swerveSubsystem = swerve;
    addRequirements(swerve);
    double currentAngle = swerve.lastInputs[0].steerAngleSetpoint;
    SmartDashboard.putNumber("Steer Motor Debug/Desired Steer Motor Angle", currentAngle);


    // Use addRequirements() here to declare subsystem dependencies.
  }

  // Called when the command is initially scheduled.
  @Override
  public void initialize() {
    double currentAngle = swerveSubsystem.lastInputs[0].steerAngleSetpoint;
    SmartDashboard.putNumber("Steer Motor Debug/Desired Steer Motor Angle", currentAngle);
  }

  // Called every time the scheduler runs while the command is scheduled.
  @Override
  public void execute() {
    double currentAngle = swerveSubsystem.lastInputs[0].steerAngle;
    SmartDashboard.putNumber("Steer Motor Debug/Current Steer Motor Angle", currentAngle);

    double desiredAngle = SmartDashboard.getNumber("Steer Motor Debug/Desired Steer Motor Angle", currentAngle);
    swerveSubsystem.setStates(new SwerveModuleState[] {new SwerveModuleState(0, Rotation2d.fromDegrees(desiredAngle))});
  }

  // Called once the command ends or is interrupted.
  @Override
  public void end(boolean interrupted) {}

  // Returns true when the command should end.
  @Override
  public boolean isFinished() {
    return false;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.drive;

import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.drive.Swerve;

public class SwerveModuleDebug extends CommandBase {
  private Swerve swerve;

  /** Creates a new SwerveModuleDebug. */
  public SwerveModuleDebug(Swerve swerve) {
    addRequirements(swerve);
    this.swerve = swerve;
    // Use addRequirements() here to declare subsystem dependencies.
  }

  // Called when the command is initially scheduled.
  @Override
  public void initialize() {
    SmartDashboard.putNumber("SW Debug/SW Angle Setpoint", 0);
    SmartDashboard.putNumber("SW Debug/SW kP", 0);
    SmartDashboard.putNumber("SW Debug/SW kI", 0);
    SmartDashboard.putNumber("SW Debug/SW kD", 0);


  }

  // Called every time the scheduler runs while the command is scheduled.
  @Override
  public void execute() {
    double setpoint = SmartDashboard.getNumber("SW Debug/Left Mod Angle Setpoint", 0);
    swerve.modules[1].setState(new SwerveModuleState(0.0, Rotation2d.fromDegrees(setpoint)));

    double kP = SmartDashboard.getNumber("SW Debug/SW kP", 0);
    double kI = SmartDashboard.getNumber("SW Debug/SW kI", 0);
    double kD = SmartDashboard.getNumber("SW Debug/SW kD", 0);
    swerve.modules[1].setPIDConstants(kP, kI, kD, setpoint);
  }

  // Called once the command ends or is interrupted.
  @Override
  public void end(boolean interrupted) {}

  // Returns true when the command should end.
  @Override
  public boolean isFinished() {
    return false;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.drive;

import org.littletonrobotics.junction.Logger;
import edu.wpi.first.math.MathUtil;
import edu.wpi.first.math.Pair;
import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.Constants;
import frc.robot.controllers.Controllers;
import frc.robot.subsystems.drive.Swerve;
import frc.robot.util.MoreMath;
import frc.robot.util.SwerveRateLimit;

/** An example command that uses an example subsystem. */
public class TeleopDrive extends CommandBase {
  private final Swerve swerve;
  private PIDController rotPIDCnt = new PIDController(5d, 0d, 0d);
  private SwerveRateLimit rateLimiter = new SwerveRateLimit();
  private double angleGoal;
  private double lastRotSpdNotEqualZeroTimestamp = -1;


  /**
   * Creates a new ExampleCommand.
   *
   * @param swerve The subsystem used by this command.
   */
  public TeleopDrive(Swerve swerve) {
    this.swerve = swerve;
    // Use addRequirements() here to declare subsystem dependencies.
    addRequirements(swerve);
    SmartDashboard.putBoolean("TeleopDrive/UseFieldRelative", true);
    SmartDashboard.putBoolean("TeleopDrive/ExponentialJoystickControl", false);
    SmartDashboard.putBoolean("TeleopDrive/RateLimitDrive", false);
    SmartDashboard.putBoolean("TeleopDrive/rot pid/Turn On", true);
    SmartDashboard.putData("TeleopDrive/rot pid/PID Controller", rotPIDCnt);
  }

  // Called when the command is initially scheduled.
  @Override
  public void initialize() {
    // swerve.setPose(new Pose2d());
    var ctsGyroAngle = swerve.getCtsGyroRotWithOffset().getRadians();
    angleGoal = ctsGyroAngle;
  }

  // Called every time the scheduler runs while the command is scheduled.
  @Override
  public void execute() {
    if (Controllers.driverController.getSetWheelXButton().getAsBoolean()) {
      swerve.setX();
      return;
    }

    var xSpd = Controllers.driverController.getXMoveAxis();
    var ySpd = Controllers.driverController.getYMoveAxis();
    var rotSpd = Controllers.driverController.getRotateAxis();

    var spds = new ChassisSpeeds(xSpd, ySpd, rotSpd);

    logSpds("deadbanded", spds);

    spds = cube(spds);

    logSpds("Cubed", spds);

    spds = rateLimit(spds);

    logSpds("rate limited", spds);

    spds = scaleVel(spds);

    logSpds("scaled", spds);

    cardinalBtns();
    spds = maintainHeading(spds);

    logSpds("final", spds);

    if (SmartDashboard.getBoolean("TeleopDrive/UseFieldRelative", true)) {
      swerve.driveFieldRelative(spds);
    } else {
      swerve.drive(spds);
    }
  }

  private void cardinalBtns() {
    var heading0 = Controllers.driverController.getSetHeading0Btn().getAsBoolean();
    var heading90 = Controllers.driverController.getSetHeading90Btn().getAsBoolean();
    var heading180 = Controllers.driverController.getSetHeading180Btn().getAsBoolean();
    var heading270 = Controllers.driverController.getSetHeading270Btn().getAsBoolean();

    var ctsGyroAngle = swerve.getCtsGyroRotWithOffset().getRadians();

    SmartDashboard.putNumber("Actual Heading #", Controllers.driverController.getPOV());
    if (heading0) {
      SmartDashboard.putNumber("Heading #", 0);
      angleGoal = MoreMath.getClosestRad(ctsGyroAngle, Units.degreesToRadians(0));
      SmartDashboard.putNumber("more math", angleGoal);
    } else if (heading90) {
      SmartDashboard.putNumber("Heading #", 90);
      angleGoal = MoreMath.getClosestRad(ctsGyroAngle, Units.degreesToRadians(90));
      SmartDashboard.putNumber("more math", angleGoal);
    } else if (heading180) {
      SmartDashboard.putNumber("Heading #", 180);
      angleGoal = MoreMath.getClosestRad(ctsGyroAngle, Units.degreesToRadians(180));
      SmartDashboard.putNumber("more math", angleGoal);
    } else if (heading270) {
      SmartDashboard.putNumber("Heading #", 270);
      angleGoal = MoreMath.getClosestRad(ctsGyroAngle, Units.degreesToRadians(270));
      SmartDashboard.putNumber("more math", angleGoal);
    } else {
      SmartDashboard.putNumber("Heading #", -1);
    }
  }

  public ChassisSpeeds cube(ChassisSpeeds spds) {
    var xSpd = spds.vxMetersPerSecond;
    var ySpd = spds.vyMetersPerSecond;
    var rotSpd = spds.omegaRadiansPerSecond;

    boolean useExponentialJoystickControl = SmartDashboard.getBoolean("TeleopDrive/ExponentialJoystickControl", false);
    if (useExponentialJoystickControl) {
      Pair<Double, Double> xyPair = MoreMath.poseExp(xSpd, ySpd);
      xSpd = xyPair.getFirst();
      ySpd = xyPair.getSecond();
    } else {
      //Cubic axis control (yes, i intentionally put the signum there in case we want to change to an even power)
      xSpd = Math.abs(Math.pow(xSpd, 3)) * Math.signum(xSpd);
      ySpd = Math.abs(Math.pow(ySpd, 3)) * Math.signum(ySpd);
      rotSpd = Math.abs(Math.pow(rotSpd, 3)) * Math.signum(rotSpd);
    }

    return new ChassisSpeeds(xSpd, ySpd, rotSpd);
  }

  public ChassisSpeeds rateLimit(ChassisSpeeds spds) {
    if (SmartDashboard.getBoolean("TeleopDrive/RateLimitDrive", false)) {
      return rateLimiter.rateLimit(spds);
    }
    return spds;
  }

  public ChassisSpeeds scaleVel(ChassisSpeeds spds) {
    var lin_mult = Constants.DRIVE.MID_LIN_VEL;
    var rot_mult = Constants.DRIVE.MID_ROT_VEL;

    if (Controllers.driverController.LOW_SPEED().getAsBoolean()) {
      lin_mult = Constants.DRIVE.LOW_LIN_VEL;
      rot_mult = Constants.DRIVE.LOW_ROT_VEL;
    } else if (Controllers.driverController.HIGH_SPEED().getAsBoolean()) {
      lin_mult = Constants.DRIVE.HIGH_LIN_VEL;
      rot_mult = Constants.DRIVE.HIGH_ROT_VEL;
    }
    spds.vxMetersPerSecond *= lin_mult;
    spds.vyMetersPerSecond *= lin_mult;
    spds.omegaRadiansPerSecond *= rot_mult;

    return spds;
  }

  /*Make sure the robot maintains its heading when we aren't toggling the rotation axis*/
  public ChassisSpeeds maintainHeading(ChassisSpeeds spds) {
    var rotSpd = spds.omegaRadiansPerSecond;
    var ctsGyroAngle = swerve.getCtsGyroRotWithOffset().getRadians();

    var runRotPid = SmartDashboard.getBoolean("TeleopDrive/rot pid/Turn On", false);
    var rotSpdEqualZero = MathUtil.applyDeadband(rotSpd, 1E-2) == 0;

    if (!rotSpdEqualZero) {
      lastRotSpdNotEqualZeroTimestamp = Timer.getFPGATimestamp();
    }
    var currentTime = Timer.getFPGATimestamp();
    var waited = currentTime - lastRotSpdNotEqualZeroTimestamp > 0.1;

    if (!waited && rotSpdEqualZero) {
      SmartDashboard.putBoolean("waiting", true);
    } else {
      SmartDashboard.putBoolean("waiting", false);
    }
    if (runRotPid && rotSpdEqualZero && waited) {
      rotSpd = rotPIDCnt.calculate(ctsGyroAngle, angleGoal);
      Logger.getInstance().recordOutput("TeleopDrive/rot pid/rotSpd", rotSpd);
      rotSpd = MathUtil.clamp(rotSpd, -2.5, 2.5);
      Logger.getInstance().recordOutput("TeleopDrive/rot pid/clamped rotSpd", rotSpd);

      spds.omegaRadiansPerSecond = rotSpd;
      SmartDashboard.putBoolean("TeleopDrive/rot pid/running", true);
    } else {
      angleGoal = ctsGyroAngle;
      SmartDashboard.putBoolean("TeleopDrive/rot pid/running", false);
    }

    SmartDashboard.putNumber("TeleopDrive/rot pid/cts gyro angle", ctsGyroAngle);
    SmartDashboard.putNumber("TeleopDrive/rot pid/Goal", angleGoal);

    return spds;
  }

  public void logSpds(String subPath, ChassisSpeeds spds) {
    var xSpd = spds.vxMetersPerSecond;
    var ySpd = spds.vyMetersPerSecond;
    var rotSpd = spds.omegaRadiansPerSecond;

    Logger.getInstance().recordOutput("TeleopDrive/" + subPath + "/xSpd", xSpd);
    Logger.getInstance().recordOutput("TeleopDrive/" + subPath + "/ySpd", ySpd);
    Logger.getInstance().recordOutput("TeleopDrive/" + subPath + "/rotSpd", rotSpd);
  }

  // Called once the command ends or is interrupted.
  @Override
  public void end(boolean interrupted) {
    swerve.drive(new ChassisSpeeds());
  }

  // Returns true when the command should end.
  @Override
  public boolean isFinished() {
    return false;
  }
}
package frc.robot.commands.sysidcommand;

import edu.wpi.first.wpilibj.Notifier;
import edu.wpi.first.wpilibj.Threads;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import java.util.ArrayList;
import frc.robot.Robot;
import frc.robot.subsystems.drive.Swerve;

// This is going to be slightly weird
public class SysidCommand extends CommandBase {
  private Swerve drive;
  private ArrayList<Double> data = new ArrayList<Double>();
  /* If the test is dynamic, false if quasistatic */
  private boolean isDynamicTest;
  /* Whether to rotate or not when doing the test */
  private boolean rotateInTest;
  /* Multiplied by time for quasistatic, voltage to set for dynamic */
  private double voltCommand;
  private boolean isWrongMech;

  private double startTime;

  /* Static so it persists between command runs */
  private static double ackNum = 0;

  private final int maxCapacity = 36000;

  // Runs as auton, tries to emulate the sysid interface. Note: may have potential issues due to other robot code running and taking up processing time
  public SysidCommand(Swerve drive) {
    addRequirements(drive);
    this.drive = drive;

    // Realtime priorities
    if (Robot.isReal()) {
      // AFAIK this is already set by default
      Notifier.setHALThreadPriority(true, 40);
      // But this isn't
      Threads.setCurrentThreadPriority(true, 15);
    }

    data.ensureCapacity(maxCapacity);

    this.isDynamicTest = SmartDashboard.getString("SysIdTestType", "").toLowerCase().contains("dynamic");
    this.rotateInTest = SmartDashboard.getBoolean("SysIdRotate", false);
    this.voltCommand = SmartDashboard.getNumber("SysIdVoltageCommand", 0);
    this.isWrongMech = !SmartDashboard.getString("SysIdTest", "").contains("Drivetrain");
    SmartDashboard.putBoolean("SysIdWrongMech", isWrongMech);
    SmartDashboard.putNumber("SysIdAckNumber", ackNum);

    this.startTime = Timer.getFPGATimestamp();

    drive.zeroEncoders();
  }

  @Override
  public void execute() {
    //if(isWrongMech) {System.out.println("Wrong mechanism!!"); return;}

    // Set our motor speeds depending on which test is appropriate
    double targetVolts = 0;
    if (isDynamicTest) {
      targetVolts = voltCommand;
    } else {
      targetVolts = voltCommand * (Timer.getFPGATimestamp() - startTime);
    }
    drive.setVolts(targetVolts * (rotateInTest ? -1 : 1), targetVolts);


    var voltages = drive.getDiffVoltages();
    var velocities = drive.getDiffVelocities();
    var positions = drive.getDiffPositions();

    // Logging!
    data.add(Timer.getFPGATimestamp());
    // Note: due to our implementation this is probably behind by one periodic, and then maybe more if we're counting latency in other areas
    data.add(voltages[0]);
    data.add(voltages[1]);

    data.add(positions[0]);
    data.add(positions[1]);

    data.add(velocities[0]);
    data.add(velocities[1]);
    data.add(drive.getCtsGyroRotWithOffset().getRadians());
    data.add(drive.getAngularVelRad());

    SmartDashboard.putBoolean("is being dynmaic", isDynamicTest);
  }

  @Override
  public void end(boolean interrupted) {

    drive.setVolts(0, 0);

    // This was probably false initially
    Threads.setCurrentThreadPriority(false, 0);
    SmartDashboard.putBoolean("SysIdOverflow", data.size() > maxCapacity);

    StringBuilder outputString = new StringBuilder();
    outputString.ensureCapacity(maxCapacity + 50);
    outputString.append(isDynamicTest ? "fast" : "slow");
    outputString.append(voltCommand > 0 ? "-forward;" : "-backward;");
    for (var entry : data) {
      outputString.append(entry);
      outputString.append(",");
    }
    outputString.deleteCharAt(outputString.length() - 1);

    SmartDashboard.putString("SysIdTelemetry", outputString.toString());
    SmartDashboard.putNumber("SysIdAckNumber", ++ackNum);
  }


}
package frc.robot.commands.sysidcommand;

import edu.wpi.first.wpilibj.Notifier;
import edu.wpi.first.wpilibj.Threads;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import edu.wpi.first.wpilibj2.command.Subsystem;
import java.util.ArrayList;
import java.util.function.Consumer;
import java.util.function.Supplier;

import frc.robot.Robot;

// This is going to be slightly weird
public class SysidMechanismCommand extends CommandBase {
  private ArrayList<Double> data = new ArrayList<Double>();
  /* If the test is dynamic, false if quasistatic */
  private boolean isDynamicTest;

  /* Multiplied by time for quasistatic, voltage to set for dynamic */
  private double voltCommand;
  private boolean isWrongMech;

  private double startTime;

  /* Static so it persists between command runs */
  private static double ackNum = 0;

  private final int maxCapacity = 36000;

  private Runnable zeroEncoder;
  private Supplier<Double> getVoltage, getVelocity, getPosition;
  private Consumer<Double> setVoltage;


  // Runs as auton, tries to emulate the sysid interface. Note: may have potential issues due to other robot code running and taking up processing time.
  // POSITION AND VELOCITY UNITS ARE IN ROTATIONS
  public SysidMechanismCommand(Runnable zeroEncoder, Supplier<Double> getVoltage, Supplier<Double> getVelocity,
      Supplier<Double> getPosition, Consumer<Double> setVoltage, Subsystem... requirements) {

    addRequirements(requirements);

    this.zeroEncoder = zeroEncoder;
    this.getVelocity = getVelocity;
    this.getPosition = getPosition;
    this.setVoltage = setVoltage;
    this.getVoltage = getVoltage;

    // Realtime priorities
    if (Robot.isReal()) {
      // AFAIK this is already set by default
      Notifier.setHALThreadPriority(true, 40);
      // But this isn't
      Threads.setCurrentThreadPriority(true, 15);
    }

    data.ensureCapacity(maxCapacity);

    this.isDynamicTest = SmartDashboard.getString("SysIdTestType", "").toLowerCase().contains("dynamic");
    this.voltCommand = SmartDashboard.getNumber("SysIdVoltageCommand", 0);

    SmartDashboard.putNumber("SysIdAckNumber", ackNum);

    var test = SmartDashboard.getString("SysIdTest", "");
    this.isWrongMech = test.contains("Drivetrain");
    SmartDashboard.putBoolean("SysIdWrongMech", isWrongMech);

    this.startTime = Timer.getFPGATimestamp();

    this.zeroEncoder.run();
  }

  @Override
  public void execute() {
    if (isWrongMech) {
      System.out.println("Wrong mechanism!!");
      return;
    }

    // Set our motor speeds depending on which test is appropriate
    double targetVolts = 0;
    if (isDynamicTest) {
      targetVolts = voltCommand;
    } else {
      targetVolts = voltCommand * (Timer.getFPGATimestamp() - startTime);
    }
    setVoltage.accept(targetVolts);

    // Logging!
    data.add(Timer.getFPGATimestamp());
    // Note: due to our implementation this is probably behind by one periodic, and then maybe more if we're counting latency in other areas
    data.add(getVoltage.get());
    data.add(getPosition.get());
    data.add(getVelocity.get());
  }

  @Override
  public void end(boolean interrupted) {

    setVoltage.accept((double) 0);

    // This was probably false initially
    Threads.setCurrentThreadPriority(false, 0);
    SmartDashboard.putBoolean("SysIdOverflow", data.size() > maxCapacity);

    StringBuilder outputString = new StringBuilder();
    outputString.ensureCapacity(maxCapacity + 50);
    outputString.append(isDynamicTest ? "fast" : "slow");
    outputString.append(voltCommand > 0 ? "-forward;" : "-backward;");
    for (var entry : data) {
      outputString.append(entry);
      outputString.append(",");
    }
    outputString.deleteCharAt(outputString.length() - 1);

    SmartDashboard.putString("SysIdTelemetry", outputString.toString());
    SmartDashboard.putNumber("SysIdAckNumber", ++ackNum);
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.vision;

import edu.wpi.first.math.Matrix;
import edu.wpi.first.math.numbers.N1;
import edu.wpi.first.math.numbers.N3;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.util.vision.CustomEstimate;
import frc.robot.subsystems.vision.Vision;

public class FuseVisionEstimate extends CommandBase {
  private Vision vision;

  public enum ConfidenceStrat {
    MECH_ADV, IRON_PANTHERS, CASSEROLE, TEST, NONE;
  }

  public ConfidenceStrat confidenceStrat;
  public SendableChooser<ConfidenceStrat> trustChooser;

  /** Creates a new UpdateSwervePoseEstimator. */
  public FuseVisionEstimate(Vision vision) {
    this(vision, ConfidenceStrat.NONE);
  }

  public FuseVisionEstimate(Vision vision, ConfidenceStrat confidenceStrat) {
    this.vision = vision;
    this.confidenceStrat = confidenceStrat;
    initChooser();
    addRequirements(vision);
  }

  private void initChooser() {
    trustChooser = new SendableChooser<ConfidenceStrat>();
    for (var visionTrustType : ConfidenceStrat.values()) {
      var key = visionTrustType.name();
      var val = visionTrustType;
      trustChooser.addOption(key, val);
    }

    trustChooser.setDefaultOption(confidenceStrat.name(), confidenceStrat);

    SmartDashboard.putData("vision/trust chooser", trustChooser);
  }

  // Called every time the scheduler runs while the command is scheduled.
  @Override
  public void execute() {
    confidenceStrat = trustChooser.getSelected();
    for (var optEstimate : vision.estimates) {
      if (optEstimate.isEmpty())
        continue;
      var estimate = optEstimate.get();
      Matrix<N3, N1> confidence;
      switch (confidenceStrat) {
        case IRON_PANTHERS:
          confidence = VisionHelper.ironPanthersStdDevs(estimate);
          estimate.setConfidence(confidence);
          fuseEstimate(estimate);
          break;
        case CASSEROLE:
          confidence = VisionHelper.ROBOT_CASSEROLE_STDEV;
          estimate.setConfidence(confidence);
          if (VisionHelper.casseroleShouldFuse(estimate, vision)) {
            fuseEstimate(estimate);
          }
          break;
        case MECH_ADV:
          estimate.setConfidence(VisionHelper.mechAdvStdDevs(estimate));
          fuseEstimate(estimate);
          break;
        case TEST:
          fuseEstimate(estimate);
          break;
        default:
          break;
      }
    }
  }

  public void fuseEstimate(CustomEstimate estimate) {
    var poseEstimate = estimate.best.toPose2d();
    var timestamp = estimate.timestampSeconds;
    var confidence = estimate.confidence;
    this.vision.swerve.fuseVisionEstimate(poseEstimate, timestamp, confidence);
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.vision;

import edu.wpi.first.math.Matrix;
import edu.wpi.first.math.Nat;
import edu.wpi.first.math.VecBuilder;
import edu.wpi.first.math.numbers.N1;
import edu.wpi.first.math.numbers.N3;
import edu.wpi.first.math.util.Units;
import frc.robot.Constants;
import frc.robot.util.vision.CustomEstimate;
import frc.robot.subsystems.vision.Vision;

/** Add your docs here. */
public class VisionHelper {

  public static Matrix<N3, N1> mechAdvStdDevs(CustomEstimate estimate) {
    // Calculate average distance to tag
    var avgDist = getAverageTargetToCamDist(estimate);

    // Add to vision updates
    var xyStdDevCoefficient = 0.01;
    var thetaStdDevCoefficient = 0.01;

    var numTargets = estimate.targetsUsed.size();
    if (numTargets == 0) {
      return VecBuilder.fill(10, 10, 10);
    }
    double xyStdDev = xyStdDevCoefficient * Math.pow(avgDist, 2.0) / numTargets;
    double thetaStdDev = thetaStdDevCoefficient * Math.pow(avgDist, 2.0) / numTargets;

    return VecBuilder.fill(xyStdDev, xyStdDev, thetaStdDev);
  }

  public static Matrix<N3, N1> ironPanthersStdDevs(CustomEstimate estimate) {
    double POSE_AMBIGUITY_SHIFTER = 0.2;
    double POSE_AMBIGUITY_MULTIPLIER = 4;
    double NOISY_DISTANCE_METERS = 2.5;
    double DISTANCE_WEIGHT = 7;
    int TAG_PRESENCE_WEIGHT = 10;
    Matrix<N3, N1> VISION_MEASUREMENT_STANDARD_DEVIATIONS = Matrix.mat(Nat.N3(), Nat.N1()).fill(
        // if these numbers are less than one, multiplying will do bad things
        1, // x
        1, // y
        1 * Math.PI // theta
    );

    double smallestDistance = Double.POSITIVE_INFINITY;
    for (var target : estimate.targetsUsed) {
      var t3d = target.getBestCameraToTarget();
      var distance = Math.sqrt(Math.pow(t3d.getX(), 2) + Math.pow(t3d.getY(), 2) + Math.pow(t3d.getZ(), 2));
      if (distance < smallestDistance)
        smallestDistance = distance;
    }
    double poseAmbiguityFactor = estimate.targetsUsed.size() != 1 ? 1
        : Math.max(1,
            (estimate.targetsUsed.get(0).getPoseAmbiguity() + POSE_AMBIGUITY_SHIFTER) * POSE_AMBIGUITY_MULTIPLIER);
    double confidenceMultiplier = Math.max(1,
        (Math.max(1, Math.max(0, smallestDistance - NOISY_DISTANCE_METERS) * DISTANCE_WEIGHT) * poseAmbiguityFactor)
            / (1 + ((estimate.targetsUsed.size() - 1) * TAG_PRESENCE_WEIGHT)));

    var confidence = VISION_MEASUREMENT_STANDARD_DEVIATIONS.times(confidenceMultiplier);
    return confidence;
  }

  public static double getAverageTargetToCamDist(CustomEstimate estimate) {
    var distSum = 0;
    var targetCount = estimate.targetsUsed.size();
    if (targetCount == 0)
      return 1000;

    for (var target : estimate.targetsUsed) {
      var dist = target.getBestCameraToTarget().getTranslation().getNorm();
      distSum += dist;
    }
    return distSum / targetCount;
  }

  public static boolean isPoseInField(CustomEstimate estimate) {
    var xCheck = estimate.best.getX() >= 0 && estimate.best.getX() <= Constants.FIELD_CONSTANTS.LENGTH;
    var yCheck = estimate.best.getY() >= 0 && estimate.best.getY() <= Constants.FIELD_CONSTANTS.WIDTH;
    return xCheck && yCheck;
  }

  public static boolean isLevel(Vision vision) {
    return Math.abs(vision.swerve.getPitch()) < Units.degreesToRadians(10);
  }

  public static final Matrix<N3, N1> ROBOT_CASSEROLE_STDEV = VecBuilder.fill(0.9, 0.9, 0.009);

  public static boolean casseroleShouldFuse(CustomEstimate estimate, Vision vision) {
    var closeTargets = VisionHelper.getAverageTargetToCamDist(estimate) < Constants.FIELD_CONSTANTS.LENGTH * 0.25;
    var isPoseInField = VisionHelper.isPoseInField(estimate);
    var isLevel = VisionHelper.isLevel(vision);
    var acceptableAmbiguity = estimate.ambiguity < 0.15;
    if (closeTargets && isPoseInField && isLevel && acceptableAmbiguity) {
      return true;
    }
    return false;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.wrist;

import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.wrist.Wrist;
import frc.robot.subsystems.wrist.WristState.WristControlType;

public class AltWristControl extends CommandBase {
  private Wrist wrist;

  /** Creates a new SetWristAlternatePose. */
  public AltWristControl(Wrist wrist) {
    this.wrist = wrist;
    addRequirements(wrist);
    // Use addRequirements() here to declare subsystem dependencies.
  }

  // Called when the command is initially scheduled.
  @Override
  public void initialize() {}

  // Called every time the scheduler runs while the command is scheduled.
  @Override
  public void execute() {
    wrist.setGoalByType(WristControlType.ALT);
  }

  // Called once the command ends or is interrupted.
  @Override
  public void end(boolean interrupted) {}

  // Returns true when the command should end.
  @Override
  public boolean isFinished() {
    return false;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.wrist;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.wrist.Wrist;
import frc.robot.subsystems.wrist.WristState;

public class DebugWristControl extends CommandBase {
  private Wrist wrist;

  /** Creates a new DebugWristControl. */
  public DebugWristControl(Wrist wrist) {
    // Use addRequirements() here to declare subsystem dependencies.
    this.wrist = wrist;
    addRequirements(wrist);

    SmartDashboard.putNumber("Wrist/set goal", 0);
  }

  // Called when the command is initially scheduled.
  @Override
  public void initialize() {}

  // Called every time the scheduler runs while the command is scheduled.
  @Override
  public void execute() {
    var goal = SmartDashboard.getNumber("Wrist/set goal", 0);
    var goalState = WristState.getStateWithGoal(goal);
    wrist.setGoal(goalState);
  }

  // Called once the command ends or is interrupted.
  @Override
  public void end(boolean interrupted) {}

  // Returns true when the command should end.
  @Override
  public boolean isFinished() {
    return false;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.wrist;

import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.wrist.Wrist;
import frc.robot.subsystems.wrist.WristState.WristControlType;

public class DefaultWristControl extends CommandBase {
  private Wrist wrist;

  public DefaultWristControl(Wrist wrist) {
    this.wrist = wrist;
    addRequirements(wrist);
  }

  @Override
  public void execute() {
    wrist.setGoalByType(WristControlType.DEFAULT);
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.wrist;

import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.wrist.Wrist;
import frc.robot.subsystems.wrist.WristState;

public class ManualWristControl extends CommandBase {
  private Wrist wrist;
  private WristState state;

  /** Creates a new ManualWristControl. */
  public ManualWristControl(Wrist wrist, WristState state) {
    this.wrist = wrist;
    this.state = state;
    // Use addRequirements() here to declare subsystem dependencies.
    addRequirements(wrist);
  }

  // Called when the command is initially scheduled.
  @Override
  public void initialize() {}

  // Called every time the scheduler runs while the command is scheduled.
  @Override
  public void execute() {
    wrist.setGoal(state);
  }

  // Called once the command ends or is interrupted.
  @Override
  public void end(boolean interrupted) {}

  // Returns true when the command should end.
  @Override
  public boolean isFinished() {
    return false;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import org.photonvision.PhotonCamera;
import com.pathplanner.lib.PathConstraints;
import edu.wpi.first.apriltag.AprilTag;
import edu.wpi.first.apriltag.AprilTagFieldLayout;
import edu.wpi.first.apriltag.AprilTagFields;
import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Pose3d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Rotation3d;
import edu.wpi.first.math.geometry.Transform2d;
import edu.wpi.first.math.geometry.Transform3d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.math.geometry.Translation3d;
import edu.wpi.first.math.trajectory.TrapezoidProfile.Constraints;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.wpilibj.RobotBase;
import frc.robot.annotations.*;
import frc.robot.util.vision.SimCamParams;

/**
 * The Constants class provides a convenient place for teams to hold robot-wide numerical or boolean constants. This class should not be used for any other purpose. All
 * constants should be declared globally (i.e. public static final). Do not put anything functional in this class.
 *
 * <p>
 * It is advised to statically import this class (or one of its inner classes) wherever the constants are needed, to reduce verbosity.
 */
public class Constants extends AnnotatedClass {
  public static final boolean SIM_REPLAY_MODE = false;

  public static enum RobotMode {
    SIM, SIM_REPLAY, REAL
  }

  public static RobotMode getMode() {
    if (RobotBase.isReal()) {
      return RobotMode.REAL;
    }
    if (SIM_REPLAY_MODE) {
      return RobotMode.SIM_REPLAY;
    } else {
      return RobotMode.SIM;
    }
  }


  public static final class MECH_PLOT {
    public static final double PLOT_HEIGHT = 90;
    public static final double PLOT_WIDTH = 130;

    public static final double ARM_TOWER_LENGTH = 49;
    public static final double ARM_LENGTH = 39;
    public static final double WRIST_LENGTH = 11.5;
    public static final double CHASSIS_LENGTH = 30;

    public static final double ARM_PIVOT_X = PLOT_WIDTH / 2;
    public static final double ARM_PIVOT_Y = ARM_TOWER_LENGTH;

    public static final double CHASSIS_X = ARM_PIVOT_X - 24;//the chassis extends 24 inches behind the arm tower
    public static final double CHASSIS_Y = 0;

    public static final double ARM_REDUCTION = 200;
    public static final double WRIST_REDUCTION = 80; // DONT CHANGE THIS VALUE!!!!

    public static final double ARM_MASS = Units.lbsToKilograms(6);
    public static final double WRIST_MASS = Units.lbsToKilograms(0.5);//should be 3.5 but whatev

    public static final double[] SIM_WRIST_PID = {3, 0.5, 1};
  }

  public static class ARM {
    public static final int ARM_ID = 9;
    public static final double[] ARM_POS_PID = {0.086, 0, 0};
    public static final double[] ARM_VEL_PID = {0.009, 0, 0};
    // ks, kg, kv, ka
    public static final double[] ARM_FF = {0, 0.5, 3, 0};

    @NTPublish
    public static double VELOCITY = 50;
    public static final double POSE_TOLERANCE = 5;
    public static final double ANGLE_OFFSET = -270;
    public static final Constraints ARM_CONSTRAINTS = new Constraints(120, 150);
    public static final Constraints ARM_VEL_CONSTRAINTS = new Constraints(VELOCITY, 10);
    public static final double MAX_ANGLE = 10;
    public static final double MIN_ANGLE = -190;
  }

  public static final class WRIST {
    public static final int WRIST_ID = 10;
    public static final double[] WRIST_PID = {0.135, 0, 0};//0.17


    public static final double[] WRIST_FF = {0, 0.5, 0};
    public static final double ANGLE_OFFSET = -180;
    public static final double WRAP_RANGE_SPEED = 2;
    public static final double WRAP_RANGE_UPPER_BOUND = 135;
    public static final double WRAP_RANGE_LOWER_BOUND = -135;
  }

  public static final class GRABBER {
    /* Compressor min and max pressures */
    public static final double MIN_PRESSURE = 100;
    public static final double MAX_PRESSURE = 120;
  }

  public static final class DRIVE {
    // Drive, then steer ids
    public static final int[] FL_IDS = {1, 2};
    public static final int[] FR_IDS = {3, 4};
    public static final int[] RL_IDS = {5, 6};
    public static final int[] RR_IDS = {7, 8};

    // Chassis relative offset (degrees), then duty cycle encoder offset (whatever units they are)
    public static final double[] FL_OFFSETS = {270, 0.199};//-90
    public static final double[] FR_OFFSETS = {0, 0.543};
    public static final double[] RL_OFFSETS = {180, 0.534};
    public static final double[] RR_OFFSETS = {90, 0.033};//-90

    public static final double WHEEL_DIAMETER = Units.inchesToMeters(3);
    public static final double WHEEL_CIRCUMFERENCE = Math.PI * WHEEL_DIAMETER;

    public static final double DRIVE_PINION_TOOTH_COUNT = 13;
    // 45 teeth on the wheel's bevel gear, 22 teeth on the first-stage spur gear, 15 teeth on the bevel pinion
    public static final double DRIVE_GEAR_RATIO = (45.0 * 22) / (DRIVE_PINION_TOOTH_COUNT * 15);

    // Throughbore encoder is directly on the output steer shaft
    public static final double STEER_GEAR_RATIO = 1;

    public static final double DRIVE_POS_FACTOR = WHEEL_CIRCUMFERENCE / DRIVE_GEAR_RATIO; // rotations -> gear ratio adjusted rotations -> meters
    public static final double DRIVE_VEL_FACTOR = WHEEL_CIRCUMFERENCE / DRIVE_GEAR_RATIO / 60.0; // rpm -> gear ratio adjusted rpm -> meters/min -> meters/sec 

    public static final double DRIVE_FREE_SPEED = 5676 * DRIVE_VEL_FACTOR; // Convert max neo free speed to max free wheel speed

    public static final double STEER_POS_FACTOR = 2 * Math.PI; // rotations -> radians
    public static final double STEER_VEL_FACTOR = 2 * Math.PI * 60; // rpm -> rad/sec

    public static final double DIRECTION_SLEW_RATE = 3; // radians per second
    public static final double MAG_SLEW_RATE = 7.0; // percent per second (1 = 100%)
    public static final double ROT_SLEW_RATE = 7.0; // percent per second (1 = 100%)

    public static final int DRIVE_CURRENT_LIMIT = 40;
    public static final int STEER_CURRENT_LIMIT = 20;

    // order: p, i, d, f
    public static final double[] DRIVE_PIDF = {0.04, 0, 0, 1 / DRIVE_FREE_SPEED};
    public static final double[] STEER_PIDF = {1, 0, 0, 0};

    public static final Translation2d FL_POS =
        new Translation2d(Units.inchesToMeters(12.25), Units.inchesToMeters(13.25));
    public static final Translation2d FR_POS =
        new Translation2d(Units.inchesToMeters(12.25), Units.inchesToMeters(-13.25));
    public static final Translation2d RL_POS =
        new Translation2d(Units.inchesToMeters(-12.25), Units.inchesToMeters(13.25));
    public static final Translation2d RR_POS =
        new Translation2d(Units.inchesToMeters(-12.25), Units.inchesToMeters(-13.25));

    @NTPublish
    public static double HIGH_LIN_VEL = 5;

    public static double MID_LIN_VEL = 1.5;//set to 2

    public static double LOW_LIN_VEL = 0.5;
    @NTPublish
    public static double HIGH_ROT_VEL = 2.5;

    public static double MID_ROT_VEL = 1.5;

    public static double LOW_ROT_VEL = 0.5;

    @NTPublish
    public static double MAX_MODULE_SPEED = 5;
    @NTPublish
    public static double MAX_TRANSLATIONAL_SPEED = 2;
    @NTPublish
    public static double MAX_ROTATIONAL_SPEED = 1;
  }

  public static class AUTON {
    public static PIDController X_PID = new PIDController(5, 0, 0);//0.5
    public static PIDController Y_PID = new PIDController(5, 0, 0);//0.5
    public static PIDController ROT_PID = new PIDController(1.5, 0, 0);
    public static PathConstraints REALLY_SLOW_CONSTRAINTS = new PathConstraints(0.75, 0.7);
    public static PathConstraints SLOW_CONSTRAINTS = new PathConstraints(2, 1);
    public static PathConstraints MID_CONSTRAINTS = new PathConstraints(3, 1.5);
    public static PathConstraints FAST_CONSTRAINTS = new PathConstraints(7, 3);

    public static PathConstraints DOUBLE_CONE = new PathConstraints(4.5, 2.5);
    public static final PathConstraints DOCK_CONSTRAINTS = SLOW_CONSTRAINTS;

    public static final String EVENT_NAME = "Wayne";

    public static PIDController AUTO_BALANCE_PID = new PIDController(0.023, 0, 00);
    public static double AUTO_BALANCE_VEL = 0.5;
    public static double AUTO_BALANCE_PIVOT_ROLL = 7.5;
  }
  public static final class FIELD_CONSTANTS {
    public static final double WIDTH = 8.02;
    public static final double LENGTH = 15.8496;
    public static final Pose2d DEBUG_GO_TO_DEST = new Pose2d(1.9, 4.9, Rotation2d.fromDegrees(-180));
  }
  public static final class CONTROLLERS {
    public static final double JOYSTICK_DEADBAND = 0.075;
  }

  public static final class LEDS {
    public static final int PORT = 1;
    public static final int LENGTH = 12;
  }

  public static final class VISION {
    public static final HashMap<PhotonCamera, Transform3d> CAMS_AND_TRANS = new HashMap<PhotonCamera, Transform3d>() {
      {
        var robotTip = new Transform3d(
            new Translation3d(Units.inchesToMeters(12.9 - 1), Units.inchesToMeters(12.875), Units.inchesToMeters(48.1)),
            new Rotation3d(0, 0, 0));

        var ov9281Delta = new Transform3d(
            new Translation3d(Units.inchesToMeters(0), Units.inchesToMeters(-7.375), Units.inchesToMeters(1)),
            new Rotation3d(Units.degreesToRadians(29 + 180), 7.4, 0));
        var lifecamDelta = new Transform3d(
            new Translation3d(Units.inchesToMeters(0), Units.inchesToMeters(-18.5), Units.inchesToMeters(1)),
            new Rotation3d(Units.degreesToRadians(-29 + 180), 0, 0));

        put(new PhotonCamera("ov9281"), robotTip.plus(ov9281Delta));
        put(new PhotonCamera("lifecam"), robotTip.plus(lifecamDelta));
      }
    };

    public static AprilTagFieldLayout FIELD_ATFL = null;
    static {
      try {
        FIELD_ATFL = AprilTagFieldLayout.loadFromResource(AprilTagFields.kDefaultField.m_resourceFile);
      } catch (Exception e) {
      }
    }

    public static final List<AprilTag> TEST_TAGS = new ArrayList<AprilTag>() {
      {
        var id1Pose = new Pose3d(2.5, 2.5, 0, new Rotation3d(0, 0, 0));
        var id1Toid8 = new Transform3d(new Translation3d(0, 0.2159, 0), new Rotation3d(0, 0, 0));
        var id8Pose = id1Pose.plus(id1Toid8);

        add(new AprilTag(1, id1Pose));
        add(new AprilTag(8, id8Pose));
      }
    };
    public static final AprilTagFieldLayout TEST_ATFL = new AprilTagFieldLayout(TEST_TAGS, 5, 5);

    public static final AprilTagFieldLayout SHOP_ATFL;
    static {
      var apriltagsCopy = new ArrayList<AprilTag>();
      for (var apriltag : FIELD_ATFL.getTags()) {
        apriltagsCopy.add(new AprilTag(apriltag.ID, apriltag.pose));
      }

      apriltagsCopy.get(4 - 1).pose = new Pose3d(Units.inchesToMeters(340),
          apriltagsCopy.get(6 - 1).pose.getY() + Units.inchesToMeters(-133 + 49.875),
          apriltagsCopy.get(4 - 1).pose.getZ(), apriltagsCopy.get(4 - 1).pose.getRotation());

      SHOP_ATFL = new AprilTagFieldLayout(apriltagsCopy, FIELD_CONSTANTS.LENGTH, FIELD_CONSTANTS.WIDTH);
    }
  }

  public static final class VISION_SIM {
    public static final List<SimCamParams> SIM_CAMS_PARAMS = new ArrayList<SimCamParams>() {
      {
        add(new SimCamParams(92, 9000, 640, 400, 0,
            new Transform3d(new Translation3d(Units.inchesToMeters(21.552), Units.inchesToMeters(12.855 - 7.5),
                Units.inchesToMeters(48.24)), new Rotation3d(0, 0, Units.degreesToRadians(-36))),
            "ov9281"));
      }
    };
  }

  public static class AUTO_ALIGN {
    public enum FieldType {
      SHOP, REAL;
    }

    public static FieldType fieldType = FieldType.REAL;

    public static class GRID {
      public static final double ARM_THRESHOLD = 20;//in degrees
      public static final double ROT_THRESHOLD = 20;
      public static final double DIST_THRESHOLD = 1;
      public static final PathConstraints CONSTRAINTS = new PathConstraints(2, 1);
      public static final double COMMUNITY_THRESHOLD = 3;
    }
    public static class FEEDER {
      public static final double Y_THRESHOLD = 0.5;
      public static final double ROT_THRESHOLD = 20;//in degrees
      public static final double ARM_THRESHOLD = 20;//in degrees
      public static final double MIN_X = 10;
      public static final double MIN_Y = 5.6;
      public static final double MAX_Y = FIELD_CONSTANTS.WIDTH;
      public static final double MAX_X = FIELD_CONSTANTS.LENGTH;

      public static double DIST_THRESHOLD = 1;
      public static Pose2d RIGHT_PREP_POSE;
      public static Pose2d LEFT_PREP_POSE;
      public static Pose2d RIGHT_DEST_POSE;
      public static Pose2d LEFT_DEST_POSE;
      public static Transform2d PREP2DEST = new Transform2d(new Translation2d(-1, 0), new Rotation2d());
      public static PathConstraints CONSTRAINTS = new PathConstraints(2, 1);

      static {
        switch (fieldType) {
          case REAL:
            RIGHT_DEST_POSE = new Pose2d(15.5, 6, Rotation2d.fromDegrees(180));
            LEFT_DEST_POSE = new Pose2d(15.5, 7.5, Rotation2d.fromDegrees(180));
            break;
          case SHOP:
            RIGHT_DEST_POSE = new Pose2d(7.5, 1.5, Rotation2d.fromDegrees(180));
            LEFT_DEST_POSE = new Pose2d(7.5, 2.5, Rotation2d.fromDegrees(180));
            break;
        }
        RIGHT_PREP_POSE = RIGHT_DEST_POSE.transformBy(PREP2DEST.inverse());
        LEFT_PREP_POSE = LEFT_DEST_POSE.transformBy(PREP2DEST.inverse());
      }
    }
  }
}
package frc.robot.controllers;

import edu.wpi.first.wpilibj2.command.button.Trigger;

public interface AlignController {
  /* Just like numbers on a phone dial */
  public default Trigger one() {
    return new Trigger(() -> false);
  }

  public default Trigger two() {
    return new Trigger(() -> false);
  }

  public default Trigger three() {
    return new Trigger(() -> false);
  }

  public default Trigger four() {
    return new Trigger(() -> false);
  }

  public default Trigger five() {
    return new Trigger(() -> false);
  }

  public default Trigger six() {
    return new Trigger(() -> false);
  }

  public default Trigger seven() {
    return new Trigger(() -> false);
  }

  public default Trigger eight() {
    return new Trigger(() -> false);
  }

  public default Trigger nine() {
    return new Trigger(() -> false);
  }

  public default Trigger gridChosen() {
    return new Trigger(() -> false);
  }

  public default Trigger yChosen() {
    return new Trigger(() -> false);
  }

  public default Trigger xChosen() {
    return new Trigger(() -> false);
  }

  public default Trigger alignToGrid() {
    return new Trigger(() -> false);
  }

  public default int getChosenGrid() {
    return 0;
  }

  public default int getChosenY() {
    return 0;
  }

  public default int getChosenX() {
    return 0;
  }
}
package frc.robot.controllers;

import org.littletonrobotics.junction.Logger;
import edu.wpi.first.math.MathUtil;
import edu.wpi.first.wpilibj.DriverStation;
import frc.robot.Constants;

public class Controllers {

  private Controllers() {}

  private static String[] lastControllerNames = new String[6];

  public static DriverController driverController;
  public static OperatorController operatorController;
  public static AlignController alignController;

  /** Returns true if the connected controllers have changed since last called. */
  public static boolean didControllersChange() {
    boolean hasChanged = false;

    for (int i = 0; i < DriverStation.kJoystickPorts; i++) {
      String name = DriverStation.getJoystickName(i);
      if (!name.equals(lastControllerNames[i])) {
        hasChanged = true;
        lastControllerNames[i] = name;
      }
    }

    return hasChanged;
  }

  public static void updateActiveControllerInstance() {
    // Defaults, since a NullPointerException would be far worse than any warnings
    driverController = new DriverController() {};
    operatorController = new OperatorController() {};
    alignController = new AlignController() {};

    boolean foundOperatorController = false;
    boolean foundDriveController = false;
    boolean foundAlignController = false;

    for (int i = 0; i < DriverStation.kJoystickPorts; i++) {
      String joyName = DriverStation.getJoystickName(i);
      if (joyName.equals(""))
        continue;
      if (!foundOperatorController) {
        foundOperatorController = true;
        if (joyName.toLowerCase().contains("logitech")) {
          operatorController = new LogitechOperatorController(i);
          Logger.getInstance().recordOutput("controllers/operator controller",
              "Found logitech operator controller on port " + i);
        } else if (joyName.toLowerCase().contains("16000m")) {
          Logger.getInstance().recordOutput("controllers/operator controller",
              "Found thrustmaster operator controller on port " + i);
          operatorController = new ThrustMaster(i);
        } else if (joyName.toLowerCase().contains("USB Gamepad")) {
          Logger.getInstance().recordOutput("controllers/operator controller",
              "Found Sega operator controller on port " + i);
          operatorController = new SegaOperatorController(i);
        } else if (joyName.toLowerCase().contains("keyboard")) {
          operatorController = new LogitechOperatorController(i);
          Logger.getInstance().recordOutput("controllers/operator controller",
              "Found Thrustmaster operator controller on port " + i);
        } else {
          foundOperatorController = false;
        }
        if (foundOperatorController)
          continue;
      }

      if (!foundDriveController) {
        foundDriveController = true;
        if (joyName.toLowerCase().contains("xbox")) {
          Logger.getInstance().recordOutput("controllers/driver controller",
              "Found xbox drive controller controller on port " + i);
          driverController = new XboxDriverController(i);
        } else if (joyName.toLowerCase().contains("keyboard")) {
          Logger.getInstance().recordOutput("controllers/driver controller",
              "Found xbox drive controller controller on port " + i);
          driverController = new XboxDriverController(i);
        } else {
          foundDriveController = false;
        }
        if (foundDriveController)
          continue;
      }

      if (!foundAlignController) {
        foundAlignController = true;
        if (joyName.toLowerCase().contains("keyboard")) {
          Logger.getInstance().recordOutput("controllers/align controller",
              "Found keyboard align controller controller on port " + i);
          alignController = new KeypadAlignController(i);
        } else {
          foundAlignController = false;
        }
        if (foundAlignController)
          continue;
      }
    }
  }

  public static double deadband(double num) {
    return MathUtil.applyDeadband(num, Constants.CONTROLLERS.JOYSTICK_DEADBAND);
  }
}
package frc.robot.controllers;

import edu.wpi.first.wpilibj2.command.button.Trigger;

public interface DriverController {
  /** Axis used for moving forwards and backwards. Value between -1 and 1 */
  public default double getXMoveAxis() {
    return 0.0;
  }

  /** Axis used for moving left and right. Value between -1 and 1 */
  public default double getYMoveAxis() {
    return 0.0;
  }

  /** Axis used for rotating left and right. Value between -1 and 1. */
  public default double getRotateAxis() {
    return 0.0;
  }

  public default Trigger getPPLoadDebugForwardPath() {
    return new Trigger(() -> false);
  }

  public default Trigger getPPLoadDebugBackwardPath() {
    return new Trigger(() -> false);
  }

  public default Trigger getPPLoadDebugLeftPath() {
    return new Trigger(() -> false);
  }

  public default Trigger getPPLoadDebugRightPath() {
    return new Trigger(() -> false);
  }

  public default Trigger getPPGotoTag8() {
    return new Trigger(() -> false);
  }

  public default Trigger getResetPoseButton() {
    return new Trigger(() -> false);
  }

  public default Trigger HIGH_SPEED() {
    return new Trigger(() -> false);
  }

  public default Trigger LOW_SPEED() {
    return new Trigger(() -> false);
  }

  public default Trigger backUpFromFeeder() {
    return new Trigger(() -> false);
  }

  /* Button to set wheels into X formation */
  public default Trigger getSetWheelXButton() {
    return new Trigger(() -> false);
  }

  public default Trigger getSetHeading0Btn() {
    return new Trigger(() -> false);
  };

  public default Trigger getSetHeading90Btn() {
    return new Trigger(() -> false);
  };

  public default Trigger getSetHeading180Btn() {
    return new Trigger(() -> false);
  };

  public default Trigger getSetHeading270Btn() {
    return new Trigger(() -> false);
  };

  public default double getPOV() {
    return -1;
  }

  public default Trigger testDockPath() {
    return new Trigger(() -> false);
  }

  public default Trigger alignToFeederStation() {
    return new Trigger(() -> false);
  }

  public default Trigger alignToGrid() {
    return new Trigger(() -> false);
  }

  public default Trigger getAutoLeft() {
    return new Trigger(() -> false);
  };

  public default Trigger getAutoCenter() {
    return new Trigger(() -> false);
  };

  public default Trigger getAutoRight() {
    return new Trigger(() -> false);
  };

  public default Trigger getAutoAlign() {
    return new Trigger(() -> false);
  }
}
package frc.robot.controllers;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj2.command.button.JoystickButton;
import edu.wpi.first.wpilibj2.command.button.Trigger;

public class KeypadAlignController implements AlignController {
  Joystick joy;

  public KeypadAlignController(int id) {
    joy = new Joystick(id);
  }

  public Trigger one() {
    return new JoystickButton(joy, 1);
  }

  public Trigger two() {
    return new JoystickButton(joy, 2);
  }

  public Trigger three() {
    return new JoystickButton(joy, 3);
  }

  public Trigger four() {
    return new JoystickButton(joy, 4);
  }

  public Trigger five() {
    return new JoystickButton(joy, 5);
  }

  public Trigger six() {
    return new JoystickButton(joy, 6);
  }

  public Trigger seven() {
    return new JoystickButton(joy, 7);
  }

  public Trigger eight() {
    return new JoystickButton(joy, 8);
  }

  public Trigger nine() {
    return new JoystickButton(joy, 9);
  }

  public Trigger gridChosen() {
    return new Trigger(() -> {

      var one = one().getAsBoolean();
      var two = two().getAsBoolean();
      var three = three().getAsBoolean();

      return onlyOneIsTrue(one, two, three);
    });
  }

  public Trigger yChosen() {
    return new Trigger(() -> {
      var four = four().getAsBoolean();
      var five = five().getAsBoolean();
      var six = six().getAsBoolean();

      return onlyOneIsTrue(four, five, six);
    });
  }

  public Trigger xChosen() {
    return new Trigger(() -> {
      var seven = seven().getAsBoolean();
      var eight = eight().getAsBoolean();
      var nine = nine().getAsBoolean();

      return onlyOneIsTrue(seven, eight, nine);
    });
  }

  public Trigger alignToGrid() {
    return new Trigger(() -> {
      var gridChosen = gridChosen().getAsBoolean();
      var yChosen = yChosen().getAsBoolean();
      var xChosen = xChosen().getAsBoolean();

      return gridChosen && yChosen && xChosen;
    });
  }

  public boolean onlyOneIsTrue(Boolean... bools) {
    var found = false;
    var alreadyFound = false;
    for (var bool : bools) {
      if (bool) {
        found = true;
        if (alreadyFound) {
          found = false;
          break;
        } else {
          alreadyFound = true;
        }
      }
    }
    return found;
  }

  public int getChosenGrid() {
    var one = one().getAsBoolean();
    var two = two().getAsBoolean();
    var three = three().getAsBoolean();

    if (one) {
      return 1;
    } else if (two) {
      return 2;
    } else if (three) {
      return 3;
    } else {
      return 0;
    }
  }

  public int getChosenY() {
    var four = four().getAsBoolean();
    var five = five().getAsBoolean();
    var six = six().getAsBoolean();

    if (four) {
      return 1;
    } else if (five) {
      return 2;
    } else if (six) {
      return 3;
    } else {
      return 0;
    }
  }

  public int getChosenX() {
    var seven = seven().getAsBoolean();
    var eight = eight().getAsBoolean();
    var nine = nine().getAsBoolean();

    if (seven) {
      return 1;
    } else if (eight) {
      return 2;
    } else if (nine) {
      return 3;
    } else {
      return 0;
    }
  }
}
package frc.robot.controllers;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj2.command.button.JoystickButton;
import edu.wpi.first.wpilibj2.command.button.Trigger;

public class LogitechOperatorController implements OperatorController {

  Joystick joy;

  public LogitechOperatorController(int id) {
    joy = new Joystick(id);
  }

  @Override
  public double getArmAxis() {
    return -Controllers.deadband(joy.getY());
  }

  public Trigger armGoToLowNode() {
    return new JoystickButton(joy, 4);
  }

  public Trigger armGoToMidNode() {
    return new JoystickButton(joy, 3);
  }

  public Trigger armGoToHighNode() {
    return new JoystickButton(joy, 5);
  }

  public Trigger armGoToFeederStationNode() {
    return new JoystickButton(joy, 7);
  }

  public Trigger armGoToInsideRobotNode() {
    return new JoystickButton(joy, 6);
  }

  public Trigger setWristAlternatePose() {
    return new JoystickButton(joy, 1);
  }

  public Trigger openGrabber() {
    return new JoystickButton(joy, 2);
  }

  public Trigger throwCube() {
    return new JoystickButton(joy, 8);
  }

  public Trigger setArmByJoystick() {
    return new Trigger(() -> {
      if (Math.abs(getArmAxis()) > 0) {
        return true;
      }
      return false;
    });
  }
}
package frc.robot.controllers;

import edu.wpi.first.wpilibj2.command.button.Trigger;

public interface OperatorController {
  public default double getArmAxis() {
    return 0.0;
  }

  public default double getPOVAngle() {
    return -1;
  }

  public default Trigger armGoToLowNode() {
    return new Trigger(() -> false);
  }

  public default Trigger armGoToMidNode() {
    return new Trigger(() -> false);
  }

  public default Trigger armGoToHighNode() {
    return new Trigger(() -> false);
  }

  public default Trigger armGoToFeederStationNode() {
    return new Trigger(() -> false);
  }

  public default Trigger armGoToInsideRobotNode() {
    return new Trigger(() -> false);
  }

  public default Trigger armGoToGroundPickUpNode() {
    return new Trigger(() -> false);
  }

  public default Trigger setArmByJoystick() {
    return new Trigger(() -> false);
  }

  public default Trigger setWristAlternatePose() {
    return new Trigger(() -> false);
  }

  public default Trigger openGrabber() {
    return new Trigger(() -> false);
  }

  public default Trigger throwCube() {
    return new Trigger(() -> false);
  }
}
package frc.robot.controllers;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj2.command.button.JoystickButton;
import edu.wpi.first.wpilibj2.command.button.Trigger;

public class SegaOperatorController implements OperatorController {

  Joystick joy;

  public SegaOperatorController(int id) {
    joy = new Joystick(id);
  }

  public Trigger armGoToLowNode() {
    return new JoystickButton(joy, 5);
  }

  public Trigger armGoToMidNode() {
    return new JoystickButton(joy, 3);
  }

  public Trigger armGoToHighNode() {
    return new JoystickButton(joy, 2);
  }

  public Trigger armGoToFeederStationNode() {
    return new JoystickButton(joy, 4);
  }

  public Trigger armGoToInsideRobotNode() {
    return new JoystickButton(joy, 1);
  }

  public Trigger armGoToGroundPickUpNode() {
    return new JoystickButton(joy, 6);
  }

  public Trigger setWristAlternatePose() {
    return new JoystickButton(joy, 7);
  }

  public Trigger openGrabber() {
    return new JoystickButton(joy, 8);
  }

  private Trigger downDPAD() {
    return new JoystickButton(joy, 13);
  }

  private Trigger upDPAD() {
    return new JoystickButton(joy, 12);
  }

  public Double getPOV() {
    if (upDPAD().getAsBoolean()) {
      return 0.0;
    } else if (downDPAD().getAsBoolean()) {
      return 180.0;
    } else {
      return -1.0;
    }
  }
}
package frc.robot.controllers;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj2.command.button.JoystickButton;
import edu.wpi.first.wpilibj2.command.button.Trigger;

public class ThrustMaster implements OperatorController {

  Joystick joy;

  public ThrustMaster(int id) {
    joy = new Joystick(id);
  }

  @Override
  public double getArmAxis() {
    return -Controllers.deadband(joy.getY());
  }

  public double getPOVAngle() {
    return joy.getPOV();
  }

  public Trigger armGoToLowNode() {
    return new JoystickButton(joy, 5);
  }

  public Trigger throwCube() {
    return new JoystickButton(joy, 8);
  }

  public Trigger armGoToMidNode() {
    return new JoystickButton(joy, 6);
  }

  public Trigger armGoToHighNode() {
    return new JoystickButton(joy, 7);
  }

  public Trigger armGoToFeederStationNode() {
    return new JoystickButton(joy, 3);
  }

  public Trigger armGoToInsideRobotNode() {
    return new JoystickButton(joy, 4);
  }

  public Trigger setWristAlternatePose() {
    return new JoystickButton(joy, 2);
  }

  public Trigger openGrabber() {
    return new JoystickButton(joy, 1);
  }

  public Trigger setArmByJoystick() {
    return new Trigger(() -> {
      if (Math.abs(getArmAxis()) > 0) {
        return true;
      }
      return false;
    });
  }
}
package frc.robot.controllers;

import org.littletonrobotics.junction.Logger;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj2.command.button.JoystickButton;
import edu.wpi.first.wpilibj2.command.button.Trigger;

public class XboxDriverController implements DriverController {

  public XboxController controller;

  public XboxDriverController(int port) {
    controller = new XboxController(port);
  }

  @Override
  public double getXMoveAxis() {
    Logger.getInstance().recordOutput("TeleopDrive/Raw/xSpd", -controller.getLeftY());
    return -Controllers.deadband(controller.getLeftY());
  }

  public Trigger backUpFromFeeder() {
    return new JoystickButton(controller, XboxController.Button.kA.value);
  }

  @Override
  public double getYMoveAxis() {
    return -Controllers.deadband(controller.getLeftX());
  }


  @Override
  public double getRotateAxis() {
    // if (Constants.getMode() == Constants.RobotMode.SIM) {
    //   return -Controllers.deadband(controller.getRawAxis(2));
    // }
    if (getRotateButton().getAsBoolean()) {
      return 0;
    }
    return -Controllers.deadband(controller.getRightX());
  }

  public Trigger alignToFeederStation() {
    return new JoystickButton(controller, XboxController.Button.kB.value);
  }

  public Trigger alignToGrid() {
    return new JoystickButton(controller, XboxController.Button.kY.value);
  }

  public Trigger HIGH_SPEED() {
    return new JoystickButton(controller, XboxController.Button.kRightBumper.value);
  }

  public Trigger LOW_SPEED() {
    return new JoystickButton(controller, XboxController.Button.kLeftBumper.value);
  }

  private Trigger getRotateButton() {
    return new Trigger(() -> {
      return controller.getRightTriggerAxis() > 0.7;
    });
  }

  public Trigger getResetPoseButton() {
    return new JoystickButton(controller, XboxController.Button.kX.value);
  }

  /* Probably should change to something better but all the good buttons are used by the debug stuff */
  public Trigger getSetWheelXButton() {
    return new JoystickButton(controller, XboxController.Button.kStart.value);
  }

  public Trigger getSetHeading0Btn() {
    return new Trigger(() -> {
      return getRotateButton().getAsBoolean() && (controller.getRightY() < -0.75);
    });
  };

  public Trigger getSetHeading90Btn() {
    return new Trigger(() -> {
      return getRotateButton().getAsBoolean() && (controller.getRightX() < -0.75);
    });
  };

  public Trigger getSetHeading180Btn() {
    return new Trigger(() -> {
      return getRotateButton().getAsBoolean() && (controller.getRightY() > 0.75);
    });
  };

  public Trigger getSetHeading270Btn() {
    return new Trigger(() -> {
      return getRotateButton().getAsBoolean() && (controller.getRightX() > 0.75);
    });
  };

  public double getPOV() {
    return controller.getPOV();
  };

  public Trigger testDockPath() {
    return new JoystickButton(controller, XboxController.Button.kY.value);
  }

  public Trigger getAutoAlign() {

    return new Trigger(() -> {
      var left = getAutoLeft().getAsBoolean();
      var center = getAutoCenter().getAsBoolean();
      var right = getAutoRight().getAsBoolean();
      return (left || center || right);
    });
  }

  public Trigger getAutoLeft() {
    return new JoystickButton(controller, XboxController.Button.kX.value);
  };

  public Trigger getAutoCenter() {
    return new JoystickButton(controller, XboxController.Button.kY.value);
  };

  public Trigger getAutoRight() {
    return new JoystickButton(controller, XboxController.Button.kB.value);
  };
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;

import edu.wpi.first.wpilibj.RobotBase;

/**
 * Do NOT add any static variables to this class, or any initialization at all. Unless you know what you are doing, do not modify this file except to change the parameter
 * class to the startRobot call.
 */
public final class Main {
  private Main() {}

  /**
   * Main initialization function. Do not perform any initialization here.
   *
   * <p>
   * If you change your main robot class, change the parameter type.
   */
  public static void main(String... args) {
    RobotBase.startRobot(Robot::new);
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;

import org.littletonrobotics.junction.LogFileUtil;
import org.littletonrobotics.junction.LoggedRobot;
import org.littletonrobotics.junction.Logger;
import org.littletonrobotics.junction.networktables.NT4Publisher;
import org.littletonrobotics.junction.wpilog.WPILOGReader;
import org.littletonrobotics.junction.wpilog.WPILOGWriter;

import com.pathplanner.lib.server.PathPlannerServer;
import com.revrobotics.REVPhysicsSim;

import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.CommandScheduler;

import frc.robot.Constants.RobotMode;
import frc.robot.auton.TestPlaceThenDock;
import frc.robot.util.NTToAdvantageKit;

/**
 * The VM is configured to automatically run this class, and to call the functions corresponding to each mode, as described in the TimedRobot documentation. If you change
 * the name of this class or the package after creating this project, you must also update the build.gradle file in the project.
 */
public class Robot extends LoggedRobot {
  private Command autonCommand;
  private RobotContainer robotContainer;

  /**
   * This function is run when the robot is first started up and should be used for any initialization code.
   */
  @Override
  @SuppressWarnings("all")
  public void robotInit() {

    setUseTiming(Constants.getMode() != RobotMode.SIM_REPLAY); // Run as fast as possible during replay
    Logger.getInstance().recordMetadata("GitSHA", BuildConstants.GIT_SHA);
    Logger.getInstance().recordMetadata("BuildDate", BuildConstants.BUILD_DATE);
    Logger.getInstance().recordMetadata("IsDirty", Boolean.toString(BuildConstants.DIRTY != 0));

    if (Constants.getMode() == RobotMode.REAL) {
      Logger.getInstance().addDataReceiver(new WPILOGWriter("/media/sda1/")); // Log to a USB stick
      Logger.getInstance().addDataReceiver(new NT4Publisher()); // Publish data to NetworkTables
    } else if (Constants.getMode() == RobotMode.SIM_REPLAY) {
      String path = LogFileUtil.findReplayLog(); // Pull the replay log from AdvantageScope (or prompt the user)
      Logger.getInstance().setReplaySource(new WPILOGReader(path)); // Read replay log
      Logger.getInstance().addDataReceiver(new WPILOGWriter(LogFileUtil.addPathSuffix(path, "_sim"))); // Save outputs to a new log
    } else { // Probably sim (non-replay)
      Logger.getInstance().addDataReceiver(new WPILOGWriter("./")); // Log to current directory
      Logger.getInstance().addDataReceiver(new NT4Publisher()); // Publish data to NetworkTables
    }

    Logger.getInstance().start(); // Start logging! No more data receivers, replay sources, or metadata values may be added.

    PathPlannerServer.startServer(5811);
    LiveWindow.disableAllTelemetry();
    Constants.processAnnotations(Constants.class);
    /* Somewhat cursed but it'll work */
    SmartDashboard.putData("Constants", new Constants());
    // Instantiate our RobotContainer.  This will perform all our button bindings, and put our
    // autonomous chooser on the dashboard.
    robotContainer = new RobotContainer();
  }

  /**
   * This function is called every robot packet, no matter the mode. Use this for items like diagnostics that you want ran during disabled, autonomous, teleoperated and
   * test.
   *
   * <p>
   * This runs after the mode specific periodic functions, but before LiveWindow and SmartDashboard integrated updating.
   */
  @Override
  public void robotPeriodic() {
    // Runs the Scheduler.  This is responsible for polling buttons, adding newly-scheduled
    // commands, running already-scheduled commands, removing finished or interrupted commands,
    // and running subsystem periodic() methods.  This must be called from the robot's periodic
    // block in order for anything in the Command-based framework to work.
    CommandScheduler.getInstance().run();
    NTToAdvantageKit.periodic();
    robotContainer.updateControllers();
  }

  /** This function is called once each time the robot enters Disabled mode. */
  @Override
  public void disabledInit() {}

  @Override
  public void disabledPeriodic() {}

  /** This autonomous runs the autonomous command selected by your {@link RobotContainer} class. */
  @Override
  public void autonomousInit() {
    autonCommand = robotContainer.getAutonomousCommand();
    robotContainer.clearTeleopDefault();

    // schedule the autonomous command (example)
    if (autonCommand != null) {
      autonCommand.schedule();
    }
  }

  /** This function is called periodically during autonomous. */
  @Override
  public void autonomousPeriodic() {}

  @Override
  public void teleopInit() {
    // This makes sure that the autonomous stops running when
    // teleop starts running. If you want the autonomous to
    // continue until interrupted by another command, remove
    // this line or comment it out.
    if (autonCommand != null) {
      autonCommand.cancel();
    }
    TestPlaceThenDock.initDockTestingTelemetry();
    robotContainer.setTeleopDefault();
  }

  /** This function is called periodically during operator control. */
  @Override
  public void teleopPeriodic() {}

  @Override
  public void testInit() {
    // Cancels all running commands at the start of test mode.
    CommandScheduler.getInstance().cancelAll();
  }

  /** This function is called periodically during test mode. */
  @Override
  public void testPeriodic() {}

  @Override
  public void simulationPeriodic() {
    REVPhysicsSim.getInstance().run();
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;

import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Paths;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj.Filesystem;
import edu.wpi.first.wpilibj.GenericHID;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import frc.robot.Constants.DRIVE;
import frc.robot.commands.arm.JoystickArmControl;
import frc.robot.commands.arm.SetArmPose;
import frc.robot.commands.arm.StowArm;
import frc.robot.commands.arm.Throw;
import frc.robot.commands.arm.ThrowState;
import frc.robot.commands.arm.SetArmPose.ArmPose;
import frc.robot.commands.drive.TeleopDrive;
import frc.robot.commands.wrist.AltWristControl;
import frc.robot.commands.wrist.DefaultWristControl;
import frc.robot.commands.wrist.ManualWristControl;
import frc.robot.controllers.Controllers;
import frc.robot.subsystems.drive.Swerve;
import frc.robot.auton.AutonChooser;
import frc.robot.subsystems.Grabber;
import frc.robot.subsystems.leds.Leds;
import frc.robot.subsystems.vision.Vision;
import frc.robot.subsystems.arm.Arm;
import frc.robot.subsystems.arm.ArmSim;
import frc.robot.subsystems.wrist.Wrist;
import frc.robot.subsystems.wrist.WristSim;
import frc.robot.subsystems.wrist.WristState;
import frc.robot.util.MoreMath;
import frc.robot.subsystems.drive.SwerveModule;
import frc.robot.subsystems.drive.SwerveModuleIO;
import frc.robot.subsystems.drive.SwerveModuleSim;
import frc.robot.subsystems.drive.gyro.Gyro;
import frc.robot.subsystems.drive.gyro.GyroIO;
import frc.robot.subsystems.drive.gyro.GyroSim;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.CommandScheduler;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.ProxyCommand;
import edu.wpi.first.wpilibj2.command.StartEndCommand;

/**
 * This class is where the bulk of the robot should be declared. Since Command-based is a "declarative" paradigm, very little robot logic should actually be handled in
 * the {@link Robot} periodic methods (other than the scheduler calls). Instead, the structure of the robot (including subsystems, commands, and button mappings) should
 * be declared here.
 */
public class RobotContainer {
  // The robot's subsystems and commands are defined here...
  private final Swerve swerve;
  @SuppressWarnings("unused")
  private Vision vision;
  private final AutonChooser autonChooser;
  private final Arm arm;
  private Wrist wrist;
  private Grabber grabber;
  private Leds leds;

  public String readPipelineFile() {
    try {
      return Files.readString(Paths.get(Filesystem.getDeployDirectory().getAbsolutePath(), "streampath.json"),
          Charset.forName("UTF-8"));
    } catch (Exception e) {
      e.printStackTrace();
      return "";
    }
  }

  /** The container for the robot. Contains subsystems, OI devices, and commands. */
  public RobotContainer() {
    // Configure default teleop command
    // Ideally, we publish this from vision-testing, but this is fine for now. In a deploy file because escaping quotation marks is ugly and annoying
    NetworkTableInstance.getDefault().getStringTopic("/VisionTestingPipeline").publish().set(readPipelineFile());
    switch (Constants.getMode()) {
      case REAL:
        SmartDashboard.putString("/Mode", "REAL");
        swerve = new Swerve(new Gyro(SPI.Port.kMXP, true),
            new SwerveModule(0, DRIVE.FL_IDS[0], DRIVE.FL_IDS[1], DRIVE.FL_OFFSETS, "FL"),
            new SwerveModule(1, DRIVE.FR_IDS[0], DRIVE.FR_IDS[1], DRIVE.FR_OFFSETS, "FR"),
            new SwerveModule(2, DRIVE.RL_IDS[0], DRIVE.RL_IDS[1], DRIVE.RL_OFFSETS, "RL"),
            new SwerveModule(3, DRIVE.RR_IDS[0], DRIVE.RR_IDS[1], DRIVE.RR_OFFSETS, "RR"));
        arm = new Arm();
        wrist = new Wrist(arm);
        // vision = new Vision(swerve);
        break;
      case SIM:
        SmartDashboard.putString("/Mode", "SIM");
        swerve =
            new Swerve(new GyroSim(), new SwerveModuleSim(0, DRIVE.FL_IDS[0], DRIVE.FL_IDS[1], DRIVE.FL_OFFSETS, "FL"),
                new SwerveModuleSim(1, DRIVE.FR_IDS[0], DRIVE.FR_IDS[1], DRIVE.FR_OFFSETS, "FR"),
                new SwerveModuleSim(2, DRIVE.RL_IDS[0], DRIVE.RL_IDS[1], DRIVE.RL_OFFSETS, "RL"),
                new SwerveModuleSim(3, DRIVE.RR_IDS[0], DRIVE.RR_IDS[1], DRIVE.RR_OFFSETS, "RR"));
        arm = new ArmSim();
        wrist = new WristSim((ArmSim) arm);
        vision = new Vision(swerve);
        // vision.setDefaultCommand(new FuseVisionEstimate(vision, ConfidenceStrat.MECH_ADV));
        break;
      default:
      case SIM_REPLAY:
        SmartDashboard.putString("/Mode", "SIM_REPLAY");
        swerve = new Swerve(new GyroIO() {}, new SwerveModuleIO() {}, new SwerveModuleIO() {}, new SwerveModuleIO() {},
            new SwerveModuleIO() {});
        arm = new ArmSim();
        wrist = new WristSim((ArmSim) arm);
        vision = new Vision(swerve);
        break;
    }

    grabber = new Grabber();
    autonChooser = new AutonChooser(swerve, arm, wrist, grabber);
    leds = new Leds();
    wrist.setDefaultCommand(new DefaultWristControl(wrist));
    // Configure the button binding

    // swerve.setDefaultCommand(new TeleopDrive(swerve));
    arm.setDefaultCommand(new JoystickArmControl(arm));
    // vision.setDefaultCommand(new UpdateSwervePoseEstimator(vision).ignoringDisable(true));
    updateControllers();

    // PortForwarder.add(5800, "photonvision.local", 5800);
    // PortForwarder.add(5801, "photonvisionpi.local", 5800);
  }



  /**
   * Use this method to define your button->command mappings. Buttons can be created by instantiating a {@link GenericHID} or one of its subclasses
   * ({@link edu.wpi.first.wpilibj.Joystick} or {@link XboxController}), and then passing it to a {@link edu.wpi.first.wpilibj2.command.button.JoystickButton}.
   */
  public void updateControllers() {
    // Do nothing if controller layout hasn't changed.
    if (!Controllers.didControllersChange())
      return;
    System.out.println("Updating controller layout");

    // Clear buttons
    CommandScheduler.getInstance().getActiveButtonLoop().clear();

    // Find new controllers
    Controllers.updateActiveControllerInstance();

    // Put new bindings here.
    // Controllers.driverController.getPPLoadDebugForwardPath()
    //     .toggleOnTrue(AutonPaths.getCommandForPath("StartN1-GamePiece1", true, AUTON.SLOW_CONSTRAINTS, swerve));

    // Controllers.driverController.getPPLoadDebugBackwardPath()
    //     .toggleOnTrue(AutonPaths.getCommandForPath("GamePiece1-StartN1", true, AUTON.SLOW_CONSTRAINTS, swerve));

    // This command puts the robot 1 meter in front of apriltag 8 (middle of bottom left grid on pathplanner picture of 2023 field)
    // Controllers.driverController.getPPGotoTag8().onTrue(new InstantCommand(() -> {
    //   swerve.goTo(Constants.FIELD_CONSTANTS.DEBUG_GO_TO_DEST, AUTON.SLOW_CONSTRAINTS).schedule();
    // }));

    // Controllers.driverController.getResetPoseButton().onTrue(new InstantCommand(() -> {
    //   swerve.setPose(new Pose2d(3, 0.38, Rotation2d.fromDegrees(90)));
    // }));

    Controllers.driverController.backUpFromFeeder().onTrue(new ProxyCommand(() -> {
      var currentPose = swerve.getPose();
      var dest = MoreMath.deepCopyPose(currentPose);
      var translation = new Translation2d(Units.inchesToMeters(-4), 0);
      dest = new Pose2d(dest.getTranslation().plus(translation), dest.getRotation());
      return swerve.goTo(dest, Constants.AUTON.MID_CONSTRAINTS);
    }));
    Controllers.driverController.getResetPoseButton().onTrue(new InstantCommand(() -> {
      swerve.setPose(new Pose2d());
    }, swerve));
    // Controllers.driverController.getAutoAlign().onTrue(new AutoAlign(swerve, arm));

    Controllers.operatorController.armGoToLowNode()
        .onTrue(new SetArmPose(arm, ArmPose.LOW_NODE).andThen(new ManualWristControl(wrist, WristState.RIGHT)));
    Controllers.operatorController.armGoToMidNode().onTrue(new SetArmPose(arm, ArmPose.MID_NODE));
    Controllers.operatorController.armGoToHighNode().onTrue(new SetArmPose(arm, ArmPose.HIGH_NODE));
    Controllers.operatorController.armGoToInsideRobotNode().onTrue(new StowArm(arm, wrist));
    Controllers.operatorController.armGoToFeederStationNode().onTrue(new SetArmPose(arm, ArmPose.FEEDER_STATION));
    Controllers.operatorController.setWristAlternatePose().whileTrue(new AltWristControl(wrist).repeatedly());
    Controllers.operatorController.openGrabber().whileTrue(new StartEndCommand(grabber::open, grabber::close, grabber));
    Controllers.operatorController.setArmByJoystick().onTrue(new JoystickArmControl(arm));

    Controllers.operatorController.throwCube().onTrue(
      new Throw(arm, wrist, grabber, leds, new ThrowState(-45, 30, 0)));
  }

  /**
   * Use this to pass the autonomous command to the main {@link Robot} class.
   *
   * @return the command to run in autonomous
   */
  public Command getAutonomousCommand() {
    return autonChooser.getSelectedAuton();
  }

  public void setTeleopDefault() {
    swerve.setDefaultCommand(new TeleopDrive(swerve));
  }

  public void clearTeleopDefault() {
    swerve.setDefaultCommand(new InstantCommand(() -> {
    }, swerve));
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.subsystems.arm;

import org.littletonrobotics.junction.Logger;
import com.revrobotics.CANSparkMax;
import com.revrobotics.SparkMaxAbsoluteEncoder;
import com.revrobotics.CANSparkMax.FaultID;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMax.SoftLimitDirection;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.CANSparkMaxLowLevel.PeriodicFrame;
import com.revrobotics.SparkMaxAbsoluteEncoder.Type;
import edu.wpi.first.math.MathUtil;
import edu.wpi.first.math.controller.ProfiledPIDController;
import edu.wpi.first.math.trajectory.TrapezoidProfile;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants.ARM;
import frc.robot.util.SendableArmFeedforward;

public class Arm extends SubsystemBase {
  /** Creates a new arm. */
  public boolean configureHasRan = false;
  private int zeroCount = 0;
  private TrapezoidProfile.State poseGoal = new TrapezoidProfile.State();
  private double velGoal = 0;
  protected CANSparkMax motor = new CANSparkMax(ARM.ARM_ID, MotorType.kBrushless);
  private SparkMaxAbsoluteEncoder encoder = motor.getAbsoluteEncoder(Type.kDutyCycle);
  private ProfiledPIDController pid =
      new ProfiledPIDController(ARM.ARM_POS_PID[0], ARM.ARM_POS_PID[1], ARM.ARM_POS_PID[2], ARM.ARM_CONSTRAINTS);
  private ProfiledPIDController velPid =
      new ProfiledPIDController(ARM.ARM_VEL_PID[0], ARM.ARM_VEL_PID[1], ARM.ARM_VEL_PID[2], ARM.ARM_VEL_CONSTRAINTS);
  private SendableArmFeedforward ff =
      new SendableArmFeedforward(ARM.ARM_FF[0], ARM.ARM_FF[1], ARM.ARM_FF[2], ARM.ARM_FF[3]);
  private double lastTime = Timer.getFPGATimestamp();
  private double lastVel = 0;
  private double acceleration;

  public enum ArmControlMode {
    VEL("Velocity"), POS("Position"), VOLTAGE("voltage");

    public final String name;

    private ArmControlMode(String name) {
      this.name = name;
    }
  }

  private ArmControlMode controlMode;
  private boolean prevDisabled;

  public Arm() {
    controlMode = ArmControlMode.VEL;
    configure();

    SmartDashboard.putData("Arm/pPid", pid);
    SmartDashboard.putData("Arm/vPid", velPid);
    SmartDashboard.putData("Arm/ff", ff);
    setPoseGoal(getPose());
    resetPIDs();
    prevDisabled = !DriverStation.isEnabled();
  }

  public void setControlMode(ArmControlMode mode) {
    controlMode = mode;
  }

  public void resetPIDs() {
    pid.reset(getPose(), getVel());
    velPid.reset(getVel(), 0);
  }

  public TrapezoidProfile.State getPoseGoal() {
    return poseGoal;
  }

  public void setPoseGoal(double poseGoal) {
    this.poseGoal = new TrapezoidProfile.State(poseGoal, 0);
  }

  public void setPoseGoal(TrapezoidProfile.State poseGoal){
    this.poseGoal= poseGoal; 
  }

  public double getVelGoal() {
    return velGoal;
  }

  public void setVelGoal(double newGoal) {
    velGoal = newGoal;
  }

  public double getPose() {
    return encoder.getPosition() + ARM.ANGLE_OFFSET;
  }

  public double getVel() {
    return encoder.getVelocity();
  }

  public void setVoltage(double volts) {
    Logger.getInstance().recordOutput("Arm/Appliedvolts", volts);
    motor.setVoltage(volts);
  }

  public double getVoltage() {
    return motor.getAppliedOutput() * motor.getBusVoltage();
  }

  @Override
  public void periodic() {
    if (prevDisabled && DriverStation.isEnabled()) {
      setPoseGoal(getPose());
      resetPIDs();
    }
    prevDisabled = !DriverStation.isEnabled();

    if (sensorErrorHandler()) {
      DriverStation.reportError("OUR ZERO ERROR IN ARM", true);
      setVoltage(0);
      if (configureHasRan == false) {
        configure();
      }
      configureHasRan = true;
      return;
    }

    var pose = getPose();
    var vel = getVel();
    var volts = 0.0;

    /* Calculate accleration. IT'S DOUBLE DIFFERENTIATION TIME*/
    acceleration = (vel - lastVel) / (Timer.getFPGATimestamp() - lastTime);

    Logger.getInstance().recordOutput("Arm/CurrentPose", pose);
    Logger.getInstance().recordOutput("Arm/CurrentVel", vel);
    Logger.getInstance().recordOutput("Arm/Acceleration", acceleration);
    Logger.getInstance().recordOutput("Arm/Pose/Pose Goal", poseGoal.position);
    Logger.getInstance().recordOutput("Arm/Pose/Vel Goal", poseGoal.velocity);
    Logger.getInstance().recordOutput("Arm/Vel/Goal", velGoal);
    Logger.getInstance().recordOutput("Arm/ControlMode", controlMode.name);
    Logger.getInstance().recordOutput("Arm/Pose/pose setpoint", pid.getSetpoint().position);
    Logger.getInstance().recordOutput("Arm/Pose/vel setpoint", pid.getSetpoint().velocity);
        Logger.getInstance().recordOutput("Arm/current command", this.getCurrentCommand() != null ? this.getCurrentCommand().getName() : "");

    Logger.getInstance().recordOutput("Arm/Vel/Setpoint", velPid.getSetpoint().position);

    /* Controlled entirely via setVoltage() */
    if (controlMode == ArmControlMode.VOLTAGE)
      return;

    if (controlMode == ArmControlMode.VEL) {
      volts = velControl();
    } else {
      volts = poseControl();
    }

    lastVel = getVel();
    lastTime = Timer.getFPGATimestamp();

    volts = applySoftLimit(volts);
    setVoltage(volts);
  }

  public boolean sensorErrorHandler() {
    boolean hasFaults = motor.getFault(FaultID.kCANTX) || motor.getFault(FaultID.kCANRX);
    boolean hasStickyFaults = motor.getStickyFault(FaultID.kCANTX) || motor.getStickyFault(FaultID.kCANRX);
    var pose = encoder.getPosition();

    if (pose == 0 || pose > 2000 || pose < -2000) {
      zeroCount++;
    }

    var zeroCountFault = zeroCount > 1;
    Logger.getInstance().recordOutput("Arm/Faults/Zero Count Fault", zeroCountFault);
    Logger.getInstance().recordOutput("Arm/Faults/Fault", hasFaults);
    Logger.getInstance().recordOutput("Arm/Faults/Sticky Fault", hasStickyFaults);

    if (hasStickyFaults) {
      DriverStation.reportWarning("Arm Sticky Fault", true);
    }
    return zeroCountFault || hasFaults;
  }

  public double poseControl() {
    var pose = getPose();
    double pidval = pid.calculate(pose, poseGoal);
    double ffval = ff.calculate(pid.getSetpoint().position, pid.getSetpoint().velocity); // ff wants 0 parallel to floor in pos x

    Logger.getInstance().recordOutput("Arm/Pose/FFval", ffval);
    Logger.getInstance().recordOutput("Arm/Pose/PIDval", pidval);
    Logger.getInstance().recordOutput("Arm/Pose/Error", pid.getPositionError());

    velPid.reset(getVel(), 0); // do not replace 0 with acceleration
    return ffval + pidval;
  }

  public double velControl() {
    var pose = getPose();
    var vel = getVel();

    /* Prospective Soft Limit */
    if ((getPose() + velGoal * 0.02 > ARM.MAX_ANGLE)) {
      velGoal = 0;
    } else if ((getPose() + velGoal * 0.02 < ARM.MIN_ANGLE)) {
      velGoal = 0;
    }

    double ffval = ff.calculate(pose, velGoal);
    double pidval = velPid.calculate(vel, velGoal);

    Logger.getInstance().recordOutput("Arm/Vel/FFval", ffval);
    Logger.getInstance().recordOutput("Arm/Vel/PIDval", pidval);
    Logger.getInstance().recordOutput("Arm/Vel/Error", velPid.getPositionError());

    setPoseGoal(pose);
    pid.reset(getPose(), getVel());
    return ffval + pidval;
  }

  private double applySoftLimit(double volts) {
    if (((getPose() > ARM.MAX_ANGLE) && volts > 0) || ((getPose() < ARM.MIN_ANGLE) && volts < 0)) {
      return 0;
    }
    return volts;
  }

  private void configure() {
    motor.restoreFactoryDefaults();
    motor.setInverted(false);
    motor.setSmartCurrentLimit(50);
    encoder.setInverted(false);
    motor.setIdleMode(IdleMode.kBrake);
    encoder.setPositionConversionFactor(360);
    encoder.setVelocityConversionFactor(360);

    //currently useless
    motor.setSoftLimit(SoftLimitDirection.kForward, (float) (ARM.MAX_ANGLE - ARM.ANGLE_OFFSET));
    motor.setSoftLimit(SoftLimitDirection.kReverse, (float) (ARM.MIN_ANGLE - ARM.ANGLE_OFFSET));
    motor.enableSoftLimit(SoftLimitDirection.kForward, false);
    motor.enableSoftLimit(SoftLimitDirection.kReverse, false);

    /* Status 0 governs applied output, faults, and whether is a follower. Not important for this. */
    motor.setPeriodicFramePeriod(PeriodicFrame.kStatus0, 20);
    /* Integrated motor position isn't important here. */
    motor.setPeriodicFramePeriod(PeriodicFrame.kStatus2, 500);
    /* Don't have an analog sensor */
    motor.setPeriodicFramePeriod(PeriodicFrame.kStatus3, 500);
    /* Don't have an alternate encoder */
    motor.setPeriodicFramePeriod(PeriodicFrame.kStatus4, 500);
    /* Have a duty cycle encoder */
    motor.setPeriodicFramePeriod(PeriodicFrame.kStatus5, 20);
    motor.setPeriodicFramePeriod(PeriodicFrame.kStatus6, 20);

    try {
      Thread.sleep((long) 40.0);
    } catch (Exception e) {
      e.printStackTrace();
    } ;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.subsystems.arm;

import edu.wpi.first.math.MathUtil;
import edu.wpi.first.math.VecBuilder;
import edu.wpi.first.math.system.plant.DCMotor;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.wpilibj.simulation.SingleJointedArmSim;
import edu.wpi.first.wpilibj.smartdashboard.Mechanism2d;
import edu.wpi.first.wpilibj.smartdashboard.MechanismLigament2d;
import edu.wpi.first.wpilibj.smartdashboard.MechanismRoot2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.util.Color;
import edu.wpi.first.wpilibj.util.Color8Bit;
import frc.robot.Constants.MECH_PLOT;

public class ArmSim extends Arm {
  private double simVolts = 0;

  /** Creates a new ArmSim. */
  public ArmSim() {
    super();
    SmartDashboard.putData("Arm", m_mech2d);
  }

  public void simulationPeriodic() {
    // In this method, we update our simulation of what our arm is doing
    // First, we set our "inputs" (voltages)
    m_armSim.setInput(this.simVolts);

    // Next, we update it. The standard loop time is 20ms.
    m_armSim.update(0.020);

    // Update the Mechanism Arm angle based on the simulated arm angle
    m_arm.setAngle(Units.radiansToDegrees(m_armSim.getAngleRads()));
    SmartDashboard.putNumber("Arm Vel", m_armSim.getVelocityRadPerSec());
  }

  @Override
  public double getPose() {
    return Units.radiansToDegrees(m_armSim.getAngleRads());
  }

  @Override
  public double getVel() {
    return Units.radiansToDegrees(m_armSim.getVelocityRadPerSec());
  }

  @Override
  public void setVoltage(double volts) {
    this.simVolts = MathUtil.clamp(volts,-12,12);
  }

  @Override
  public double getVoltage() {
    return this.simVolts;
  }

  @Override
  public boolean sensorErrorHandler() {
    return false;
  }

  // Setting The Scenery
  private static final DCMotor m_armGearbox = DCMotor.getNEO(1);

  private static final double m_armReduction = 200;
  private static final double m_armMass = 8.0; // Kilograms
  private static final double m_armLength = Units.inchesToMeters(20);
  private static final SingleJointedArmSim m_armSim = new SingleJointedArmSim(m_armGearbox, m_armReduction,
      SingleJointedArmSim.estimateMOI(m_armLength, m_armMass), m_armLength, -1e10, 1e10, true, VecBuilder.fill(0.001) // Add noise with a std-dev of 1 tick
  );

  public static final Mechanism2d m_mech2d = new Mechanism2d(MECH_PLOT.PLOT_WIDTH, MECH_PLOT.PLOT_HEIGHT);

  public static final MechanismRoot2d m_armPivot =
      m_mech2d.getRoot("ArmPivot", MECH_PLOT.ARM_PIVOT_X, MECH_PLOT.ARM_PIVOT_Y);
  private static final MechanismLigament2d m_armTower = m_armPivot.append(
      new MechanismLigament2d("ArmTower", MECH_PLOT.ARM_TOWER_LENGTH, -90, 10.0, new Color8Bit(Color.kDarkGray)));
  public static final MechanismLigament2d m_arm = m_armPivot.append(new MechanismLigament2d("Arm", MECH_PLOT.ARM_LENGTH,
      Units.radiansToDegrees(m_armSim.getAngleRads()), 10.0, new Color8Bit(Color.kGray)));

  public static final MechanismRoot2d m_chassisPivot =
      m_mech2d.getRoot("ChassisPivot", MECH_PLOT.CHASSIS_X, MECH_PLOT.CHASSIS_Y);
  private static final MechanismLigament2d m_chassis = m_chassisPivot
      .append(new MechanismLigament2d("Chassis", MECH_PLOT.CHASSIS_LENGTH, 0, 100.0, new Color8Bit(Color.kDarkRed)));

  public static final MechanismRoot2d feederPivot = m_mech2d.getRoot("Feeder Pivot", 5, 25);
  private static final MechanismLigament2d feeder =
      feederPivot.append(new MechanismLigament2d("Feeder", 10, 0, 30.0, new Color8Bit(Color.kWhite)));

  // public final MechanismRoot2d midNodePivot = m_mech2d.getRoot("Mid Node Pivot", 50, 0);
  // private final MechanismLigament2d midNode = midNodePivot.append(new MechanismLigament2d("Mid Node", 13, 90,30.0,new Color8Bit(Color.kWhite)));

  public static final MechanismRoot2d highNodePivot = m_mech2d.getRoot("High Node Pivot", 55, 0);
  private static final MechanismLigament2d highNode =
      highNodePivot.append(new MechanismLigament2d("High Node", 25, 90, 30.0, new Color8Bit(Color.kWhite)));
}
package frc.robot.subsystems.drive.gyro;

import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.wpilibj.SPI;

public class Gyro extends AHRS implements GyroIO {
  private boolean isCounterClockwise;

  public Gyro(SPI.Port port) {
    this(port, false);
  }

  public Gyro(SPI.Port port, boolean isCounterClockwise) {
    super(port);
    this.isCounterClockwise = isCounterClockwise;
  }

  public void setCounterClockwise(boolean isInverted) {
    this.isCounterClockwise = isInverted;
  }

  @Override
  public Rotation2d getRotation2d() {
    double direction = isCounterClockwise ? 1 : -1;//This one is different because getRotation2d already negates getAngle()!!!!
    return new Rotation2d(direction * super.getRotation2d().getRadians());
  }

  public void setRotation2d(Rotation2d newRotation2d) {
    double direction = isCounterClockwise ? -1 : 1;
    double newAngle = newRotation2d.getDegrees() * direction;
    super.zeroYaw();
    super.setAngleAdjustment(newAngle);
  }

  @Override
  public double getRate() {
    double direction = isCounterClockwise ? -1 : 1;
    return direction * super.getRate();
  }

  public void updateInputs(GyroIOInputs inputs) {
    inputs.angleRadians = getRotation2d().getRadians();
    inputs.angleRate = getRate();
    inputs.pitchDegrees = getPitch();
    inputs.rollDegrees = getRoll();
    inputs.linearAccelY = getWorldLinearAccelY();
    inputs.linearVelY = getVelocityY();
    inputs.linearVelZ = getVelocityZ();
    inputs.linearAccelZ = getWorldLinearAccelZ();
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.subsystems.drive.gyro;

import org.littletonrobotics.junction.AutoLog;
import edu.wpi.first.math.geometry.Rotation2d;

/** Add your docs here. */
public interface GyroIO {

  @AutoLog
  public class GyroIOInputs {
    public double angleRadians;
    public double angleRate;
    public double pitchDegrees;
    public double rollDegrees;
    public double linearAccelY;
    public double linearVelY;
    public double linearAccelZ;
    public double linearVelZ;
  }

  public default void setRotation2d(Rotation2d newRotation2d) {};

  public default void setRate(double omegaRadiansPerSecond) {};

  public default void zeroYaw() {};

  public default void updateInputs(GyroIOInputs inputs) {};
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.subsystems.drive.gyro;

import edu.wpi.first.math.StateSpaceUtil;
import edu.wpi.first.math.VecBuilder;
import edu.wpi.first.math.geometry.Rotation2d;

/** Add your docs here. */
public class GyroSim implements GyroIO {
  private Rotation2d rot;
  private double rate;

  public GyroSim() {
    this.rot = new Rotation2d();
  }

  public Rotation2d getRotation2d() {
    return rot;
  }

  public void setRotation2d(Rotation2d newRotation2d) {
    rot = newRotation2d;
  }

  public double getRate() {
    return this.rate;
  }

  public void setRate(double omegaRadiansPerSecond) {
    this.rate = omegaRadiansPerSecond;
  };


  public void zeroYaw() {
    rot = new Rotation2d();
  }

  public void updateInputs(GyroIOInputs inputs) {
    var noise = StateSpaceUtil.makeWhiteNoiseVector(VecBuilder.fill(0.01)).get(0, 0);
    noise = 0;
    var delta = (getRate() + noise) * 0.02;
    this.rot = new Rotation2d(this.rot.getRadians() + delta);
    inputs.angleRadians = this.rot.getRadians();
    inputs.angleRate = rate;
  }
}
package frc.robot.subsystems.drive.motors;

import com.revrobotics.CANSparkMax;
import com.revrobotics.SparkMaxAbsoluteEncoder;
import com.revrobotics.SparkMaxPIDController;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.CANSparkMaxLowLevel.PeriodicFrame;
import com.revrobotics.SparkMaxAbsoluteEncoder.Type;

import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import frc.robot.Constants.DRIVE;
import frc.robot.util.SendableSparkMaxPID;

public class Neo550Steer {

  private CANSparkMax max;
  private SparkMaxPIDController pid;
  private SendableSparkMaxPID sPid;
  private SparkMaxAbsoluteEncoder encoder;
  private String path;

  @SuppressWarnings("unused")
  private double dutyCycleOffset;
  private Rotation2d setpoint = new Rotation2d();

  public Neo550Steer(int id, double dutyCycleOffset, String path) {
    this.dutyCycleOffset = dutyCycleOffset;
    this.path = path;
    max = new CANSparkMax(id, MotorType.kBrushless);
    pid = max.getPIDController();
    sPid = new SendableSparkMaxPID(pid);
    encoder = max.getAbsoluteEncoder(Type.kDutyCycle);
    configure();
  }

  private void configure() {
    max.restoreFactoryDefaults();
    max.setSmartCurrentLimit(DRIVE.STEER_CURRENT_LIMIT);
    max.setIdleMode(IdleMode.kBrake);

    encoder.setPositionConversionFactor(DRIVE.STEER_POS_FACTOR);
    encoder.setVelocityConversionFactor(DRIVE.STEER_VEL_FACTOR);

    // MaxSwerve steering encoder is inverted
    encoder.setInverted(true);

    pid.setFeedbackDevice(encoder);

    sPid.setP(DRIVE.STEER_PIDF[0]);
    sPid.setI(DRIVE.STEER_PIDF[1]);
    sPid.setD(DRIVE.STEER_PIDF[2]);
    sPid.setFF(DRIVE.STEER_PIDF[3]);

    SmartDashboard.putData(path + "/SteerPid", sPid);

    /* Probably the default */
    pid.setOutputRange(-1, 1);

    /* No need for angleMod360 with this */
    pid.setPositionPIDWrappingEnabled(true);
    pid.setPositionPIDWrappingMinInput(-Math.PI);
    /* I guess the rationale behind reusing pos factor instead of just putting 2pi here is that this lets us switch to degrees with only 1 change to the factors */
    pid.setPositionPIDWrappingMaxInput(Math.PI);

    /* Set periodic status intervals */

    /* Status 0 governs applied output, faults, and whether is a follower. We don't care about that super much, so we increase it */
    max.setPeriodicFramePeriod(PeriodicFrame.kStatus0, 20);
    /* We don't care about our motor position, only what the encoder reads */
    max.setPeriodicFramePeriod(PeriodicFrame.kStatus2, 500);
    /* Don't have an analog sensor */
    max.setPeriodicFramePeriod(PeriodicFrame.kStatus3, 500);
    /* Don't have an alternate encoder */
    max.setPeriodicFramePeriod(PeriodicFrame.kStatus4, 500);
    /* We -really- care about our duty cycle encoder readings though. THE DEFAULT WAS 200MS */
    max.setPeriodicFramePeriod(PeriodicFrame.kStatus5, 20);
    max.setPeriodicFramePeriod(PeriodicFrame.kStatus6, 20);

    try {
      Thread.sleep((long) 40.0);
    } catch (Exception e) {
      e.printStackTrace();
    } ;
  }

  public void setAngle(Rotation2d angle) {
    setpoint = angle;
    pid.setReference(angle.getRadians(), CANSparkMax.ControlType.kPosition);
  }

  public Rotation2d getAngle() {
    return Rotation2d.fromRadians(encoder.getPosition());
  }

  public Rotation2d getAngleSetpoint() {
    return setpoint;
  }

  public double getVelocity() {
    return encoder.getVelocity();
  }

  public double getAppliedVolts() {
    return max.getAppliedOutput() * max.getBusVoltage();
  }

  public void updatePIDConstants(double P, double I, double D, double F) {
    pid.setP(P);
    pid.setI(I);
    pid.setD(D);
    pid.setFF(F);
  }
}
package frc.robot.subsystems.drive.motors;

import com.revrobotics.CANSparkMax;
import com.revrobotics.RelativeEncoder;
import com.revrobotics.SparkMaxPIDController;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import com.revrobotics.CANSparkMaxLowLevel.PeriodicFrame;

import frc.robot.Constants.DRIVE;
import frc.robot.util.SendableSparkMaxPID;

public class NeoDrive {
  private CANSparkMax max;
  private RelativeEncoder encoder;
  private SparkMaxPIDController pid;
  private SendableSparkMaxPID sPid;

  private double setpoint;

  public NeoDrive(int id) {
    max = new CANSparkMax(id, MotorType.kBrushless);
    encoder = max.getEncoder();
    pid = max.getPIDController();
    sPid = new SendableSparkMaxPID(pid);
    configure();
  }

  private void configure() {
    max.restoreFactoryDefaults();
    max.setSmartCurrentLimit(DRIVE.DRIVE_CURRENT_LIMIT);
    max.setIdleMode(IdleMode.kBrake);

    encoder.setPositionConversionFactor(DRIVE.DRIVE_POS_FACTOR);
    encoder.setVelocityConversionFactor(DRIVE.DRIVE_VEL_FACTOR);

    // TODO: 1) check if this is too noisy 2) check if this impacts other robot code that deals with encoder velocities
    encoder.setMeasurementPeriod(10);

    pid.setFeedbackDevice(encoder);

    sPid.setP(DRIVE.DRIVE_PIDF[0]);
    sPid.setI(DRIVE.DRIVE_PIDF[1]);
    sPid.setD(DRIVE.DRIVE_PIDF[2]);
    sPid.setFF(DRIVE.DRIVE_PIDF[3]);

    // Probably the default
    pid.setOutputRange(-1, 1);

    /* Set periodic frame periods */

    /* Send our velocity more frequently */
    max.setPeriodicFramePeriod(PeriodicFrame.kStatus1, 10);
    /* Don't have an analog encoder */
    max.setPeriodicFramePeriod(PeriodicFrame.kStatus3, 500);
    /* Don't have an alternate encoder */
    max.setPeriodicFramePeriod(PeriodicFrame.kStatus4, 500);
    /* Don't have a duty cycle encoder */
    max.setPeriodicFramePeriod(PeriodicFrame.kStatus5, 500);
    max.setPeriodicFramePeriod(PeriodicFrame.kStatus6, 500);

    try {
      Thread.sleep((long) 40.0);
    } catch (Exception e) {
      e.printStackTrace();
    } ;
  }

  public void setSpeed(double speed) {
    setpoint = speed;
    pid.setReference(speed, CANSparkMax.ControlType.kVelocity);
  }

  /* Please work */
  public void setVoltage(double volts) {
    SmartDashboard.putNumber("Swerve/ManualVolts", volts);
    // pid.setReference(volts, CANSparkMax.ControlType.kVoltage);
    max.setVoltage(volts);
  }

  public void zeroEncoders() {
    encoder.setPosition(0);
  }

  public double getVelocitySetpoint() {
    return setpoint;
  }

  public double getPosition() {
    return encoder.getPosition();
  }

  public double getVelocity() {
    return encoder.getVelocity();
  }

  public double getAppliedVolts() {
    return max.getAppliedOutput() * max.getBusVoltage();
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.subsystems.drive;

import java.util.ArrayList;

import org.littletonrobotics.junction.Logger;

import com.pathplanner.lib.PathConstraints;
import com.pathplanner.lib.PathPlanner;
import com.pathplanner.lib.PathPlannerTrajectory;
import com.pathplanner.lib.PathPoint;
import com.pathplanner.lib.commands.PPSwerveControllerCommand;
import edu.wpi.first.math.Matrix;
import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.estimator.SwerveDrivePoseEstimator;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.kinematics.SwerveDriveKinematics;
import edu.wpi.first.math.kinematics.SwerveDriveOdometry;
import edu.wpi.first.math.kinematics.SwerveModulePosition;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import edu.wpi.first.math.numbers.N1;
import edu.wpi.first.math.numbers.N3;
import edu.wpi.first.math.trajectory.Trajectory;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.smartdashboard.Field2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import frc.robot.Constants.DRIVE;
import frc.robot.Constants.AUTON;
import frc.robot.subsystems.drive.gyro.GyroIO;
import frc.robot.subsystems.drive.gyro.GyroIOInputsAutoLogged;

public class Swerve extends SubsystemBase {

  Translation2d[] modulePositions = {DRIVE.FL_POS, DRIVE.FR_POS, DRIVE.RL_POS, DRIVE.RR_POS};
  public final SwerveDriveKinematics kinematics = new SwerveDriveKinematics(modulePositions);
  public SwerveModuleIO[] modules;
  public SwerveModuleInputsAutoLogged[] lastInputs;
  public GyroIOInputsAutoLogged lastGyroInputs;
  public GyroIO gyro;
  SwerveDrivePoseEstimator odometry;
  /* Regular odometry object so we can compare vision-aided odometry with regular odometry in telemetry */
  SwerveDriveOdometry wheelOdometry;
  Field2d field = new Field2d();
  Runnable resetBuffer = () -> {
  };
  private Rotation2d gyroOffset;

  /** Creates a new SwerveSubsystem. */
  public Swerve(GyroIO gyro, SwerveModuleIO... modules) {
    this.gyro = gyro;

    this.modules = modules;
    /* Get module states to pass to odometry */
    updateInputs();

    this.odometry = new SwerveDrivePoseEstimator(kinematics, getCtsGyroRot(), getModulePositions(), new Pose2d());
    this.wheelOdometry = new SwerveDriveOdometry(kinematics, getCtsGyroRot(), getModulePositions());
    zeroEncoders();

    /* Initialize SmartDashboard values */
    SmartDashboard.putBoolean("Swerve/DesaturateWheelSpeeds", false);

    SmartDashboard.putData("Swerve/swerve field", field);

    SmartDashboard.putData("Swerve/xPid", AUTON.X_PID);
    SmartDashboard.putData("Swerve/yPid", AUTON.Y_PID);
    SmartDashboard.putData("Swerve/rotPid", AUTON.ROT_PID);
  }

  @Override
  public void periodic() {
    updateInputs();
    odometry.update(getCtsGyroRot(), getPositionsFromInputs(lastInputs));
    wheelOdometry.update(getCtsGyroRot(), getPositionsFromInputs(lastInputs));
    log();
  }

  public void log() {
    field.setRobotPose(getPose());
    field.getObject("Wheels").setPose(wheelOdometry.getPoseMeters());

    Logger.getInstance().recordOutput("Swerve/Field/Robot", getPose());
    Logger.getInstance().recordOutput("Swerve/Field/Wheels", wheelOdometry.getPoseMeters());
    Logger.getInstance().recordOutput("Swerve/Field/Vision", field.getObject("Vision").getPose());

    var speeds = getChassisSpeeds();
    Logger.getInstance().recordOutput("Swerve/ChassisSpeeds/Vx", speeds.vxMetersPerSecond);
    Logger.getInstance().recordOutput("Swerve/ChassisSpeeds/Vy", speeds.vyMetersPerSecond);
    Logger.getInstance().recordOutput("Swerve/ChassisSpeeds/Rot", speeds.omegaRadiansPerSecond);

    var states = getStatesFromInputs(lastInputs);
    Logger.getInstance().recordOutput("Swerve/CurrentModuleStates", states);

    var commandName = this.getCurrentCommand() == null ? "None" : this.getCurrentCommand().getName();
    Logger.getInstance().recordOutput("Swerve/Current Command", commandName);
  }

  public void simulationPeriodic() {
    /* Sim replay is in sim but this doesn't apply to that */
    if (Constants.getMode() != Constants.RobotMode.SIM)
      return;

    ChassisSpeeds chassisSpeeds = getChassisSpeeds();
    gyro.setRate(chassisSpeeds.omegaRadiansPerSecond);
  }

  /* Teleop-Drive Related Methods */
  /**
   * Sets all swerve modules to have the specified velocities and angles
   * 
   * @param states
   */
  public void setStates(SwerveModuleState[] states) {
    Logger.getInstance().recordOutput("Swerve/TargetModuleStates", states);
    for (int i = 0; i < states.length; i++) {
      modules[i].setState(states[i]);
    }
  }

  /**
   * Drives the robot at the specified speeds
   * 
   * @param speeds Speeds to go
   */
  public void drive(ChassisSpeeds speeds) {
    Logger.getInstance().recordOutput("Swerve/DesiredSpeeds/Vx", speeds.vxMetersPerSecond);
    Logger.getInstance().recordOutput("Swerve/DesiredSpeeds/Vy", speeds.vyMetersPerSecond);
    Logger.getInstance().recordOutput("Swerve/DesiredSpeeds/Rot", speeds.omegaRadiansPerSecond);
    var states = kinematics.toSwerveModuleStates(speeds);
    if (SmartDashboard.getBoolean("Swerve/DesaturateWheelSpeeds", true)) {
      SwerveDriveKinematics.desaturateWheelSpeeds(states, getChassisSpeeds(), DRIVE.MAX_MODULE_SPEED,
          DRIVE.MAX_TRANSLATIONAL_SPEED, DRIVE.MAX_ROTATIONAL_SPEED);
    }
    setStates(states);
  }

  /* Odometry Related Methods */
  /**
   * Zeros all encoders to be at the default pose (0x, 0y, 0deg)
   */
  public void zeroEncoders() {
    gyro.zeroYaw();
    for (int i = 0; i < modules.length; i++) {
      modules[i].zeroEncoders();
    }
    // Needed to update lastInputs to be accurate
    updateInputs();
    setPose(new Pose2d());
  }

  /**
   * Gets current odometry pose
   * 
   * @return Current robot pose, as reported by odometry
   */
  public Pose2d getPose() {
    return odometry.getEstimatedPosition();
  }

  /**
   * Resets the odometry pose to the given position
   * 
   * @param pose Position robot is at
   */
  public void setPose(Pose2d pose) {
    this.gyroOffset = pose.getRotation().minus(getCtsGyroRot());
    odometry.resetPosition(getCtsGyroRot(), getPositionsFromInputs(lastInputs), pose);
    wheelOdometry.resetPosition(getCtsGyroRot(), getPositionsFromInputs(lastInputs), pose);
    resetBuffer.run();
  }

  public void fuseVisionEstimate(Pose2d visionRobotPos, double timestamp) {
    odometry.addVisionMeasurement(visionRobotPos, timestamp);
    field.getObject("Vision").setPose(visionRobotPos);
  }

  public void fuseVisionEstimate(Pose2d visionRobotPos, double timestamp, Matrix<N3, N1> stDevs) {
    odometry.addVisionMeasurement(visionRobotPos, timestamp, stDevs);
    field.getObject("Vision").setPose(visionRobotPos);
  }

  /* Auton Related Methods */
  /**
   * Generates a command that will follow a given trajectory
   * 
   * @param traj The trajectory to follow
   * @param isFirstPath Reset odometry to starting position if first path
   * @param stopWhenDone Append a command to stop the robot if done
   * @return
   */
  public Command followTrajectoryCommand(PathPlannerTrajectory traj, boolean isFirstPath, boolean stopWhenDone) {
    return new SequentialCommandGroup(new InstantCommand(() -> {
      var innerTraj = traj;
      // Reset odometry for the first path you run during auto
      if (isFirstPath) {
        Pose2d initPose = traj.getInitialHolonomicPose();
        if (DriverStation.getAlliance() == DriverStation.Alliance.Red) {
          // Create a new state so that we don't overwrite the original
          Translation2d newTranslation =
              new Translation2d(initPose.getX(), Constants.FIELD_CONSTANTS.WIDTH - initPose.getY());
          Rotation2d newHeading = initPose.getRotation().times(-1);
          initPose = new Pose2d(newTranslation, newHeading);
        }
        this.setPose(initPose);
        innerTraj = PathPlannerTrajectory.transformTrajectoryForAlliance(traj, DriverStation.getAlliance());
      }

      // field.getObject("CurrentTrajectory").setTrajectory(innerTraj);
      Logger.getInstance().recordOutput("Swerve/Field/CurrentTrajectory", innerTraj);
    }), new PPSwerveControllerCommand(traj, this::getPose, // Pose supplier
        this.kinematics, // SwerveDriveKinematicsSS
        (PIDController) SmartDashboard.getData("Swerve/xPid"), // X controller. Tune these values for your robot. Leaving them 0 will only use feedforwards.
        (PIDController) SmartDashboard.getData("Swerve/yPid"), // Y controller (usually the same values as X controller)
        (PIDController) SmartDashboard.getData("Swerve/rotPid"), // Rotation controller. Tune these values for your robot. Leaving them 0 will only use feedforwards.
        this::setStates, // Module states consumer
        true, this // Requires this drive subsystem
    ), new InstantCommand(() -> {
      if (stopWhenDone) {
        drive(new ChassisSpeeds(0, 0, 0));
      }
      // field.getObject("CurrentTrajectory").setTrajectory(new Trajectory());
      Logger.getInstance().recordOutput("Swerve/Field/CurrentTrajectory", new Trajectory());
    }));
  }

  /**
   * Generates a command that will follow a given trajectory
   * 
   * @param traj The trajectory to follow
   * @param isFirstPath Reset odometry to starting position if first path
   * @param stopWhenDone Append a command to stop the robot if done
   * @return
   */
  public Command silentFollowTrajectoryCommand(PathPlannerTrajectory traj, boolean isFirstPath, boolean stopWhenDone) {
    return new SequentialCommandGroup(new InstantCommand(() -> {
      // Reset odometry for the first path you run during auto
      if (isFirstPath) {
        Pose2d initPose = traj.getInitialHolonomicPose();
        if (DriverStation.getAlliance() == DriverStation.Alliance.Red) {
          // Create a new state so that we don't overwrite the original
          Translation2d newTranslation =
              new Translation2d(initPose.getX(), Constants.FIELD_CONSTANTS.WIDTH - initPose.getY());
          Rotation2d newHeading = initPose.getRotation().times(-1);
          initPose = new Pose2d(newTranslation, newHeading);
        }
        this.setPose(initPose);
        var allianceTraj = PathPlannerTrajectory.transformTrajectoryForAlliance(traj, DriverStation.getAlliance());
        field.getObject("CurrentTrajectory").setTrajectory(allianceTraj);
        Logger.getInstance().recordOutput("Swerve/Field/CurrentTrajectory", allianceTraj);
      }
    }), new PPSwerveControllerCommand(traj, this::getPose, // Pose supplier
        this.kinematics, // SwerveDriveKinematicsSS
        (PIDController) SmartDashboard.getData("Swerve/xPid"), // X controller. Tune these values for your robot. Leaving them 0 will only use feedforwards.
        (PIDController) SmartDashboard.getData("Swerve/yPid"), // Y controller (usually the same values as X controller)
        (PIDController) SmartDashboard.getData("Swerve/rotPid"), // Rotation controller. Tune these values for your robot. Leaving them 0 will only use feedforwards.
        this::setStates, // Module states consumer
        true // Requires this drive subsystem
    ), new InstantCommand(() -> {
      if (stopWhenDone) {
        drive(new ChassisSpeeds(0, 0, 0));
      }
      field.getObject("CurrentTrajectory").setTrajectory(new Trajectory());
      Logger.getInstance().recordOutput("Swerve/Field/CurrentTrajectory", new Trajectory());
    }));
  }


  /**
   * Follows an ArrayList of trajectories
   * 
   * @param trajectories List of trajectories to follow
   * @param stopWhenDone [unimplemented] stop when done following all trajectories
   * @return
   */
  public Command followTrajectoriesCommand(ArrayList<PathPlannerTrajectory> trajectories, boolean stopWhenDone) {
    Command fullCommand = new InstantCommand();
    boolean isFirstTrajectory = true;
    for (PathPlannerTrajectory trajectory : trajectories) {
      fullCommand = fullCommand.andThen(followTrajectoryCommand(trajectory, isFirstTrajectory, false));
      isFirstTrajectory = false;
    }
    return fullCommand;
  }

  public Command followTrajectoriesCommand(ArrayList<PathPlannerTrajectory> trajectories, boolean resetPose,
      boolean stopWhenDone) {
    Command fullCommand = new InstantCommand();
    boolean isFirstTrajectory = resetPose;
    for (PathPlannerTrajectory trajectory : trajectories) {
      fullCommand = fullCommand.andThen(followTrajectoryCommand(trajectory, isFirstTrajectory, false));
      isFirstTrajectory = false;
    }
    return fullCommand;
  }

  public Command goTo(Pose2d endPose, PathConstraints constraints) {
    Pose2d startPose = getPose();
    Rotation2d startHeading = endPose.getTranslation().minus(startPose.getTranslation()).getAngle();
    Rotation2d endHeading = startHeading;
    // .rotateBy(Rotation2d.fromDegrees(180));

    PathPoint startPoint = new PathPoint(startPose.getTranslation(), startHeading, startPose.getRotation());// position, heading(direction of travel), holonomic rotation
    PathPoint endPoint = new PathPoint(endPose.getTranslation(), endHeading, endPose.getRotation());
    PathPlannerTrajectory traj = PathPlanner.generatePath(constraints, startPoint, endPoint);
    return followTrajectoryCommand(traj, false, true);
  }

  /* Telemetry (Advantage Kit) Related Methods (also used in odometry) */
  private void updateInputs() {
    /* Get inputs for each swerve module */
    SwerveModuleInputsAutoLogged[] inputs = new SwerveModuleInputsAutoLogged[modules.length];
    for (int i = 0; i < modules.length; i++) {
      inputs[i] = new SwerveModuleInputsAutoLogged();
      modules[i].updateInputs(inputs[i]);
      Logger.getInstance().processInputs(modules[i].getPath(), inputs[i]);
    }
    lastInputs = inputs;

    GyroIOInputsAutoLogged gyroInputs = new GyroIOInputsAutoLogged();
    gyro.updateInputs(gyroInputs);
    Logger.getInstance().processInputs("Gyro", gyroInputs);
    lastGyroInputs = gyroInputs;
  }

  /**
   * Return SwerveModulePositions for all SwerveModuleInputs
   * 
   * @param inputs SwerveModuleInputs containing velocities and angles
   * @return SwerveModulePositions containing velocities and angles
   */
  public SwerveModulePosition[] getPositionsFromInputs(SwerveModuleInputsAutoLogged[] inputs) {
    SwerveModulePosition states[] = new SwerveModulePosition[inputs.length];
    for (int i = 0; i < inputs.length; i++) {
      states[i] = new SwerveModulePosition(inputs[i].drivePosition, Rotation2d.fromRadians(inputs[i].steerAngle));
    }
    return states;
  }

  /**
   * Return SwerveModuleStates for all SwerveModuleInputs
   * 
   * @param inputs SwerveModuleInputs containing velocities and angles
   * @return SwerveModuleStates containing velocities and angles
   */
  public SwerveModuleState[] getStatesFromInputs(SwerveModuleInputsAutoLogged[] inputs) {
    SwerveModuleState states[] = new SwerveModuleState[inputs.length];
    for (int i = 0; i < inputs.length; i++) {
      states[i] = new SwerveModuleState(inputs[i].driveVelocity, Rotation2d.fromRadians(inputs[i].steerAngle));
    }
    return states;
  }

  public ChassisSpeeds getChassisSpeeds() {
    var states = getStatesFromInputs(lastInputs);
    return kinematics.toChassisSpeeds(states);
  }

  /**
   * Drives, but field relative. +X is away from the driver station.
   * 
   * @param speeds Speeds to go in each axis, field relative
   */
  public void driveFieldRelative(ChassisSpeeds speeds) {
    var robotOrientedSpeeds = ChassisSpeeds.fromFieldRelativeSpeeds(speeds.vxMetersPerSecond, speeds.vyMetersPerSecond,
        speeds.omegaRadiansPerSecond, getPose().getRotation());
    drive(robotOrientedSpeeds);
  }

  /* Sets all modules into an X formation (and stops driving) */
  public void setX() {
    // for(var module: modules) {
    //   module.setState(new SwerveModuleState());
    // }
    // modules[0].setAngle(Rotation2d.fromDegrees(45));
    // modules[1].setAngle(Rotation2d.fromDegrees(-45));
    // modules[2].setAngle(Rotation2d.fromDegrees(-45));
    // modules[3].setAngle(Rotation2d.fromDegrees(45));

    setStates(new SwerveModuleState[] {
        // FL
        new SwerveModuleState(0, Rotation2d.fromDegrees(45)),
        // FR
        new SwerveModuleState(0, Rotation2d.fromDegrees(-45)),
        // RL
        new SwerveModuleState(0, Rotation2d.fromDegrees(-45)),
        // RR
        new SwerveModuleState(0, Rotation2d.fromDegrees(45))});
  }

  /* SysId Related Methods  */
  /* Sets volts in a way that makes it drive like a differential drive */
  public void setVolts(double leftVolts, double rightVolts) {
    rightVolts *= -1;
    for (int i = 0; i < modules.length; i++) {
      // If i is divisible by 2, it is on the left (because order is FL, FR, RL, RR). 0 is divisible by 2 in this implementation.
      if (i % 2 == 0) {
        modules[i].setVoltage(leftVolts);
      } else {
        modules[i].setVoltage(rightVolts);
      }
    }
  }

  /* Gets drive motor voltages in a way that would make sense for a differential drive */
  public double[] getDiffVoltages() {
    return new double[] {lastInputs[0].driveAppliedVolts, -lastInputs[1].driveAppliedVolts};
  }

  /* Gets drive motor positions in a way that would make sense for a differential drive */
  public double[] getDiffPositions() {
    return new double[] {lastInputs[0].drivePosition, -lastInputs[1].drivePosition};
  }

  /* Gets drive motor velocities in a way that would make sense for a differential drive */
  public double[] getDiffVelocities() {
    return new double[] {lastInputs[0].driveVelocity, -lastInputs[1].driveVelocity};
  }

  public Rotation2d getCtsGyroRot() {
    return new Rotation2d(lastGyroInputs.angleRadians);
  }

  public Rotation2d getCtsGyroRotWithOffset() {
    return new Rotation2d(getCtsGyroRot().getRadians() + gyroOffset.getRadians());
  }

  /* Returns Z axis rotation speed in degrees per second */
  public double getAngularVel() {
    return lastGyroInputs.angleRate;
  }

  /* Returns Z axis rotation speed in radians per second */
  public double getAngularVelRad() {
    return getAngularVel();
  }


  public double getPitch() {
    return lastGyroInputs.pitchDegrees;
  }

  public double getRoll() {
    return lastGyroInputs.rollDegrees;
  }

  /**
   * Sets steer pid constants for all modules
   * 
   * @param kF F(eedforward) value
   * @param kP P(roportional) PID value
   * @param kI I(ntegral) PID value
   * @param kD D(erivitive) PID value
   */
  public void setPIDConstants(double kF, double kP, double kI, double kD) {
    for (int i = 0; i < modules.length; i++) {
      modules[i].setPIDConstants(kF, kP, kI, kD);
    }
  }

  public SwerveModulePosition[] getModulePositions() {
    return getPositionsFromInputs(lastInputs);
  }

  public Pose2d getWheelPose() {
    return wheelOdometry.getPoseMeters();
  }

  public void setResetBuffer(Runnable resetBuffer) {
    this.resetBuffer = resetBuffer;
  }
}
package frc.robot.subsystems.drive;

import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import frc.robot.subsystems.drive.motors.Neo550Steer;
import frc.robot.subsystems.drive.motors.NeoDrive;

public class SwerveModule implements SwerveModuleIO {

  protected NeoDrive drive;
  protected Neo550Steer steer;

  protected Rotation2d angleOffset;

  private int id;
  private String description;

  public SwerveModule(int id, int driveId, int steerId, double[] offsets, String description) {
    this.id = id;
    this.description = description;
    this.angleOffset = Rotation2d.fromDegrees(offsets[0]);
    drive = new NeoDrive(driveId);
    steer = new Neo550Steer(steerId, offsets[1], getPath());
  }

  @Override
  public void zeroEncoders() {
    drive.zeroEncoders();
  }

  private Rotation2d getAngle() {
    return steer.getAngle().minus(angleOffset);
  }

  /* Directly sets module angle */
  @Override
  public void setAngle(Rotation2d newAngle) {
    steer.setAngle(newAngle.plus(angleOffset));
  }

  /* Directly sets drive motor volts, ignoring pid */
  @Override
  public void setVoltage(double volts) {
    drive.setVoltage(volts);
  }

  @Override
  public void setState(SwerveModuleState state) {
    // create deepcopy so subsequent mutations are not percieved by SwerveKinematics
    state = new SwerveModuleState(state.speedMetersPerSecond, state.angle);

    /* We do offsetting before optimization so the wheel automatically gets reversed when the module is facing backwards. Downside: the robot will not work without optimizations enabled. */
    state.angle = state.angle.plus(angleOffset);
    state = SwerveModuleState.optimize(state, steer.getAngle());

    steer.setAngle(state.angle);
    drive.setSpeed(state.speedMetersPerSecond);
  }

  public void updateSteerPIDConstants(double kP, double kI, double kD, double kF) {
    steer.updatePIDConstants(kP, kI, kD, kF);
  }

  /* Called every periodic() */
  @Override
  public void updateInputs(SwerveModuleInputs inputs) {
    inputs.description = this.description;

    inputs.driveAppliedVolts = drive.getAppliedVolts();
    inputs.drivePosition = drive.getPosition();
    inputs.driveVelocity = drive.getVelocity();
    inputs.driveVelocitySetpoint = drive.getVelocitySetpoint();

    inputs.steerAppliedVolts = steer.getAppliedVolts();
    inputs.steerAngle = getAngle().getRadians();
    inputs.steerVelocity = steer.getVelocity();
    inputs.steerAngleSetpoint = steer.getAngleSetpoint().getRadians();
  }

  @Override
  public String getDescription() {
    return this.description;
  }

  @Override
  public int getId() {
    return this.id;
  }

  @Override
  public String getPath() {
    return "Swerve/Wheel " + id + " (" + description + ")";
  }
}
package frc.robot.subsystems.drive;

import org.littletonrobotics.junction.AutoLog;

import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.kinematics.SwerveModuleState;

public interface SwerveModuleIO {
  @AutoLog
  public static class SwerveModuleInputs {
    public double driveAppliedVolts;
    public double drivePosition;
    public double driveVelocity;
    public double driveVelocitySetpoint;

    public String description;

    public double steerAppliedVolts;
    public double steerVelocity;
    public double steerAngle;
    public double steerAngleSetpoint;
  }

  public default void setState(SwerveModuleState state) {}

  public default void zeroEncoders() {}

  public default void setPIDConstants(double kF, double kP, double kI, double kD) {}

  public default void setAngle(Rotation2d angle) {}

  public default void setVoltage(double volts) {}

  public default void updateInputs(SwerveModuleInputs inputs) {}

  public default String getDescription() {
    return "";
  }

  public default String getPath() {
    return "";
  }

  public default int getId() {
    return 0;
  }
}
package frc.robot.subsystems.drive;

import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.kinematics.SwerveModuleState;

public class SwerveModuleSim extends SwerveModule {

  private double drivePos;
  private double driveVel;
  private Rotation2d angle;

  public SwerveModuleSim(int id, int driveId, int steerId, double[] offsets, String description) {
    super(id, driveId, steerId, offsets, description);
    angle = new Rotation2d();
  }

  /* (non-Javadoc)
   * @see frc.robot.subsystems.drive.SwerveModule#setState(edu.wpi.first.math.kinematics.SwerveModuleState)
   */
  @Override
  public void setState(SwerveModuleState state) {
    super.setState(state);

    state = new SwerveModuleState(state.speedMetersPerSecond, state.angle);

    /* We do offsetting before optimization so the wheel automatically gets reversed when the module is facing backwards. Downside: the robot will not work without optimizations enabled. */
    // state = SwerveModuleState.optimize(state, steer.getAngle());

    this.angle = state.angle;
    this.driveVel = state.speedMetersPerSecond;
    this.drivePos += this.driveVel * 0.02;
  }

  /* Called every periodic() */
  @Override
  public void updateInputs(SwerveModuleInputs inputs) {
    super.updateInputs(inputs);
    inputs.drivePosition = this.drivePos;
    inputs.driveVelocity = this.driveVel;
    inputs.steerAngle = this.angle.getRadians();
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.subsystems;

import org.littletonrobotics.junction.Logger;
import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.PneumaticsModuleType;
import edu.wpi.first.wpilibj.PowerDistribution;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants.GRABBER;

public class Grabber extends SubsystemBase {
  boolean isClosed = true;
  Solenoid closeSolenoid = new Solenoid(PneumaticsModuleType.REVPH, 0);
  Solenoid openSolenoid = new Solenoid(PneumaticsModuleType.REVPH, 1);
  PowerDistribution pdh = new PowerDistribution();
  Compressor compressor = new Compressor(PneumaticsModuleType.REVPH);

  public Grabber() {
    compressor.enableAnalog(GRABBER.MIN_PRESSURE, GRABBER.MAX_PRESSURE);
    close();
  }

  public void close() {
    openSolenoid.set(false);
    closeSolenoid.set(true);
    isClosed = true;
  }

  public void open() {
    closeSolenoid.set(false);
    openSolenoid.set(true);
    isClosed = false;
  }

  public boolean isClosed() {
    return isClosed;
  }

  boolean wasLastEnabled = false;

  @Override
  public void periodic() {
    // This method will be called once per scheduler run
    var enabled = DriverStation.isEnabled();
    if (enabled && !wasLastEnabled) {
      // Turn spinny air pump cooling device on if enabled
      pdh.setSwitchableChannel(true);
    }
    if (!enabled && wasLastEnabled) {
      pdh.setSwitchableChannel(false);
    }

    wasLastEnabled = enabled;
    Logger.getInstance().recordOutput("Grabber/IsClosed", isClosed);
  }
}
package frc.robot.subsystems.leds;


// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

import edu.wpi.first.wpilibj.AddressableLED;
import edu.wpi.first.wpilibj.AddressableLEDBuffer;
import edu.wpi.first.wpilibj.simulation.AddressableLEDSim;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants.LEDS;

public class Leds extends SubsystemBase {
  /** Creates a new LEDS. d */
  private AddressableLED ledStrip;
  private AddressableLEDSim ledSim;

  // one buffer for all the live shit, one for no lights
  public AddressableLEDBuffer buffer;

  // LED States
  public LedState state;
  // Assuming that both strips are the same length - therefore we can use one buffer

  public Leds() {
    buffer = new AddressableLEDBuffer(LEDS.LENGTH);

    ledStrip = new AddressableLED(LEDS.PORT);
    ledStrip.setLength(buffer.getLength());

    ledSim = new AddressableLEDSim(ledStrip);

    state = LedState.GREEN;

    // send voltages to the strips
    startLED();
  }

  public void setState(LedState newState) {
    this.state = newState;
  }

  // method to flush both strips
  public void startLED() {
    ledStrip.start();
  }

  @Override
  public void periodic() {
    this.state.updateBuffer(buffer);
    this.ledStrip.setData(buffer);
  }
}

package frc.robot.subsystems.leds;

import java.util.function.Consumer;
import edu.wpi.first.wpilibj.AddressableLEDBuffer;
import edu.wpi.first.wpilibj.util.Color;

public enum LedState {
  GREEN(Color.kGreen), WHITE(Color.kWhite), ORANGE(Color.kOrange);

  private Consumer<AddressableLEDBuffer> updateBufferLambda;

  public void updateBuffer(AddressableLEDBuffer buffer) {
    this.updateBufferLambda.accept(buffer);
  }

  private LedState(Color color) {
    this((AddressableLEDBuffer buffer) -> {
      for (int i = 0; i < buffer.getLength(); i++) {
        buffer.setLED(i, color);
      }
    });
  }

  private LedState(Consumer<AddressableLEDBuffer> updateBufferLambda) {
    this.updateBufferLambda = updateBufferLambda;
  }
}
package frc.robot.subsystems;

import frc.robot.subsystems.arm.Arm;
import frc.robot.subsystems.drive.Swerve;
import frc.robot.subsystems.wrist.Wrist;
import frc.robot.subsystems.vision.Vision;

/* Container class for all subsystems */
public class Subsystems {
  public Swerve swerve;
  public Wrist wrist;
  public Arm arm;
  public Vision vision;
  public Grabber grabber;

  public Subsystems(Swerve swerve, Wrist wrist, Arm arm, Vision vision, Grabber grabber) {
    this.swerve = swerve;
    this.wrist = wrist;
    this.arm = arm;
    this.vision = vision;
    this.grabber = grabber;
  }

  public Subsystems(Swerve swerve, Wrist wrist, Arm arm, Grabber grabber) {
    this.swerve = swerve;
    this.wrist = wrist;
    this.arm = arm;
    this.vision = null;
    this.grabber = grabber;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.subsystems.vision;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.Map.Entry;
import org.littletonrobotics.junction.Logger;
import org.photonvision.PhotonCamera;
import org.photonvision.targeting.PhotonTrackedTarget;
import org.photonvision.targeting.TargetCorner;
import edu.wpi.first.apriltag.AprilTagFieldLayout;
import edu.wpi.first.apriltag.AprilTagFieldLayout.OriginPosition;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Pose3d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Transform3d;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.smartdashboard.Field2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import frc.robot.subsystems.drive.Swerve;
import frc.robot.util.vision.CustomEstimator.PoseStrategy;
import frc.robot.util.MoreMath;
import frc.robot.util.vision.CustomEstimate;
import frc.robot.util.vision.CustomEstimator;
import frc.robot.util.vision.PoseBufferWrapper;

public class Vision extends SubsystemBase {
  public Swerve swerve;

  public List<CustomEstimator> estimators;
  private Field2d field = new Field2d();

  public List<List<PhotonTrackedTarget>> targetsPerCam;
  public List<Optional<CustomEstimate>> estimates;

  private AprilTagFieldLayout atfl;

  public Vision(Swerve swerve) {
    this.swerve = swerve;

    initAtfl();
    initPoseEstimators();
    initEstimates();
    initBuffer();
    initField();
  }

  private void initBuffer() {
    PoseBufferWrapper.createBuffers(swerve::getPose, swerve::getWheelPose, swerve::getModulePositions,
        swerve::getCtsGyroRotWithOffset, swerve.kinematics, swerve::setResetBuffer);
  }

  public void periodic() {
    updateAtflOrigin();
    updateEstimates();
    logTagPoses();
  }

  /* I hate null pointer exceptions */
  public void initEstimates() {
    this.targetsPerCam = new ArrayList<>(Collections.nCopies(estimators.size(), new ArrayList<PhotonTrackedTarget>()));
    this.estimates = new ArrayList<>(Collections.nCopies(estimators.size(), Optional.empty()));
  }

  private void initField() {
    SmartDashboard.putData("vision/vision field", field);
    field.setRobotPose(new Pose2d(-100, -100, new Rotation2d()));
  }

  /**
   * 
   */
  public void updateAtflOrigin() {
    // Set AprilTagFieldLayout Alliance Color
    if (DriverStation.getAlliance() == DriverStation.Alliance.Blue) {
      this.atfl.setOrigin(OriginPosition.kBlueAllianceWallRightSide);
    } else {
      this.atfl.setOrigin(OriginPosition.kRedAllianceWallRightSide);
    }
  }

  public AprilTagFieldLayout getAtfl() {
    return atfl;
  }

  public void updateEstimates() {
    estimates.clear();
    targetsPerCam.clear();

    /* For some reason cam in PhotonPoseEstimator is not visible */
    for (var i = 0; i < estimators.size(); i++) {
      var poseEstimator = estimators.get(i);
      var cam = (PhotonCamera) Constants.VISION.CAMS_AND_TRANS.keySet().toArray()[i];

      var targets = cam.getLatestResult().getTargets();
      targetsPerCam.add(targets);

      var estimate = poseEstimator.update();
      estimates.add(estimate);
    }
  }

  public static boolean isEstimatePresent(Optional<CustomEstimate> estimate) {
    return estimate.isPresent() && estimate.get().best != null && estimate.get().best.getRotation() != null;
  }

  private void initAtfl() {
    try {
      this.atfl = Constants.VISION.SHOP_ATFL;
      // this.atfl = AprilTagFieldLayout.loadFromResource(AprilTagFields.kDefaultField.m_resourceFile);
    } catch (Exception e) {//I really wish we could be doing this in constants.java, not here lol (if you can fix this, plz do)
      DriverStation.reportError("Welp, if ur reading this, imma guess ur getting a nullpointer exception.", true);
    }
  }

  private void initPoseEstimators() {
    estimators = new ArrayList<>();
    for (var camAndTransform : Constants.VISION.CAMS_AND_TRANS.entrySet()) {
      estimators.add(
          new CustomEstimator(atfl, PoseStrategy.MIN_AMBIGUITY, camAndTransform.getKey(), camAndTransform.getValue()));
    }
  }

  public void logTagPoses() {
    /* Loop through estimators/cams */
    for (var i = 0; i < estimators.size(); i++) {
      //create camera and transform variables to ease access
      var camAndTrans = (Entry<PhotonCamera, Transform3d>) Constants.VISION.CAMS_AND_TRANS.entrySet().toArray()[i];
      var cam = camAndTrans.getKey();
      var robot2Cam = camAndTrans.getValue();

      //prepare arrays
      var tagIds = new ArrayList<Integer>();
      var tagCorners = new ArrayList<TargetCorner>();
      var fieldToTags = new ArrayList<Pose3d>();
      var fieldToRobots = new ArrayList<Pose3d>();
      var fieldToCams = new ArrayList<Pose3d>();
      var camToTags = new ArrayList<Transform3d>();

      /* Loop through targets */
      for (var target : cam.getLatestResult().getTargets()) {
        var id = target.getFiducialId();
        tagIds.add(id);

        var tagPoseOpt = atfl.getTagPose(id);
        if (tagPoseOpt.isEmpty()) {
          fieldToTags.add(new Pose3d());
          fieldToRobots.add(new Pose3d());
          camToTags.add(new Transform3d());
          tagCorners.addAll(Collections.emptyList());
          continue;
        }

        var fieldToTag = tagPoseOpt.get();
        var fieldToRobot =
            fieldToTag.transformBy(target.getBestCameraToTarget().inverse()).transformBy(robot2Cam.inverse());
        var fieldToCam = fieldToTag.transformBy(target.getBestCameraToTarget().inverse());

        var corners = target.getDetectedCorners(); // actually 4, but who cares about understandable variable naming lol

        fieldToCams.add(fieldToCam);
        fieldToTags.add(fieldToTag);
        fieldToRobots.add(fieldToRobot);
        tagCorners.addAll(corners);
        camToTags.add(target.getBestCameraToTarget());
      }

      /* Prepare values for logging */
      var tagIdsArray = tagIds.stream().mapToLong(Long::valueOf).toArray();

      var fieldToRobotStrs = fieldToRobots.stream().map((estRobotPose) -> MoreMath.pose3dToString(estRobotPose, 1))
          .toList().toArray(new String[0]);

      var fieldToCamStrs = fieldToCams.stream().map((estRobotPose) -> MoreMath.pose3dToString(estRobotPose, 1)).toList()
          .toArray(new String[0]);

      var fieldToTagStrs = fieldToTags.stream().map((tagPose) -> (MoreMath.pose2dToString(tagPose.toPose2d(), 1)))
          .toList().toArray(new String[0]);

      var camToTagStrs = camToTags.stream().map((camToTag) -> (MoreMath.transform3dToString(camToTag, 1))).toList()
          .toArray(new String[0]);

      var tagCornersStr =
          tagCorners.stream().map((corner) -> MoreMath.cornerToString(corner, 1)).toList().toArray(new String[0]);

      var optEstimate = estimates.get(i);
      var estimateStatus = "invalid";
      var estimateStr = "";
      var estimate3dStr = "";
      if (isEstimatePresent(optEstimate)) {
        estimateStatus = "valid";
        var estimate = optEstimate.get();
        var pose = estimate.best.toPose2d();
        this.field.getObject(cam.getName()).setPose(pose);
        estimateStr = MoreMath.pose2dToString(pose, 1);
        estimate3dStr = MoreMath.pose3dToString(estimate.best, 1);
      }

      var timestamp = cam.getLatestResult().getTimestampSeconds();

      var camMatrixPresent = "invalid";
      if (cam.getCameraMatrix().isPresent()) {
        camMatrixPresent = "valid";
      }

      var distCoeffPresent = "invalid";
      if (cam.getDistCoeffs().isPresent()) {
        distCoeffPresent = "valid";
      }

      var camPresent = cam.isConnected() ? "connected" : "disconnected";

      // advantage kit logging (because why not)
      List<Pose3d> akTagPoses = new ArrayList<>();
      List<Integer> akTagIds = new ArrayList<>();
      for (var target : cam.getLatestResult().getTargets()) {
        var swervePose = new Pose3d(swerve.getPose());
        akTagPoses.add(swervePose.transformBy(target.getBestCameraToTarget()));
        akTagIds.add(target.getFiducialId());
      }
      var akTagPosesArray = fieldToTags.toArray(new Pose3d[fieldToTags.size()]);
      var akFieldToCams = fieldToCams.toArray(new Pose3d[fieldToCams.size()]);
      var akFieldToRobots = fieldToRobots.toArray(new Pose3d[fieldToRobots.size()]);

      /* May be slightly cursed */
      var akTagIdsArray = tagIds.stream().mapToLong(Long::valueOf).toArray();

      var path = "vision/" + cam.getName() + "/";
      Logger.getInstance().recordOutput(path + "cam status", camPresent);
      Logger.getInstance().recordOutput(path + "estimate status", estimateStatus);
      if (!estimateStatus.equals("invalid")) {
        Logger.getInstance().recordOutput(path + "estimate", estimateStr);
        Logger.getInstance().recordOutput(path + "3d estimate", estimate3dStr);
      }
      Logger.getInstance().recordOutput(path + "timestamp", timestamp);
      Logger.getInstance().recordOutput(path + "cam matrix", camMatrixPresent);
      Logger.getInstance().recordOutput(path + "dist coeff", distCoeffPresent);

      var targetPath = path + "targets/";
      Logger.getInstance().recordOutput(targetPath + "tag ids", tagIdsArray);
      Logger.getInstance().recordOutput(targetPath + "tag corners", tagCornersStr);
      Logger.getInstance().recordOutput(targetPath + "field to tags", fieldToTagStrs);
      Logger.getInstance().recordOutput(targetPath + "field to cams", fieldToCamStrs);
      Logger.getInstance().recordOutput(targetPath + "field to robots", fieldToRobotStrs);
      Logger.getInstance().recordOutput(targetPath + "cam to tags", camToTagStrs);

      var akPath = path + "ak/";
      Logger.getInstance().recordOutput(akPath + "tag poses", akTagPosesArray);
      Logger.getInstance().recordOutput(akPath + "tag ids", akTagIdsArray);
      Logger.getInstance().recordOutput(akPath + "field to cams", akFieldToCams);
      Logger.getInstance().recordOutput(akPath + "field to robots", akFieldToRobots);


      field.getObject("Robot Pose").setPose(swerve.getPose());
      field.getObject("Wheel Pose").setPose(swerve.getWheelPose());
    }
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.subsystems.vision;

import java.util.ArrayList;
import java.util.Optional;
import org.littletonrobotics.junction.Logger;
import frc.robot.util.MoreMath;
import frc.robot.util.vision.CustomEstimate;
import frc.robot.util.vision.SimCamParams;
import frc.robot.util.vision.SimVisionSystem;
import edu.wpi.first.math.VecBuilder;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.wpilibj.smartdashboard.Field2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import frc.robot.Constants;
import frc.robot.subsystems.drive.Swerve;

/** Add your docs here. */
public class VisionSim extends Vision {
  ArrayList<SimVisionSystem> simCams;
  private Field2d field;
  private Field2d staticField;
  private Pose2d actualStaticPose = new Pose2d(1.5, 1.5, Rotation2d.fromDegrees(90));

  public VisionSim(Swerve swerve) {
    super(swerve);
    initSimCams();

    this.field = new Field2d();
    SmartDashboard.putData("vision sim field", field);

    this.staticField = new Field2d();
    SmartDashboard.putData("vision sim delta field", staticField);
    staticField.setRobotPose(this.actualStaticPose);
  }

  @Override
  public void simulationPeriodic() {
    for (var simCam : simCams) {
      simCam.clearVisionTargets();
      simCam.addVisionTargets(getAtfl());
      simCam.processFrame(swerve.getWheelPose());
    }

    this.field.setRobotPose(this.swerve.getWheelPose());

    var estimate = getEstimate();
    if (isEstimatePresent(estimate)) {
      var pose = estimate.get().best.toPose2d();
      this.field.getObject("vision est").setPose(pose);
      Logger.getInstance().recordOutput("Vision/logging vision est", true);

      var staticTrans = pose.getTranslation().minus(this.swerve.getWheelPose().getTranslation())
          .plus(this.actualStaticPose.getTranslation());
      var staticPose = new Pose2d(staticTrans, this.actualStaticPose.getRotation());
      this.staticField.getObject("vision est").setPose(staticPose);
    } else {
      Logger.getInstance().recordOutput("Vision/logging vision est", false);
    }
  }

  public void initSimCams() {
    simCams = new ArrayList<SimVisionSystem>();
    for (SimCamParams simCamParams : Constants.VISION_SIM.SIM_CAMS_PARAMS) {
      var simCam = new SimVisionSystem(simCamParams.name, simCamParams.camDiagFOV, simCamParams.robot2Cam,
          simCamParams.maxLEDRange, simCamParams.camResWidth, simCamParams.camResHeight, simCamParams.minTargetArea,
          0.1);
      simCams.add(simCam);

      double hypotPixels = Math.hypot(simCamParams.camResWidth, simCamParams.camResHeight);
      var camHorizFOVDegrees = simCamParams.camDiagFOV * simCamParams.camResWidth / hypotPixels;
      var camVertFOVDegrees = simCamParams.camDiagFOV * simCamParams.camResHeight / hypotPixels;
      var camMatrix = MoreMath.calcCamMatrix(simCamParams.camResWidth, simCamParams.camResHeight, camHorizFOVDegrees,
          camVertFOVDegrees);
      simCam.getSimCam().setCameraIntrinsicsMat(camMatrix);
      simCam.getSimCam().setCameraDistortionMat(VecBuilder.fill(0, 0, 0, 0, 0));
    }
  }

  public Optional<CustomEstimate> getEstimate() {
    Optional<CustomEstimate> latestEstimate = Optional.empty();
    for (var estimate : estimates) {
      if (!isEstimatePresent(latestEstimate)
          || (isEstimatePresent(estimate) && estimate.get().timestampSeconds > latestEstimate.get().timestampSeconds)) {
        latestEstimate = estimate;
      }
    }
    return latestEstimate;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.subsystems.wrist;

import org.littletonrobotics.junction.Logger;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.FaultID;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.CANSparkMaxLowLevel.PeriodicFrame;
import com.revrobotics.SparkMaxAbsoluteEncoder;
import com.revrobotics.SparkMaxAbsoluteEncoder.Type;
import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import frc.robot.Constants.WRIST;
import frc.robot.subsystems.arm.Arm;
import frc.robot.subsystems.wrist.WristState.WristControlType;
import frc.robot.util.MoreMath;
import frc.robot.util.SendableArmFeedforward;

public class Wrist extends SubsystemBase {
  /** Creates a new Wrist. */
  private int zeroCount = 0;
  private Boolean configureHasRan = false;

  private double goal;
  private WristControlType controlState = WristControlType.DEFAULT;

  private CANSparkMax motor = new CANSparkMax(WRIST.WRIST_ID, MotorType.kBrushless);
  private SparkMaxAbsoluteEncoder encoder = motor.getAbsoluteEncoder(Type.kDutyCycle);

  protected PIDController pid = new PIDController(WRIST.WRIST_PID[0], WRIST.WRIST_PID[1], WRIST.WRIST_PID[2]);
  private SendableArmFeedforward ff =
      new SendableArmFeedforward(WRIST.WRIST_FF[0], WRIST.WRIST_FF[1], WRIST.WRIST_FF[2]);

  private double pidval;
  private double ffval;

  private double lastNonWrapRangePose = 90;

  private Arm arm;
  private boolean wrapRangeEntered = false;
  private double volts;

  public Wrist(Arm arm) {
    this.arm = arm;
    configure();

    SmartDashboard.putData("Wrist/ff", ff);
    SmartDashboard.putData("Wrist/pid", pid);
  }

  private void setControlState(WristControlType controlState) {
    this.controlState = controlState;
  }

  public double getGoal() {
    return goal;
  }

  public double getPose() {
    return encoder.getPosition() + Constants.WRIST.ANGLE_OFFSET;
  }

  public double getVelocity() {
    return encoder.getVelocity();
  }

  //In case a wrist command needs to access arm pose (don't want to give it entire arm subsystem)
  public double getArmPose() {
    return arm.getPose();
  }

  public void setVoltage(double volts) {
    this.volts = volts;
    motor.setVoltage(volts);
  }

  public void setGoal(WristState state) {
    var desiredGoal = state.getGoal();

    if (angersWrapRangeHandler(desiredGoal) || angersInsideRobotHandler(desiredGoal)){
      setGoalByType(WristControlType.DEFAULT);
    }else{
      goal = desiredGoal;
      setControlState(state.type);
    }
  }

  private boolean angersInsideRobotHandler(double goal) {
    var armInsideBot = WristState.INSIDE_ROBOT.inRange(getArmPose());
    return armInsideBot && goal < 0;
  }

  private boolean angersWrapRangeHandler(double goal) {
    return goal > WRIST.WRAP_RANGE_UPPER_BOUND || goal < WRIST.WRAP_RANGE_LOWER_BOUND;
  }

  @Override
  public void periodic() {
    runPid();
    wrapRangeHandler();
    insideRobotHandler();
    sensorFaultHandler();
    log();
  }

  private void runPid() {
    double currentPose = getPose();
    this.pidval = pid.calculate(currentPose, goal);
    this.ffval = ff.calculate(currentPose, 0);

    setVoltage(ffval + pidval);
  }

  private void wrapRangeHandler() {
    var inWrapRange = getPose() > WRIST.WRAP_RANGE_UPPER_BOUND || getPose() < WRIST.WRAP_RANGE_LOWER_BOUND;
    if (inWrapRange)
      wrapRangeEntered = true;
    else {
      var didLoopBack = Math.signum(lastNonWrapRangePose) == Math.signum(getPose());
      if (didLoopBack)
        wrapRangeEntered = false;
    }

    if (wrapRangeEntered) {
      var direction = -1 * Math.signum(lastNonWrapRangePose);
      setVoltage(direction * WRIST.WRAP_RANGE_SPEED);
      Logger.getInstance().recordOutput("Wrist/wrap range handler triggered", true);
    } else{
      lastNonWrapRangePose = getPose();
      Logger.getInstance().recordOutput("Wrist/wrap range handler triggered", false);
    }

  }

  /* Don't move towards the base of the robot if inside it (not good) */
  private void insideRobotHandler() {
    var armInsideBot = WristState.INSIDE_ROBOT.inRange(getArmPose());
    var inQuad3 = MoreMath.within(getPose(), -180, -90);
    var inQuad4 = MoreMath.within(getPose(), -90, 0);
    var wristMovingDown = (inQuad3 && volts > 0) || (inQuad4 && volts < 0);

    var overrideTriggered = false;
    if (armInsideBot && wristMovingDown) {
      setVoltage(0);
      overrideTriggered = true;
    }
    Logger.getInstance().recordOutput("Wrist/Inside Robot Handler Triggered", overrideTriggered);
  }

  public void setGoalByType(WristControlType wristStateType) { // check what range the arm is in and set the wrist accordingly
    double armPos = arm.getPose();
    for (WristState wristState : WristState.values()) {
      if (wristState.type == wristStateType && wristState.inRange(armPos)) {
        setGoal(wristState);
        return;
      }
    }
  }

  public void sensorFaultHandler() {
    boolean hasFaults = motor.getFault(FaultID.kCANTX) || motor.getFault(FaultID.kCANRX);
    boolean hasStickyFaults = motor.getStickyFault(FaultID.kCANTX) || motor.getStickyFault(FaultID.kCANRX);
    var pose = encoder.getPosition();

    if (pose == 0 || pose > 2000 || pose < -2000) {
      zeroCount++;
    }

    var zeroCountFault = zeroCount > 1;
    Logger.getInstance().recordOutput("Wrist/Faults/Zero Count Fault", zeroCountFault);
    Logger.getInstance().recordOutput("Wrist/Faults/Fault", hasFaults);
    Logger.getInstance().recordOutput("Wrist/Faults/Sticky Fault", hasStickyFaults);

    if (hasStickyFaults) {
      DriverStation.reportWarning("Wrist Sticky Fault", true);
    }

    var shouldPanic = zeroCountFault || hasFaults;
    if (shouldPanic) {
      DriverStation.reportError("OUR ZERO ERROR IN WRIST", true);
      setVoltage(0);
      if (configureHasRan == false) {
        configure();
      }
      configureHasRan = true;
    }
  }

  private void log() {
    Logger.getInstance().recordOutput("Wrist/wrap range entered", wrapRangeEntered);
    Logger.getInstance().recordOutput("Wrist/Last non wrap pose", lastNonWrapRangePose);
    Logger.getInstance().recordOutput("Wrist/ReConfigure has ran", configureHasRan);
    Logger.getInstance().recordOutput("Wrist/control state", controlState.name());
    Logger.getInstance().recordOutput("Wrist/Pose", MoreMath.round(getPose(), 1));
    Logger.getInstance().recordOutput("Wrist/Vel", MoreMath.round(getVelocity(), 1));
    Logger.getInstance().recordOutput("Wrist/Goal", MoreMath.round(goal, 1));
    Logger.getInstance().recordOutput("Wrist/Error", MoreMath.round(pid.getPositionError(), 1));
    Logger.getInstance().recordOutput("Wrist/PIDVal", MoreMath.round(pidval, 1));
    Logger.getInstance().recordOutput("Wrist/FFVal", MoreMath.round(ffval, 1));
    Logger.getInstance().recordOutput("Wrist/Appliedvolts", MoreMath.round(motor.getAppliedOutput(), 1));
    Logger.getInstance().recordOutput("Wrist/Current Command",
        this.getCurrentCommand() != null ? this.getCurrentCommand().getName() : "");
  }

  private void configure() {
    motor.restoreFactoryDefaults();
    motor.setInverted(true);
    encoder.setInverted(true);
    motor.setIdleMode(IdleMode.kCoast);
    encoder.setPositionConversionFactor(360);
    encoder.setVelocityConversionFactor(360);

    /* Status 0 governs applied output, faults, and whether is a follower. Not important for this. */
    motor.setPeriodicFramePeriod(PeriodicFrame.kStatus0, 20);
    /* Integrated motor position isn't important here. */
    motor.setPeriodicFramePeriod(PeriodicFrame.kStatus2, 500);
    /* Don't have an analog sensor */
    motor.setPeriodicFramePeriod(PeriodicFrame.kStatus3, 500);
    /* Don't have an alternate encoder */
    motor.setPeriodicFramePeriod(PeriodicFrame.kStatus4, 500);
    /* Have a duty cycle encoder */
    motor.setPeriodicFramePeriod(PeriodicFrame.kStatus5, 20);
    motor.setPeriodicFramePeriod(PeriodicFrame.kStatus6, 20);

    try {
      Thread.sleep((long) 40.0);
    } catch (Exception e) {
      e.printStackTrace();
    } ;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.subsystems.wrist;

import edu.wpi.first.math.MathUtil;
import edu.wpi.first.math.VecBuilder;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.system.plant.DCMotor;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.wpilibj.simulation.SingleJointedArmSim;
import edu.wpi.first.wpilibj.smartdashboard.MechanismLigament2d;
import edu.wpi.first.wpilibj.util.Color;
import edu.wpi.first.wpilibj.util.Color8Bit;
import frc.robot.Constants;
import frc.robot.Constants.MECH_PLOT;
import frc.robot.subsystems.arm.ArmSim;
import frc.robot.util.sim.Cone;
import frc.robot.util.sim.MechRootWrapper;

/** Add your docs here. */
public class WristSim extends Wrist {
  private ArmSim armSim;
  private double simVolts;

  private static final DCMotor simMotor = DCMotor.getNEO(1);
  private static final SingleJointedArmSim sim = new SingleJointedArmSim(simMotor, MECH_PLOT.WRIST_REDUCTION,
      SingleJointedArmSim.estimateMOI(MECH_PLOT.WRIST_LENGTH, MECH_PLOT.WRIST_MASS), MECH_PLOT.WRIST_LENGTH, -1e10,
      1e10, true, VecBuilder.fill(0.001));
  private final MechRootWrapper simPivot;
  private final MechanismLigament2d simLig;
  private final Cone simCone;

  public WristSim(ArmSim arm) {
    super(arm);
    this.armSim = arm;

    simPivot = new MechRootWrapper(this.armSim.m_mech2d, "WristPivot", 0, 0);
    simLig = simPivot.append(new MechanismLigament2d("Wrist", MECH_PLOT.WRIST_LENGTH,
        Units.radiansToDegrees(sim.getAngleRads()), 10.0, new Color8Bit(Color.kBlue)));
    simCone = new Cone(simPivot, new Pose2d(5, 0, new Rotation2d(180)));

    super.pid.setP(Constants.MECH_PLOT.SIM_WRIST_PID[0]);
    super.pid.setI(Constants.MECH_PLOT.SIM_WRIST_PID[1]);
    super.pid.setD(Constants.MECH_PLOT.SIM_WRIST_PID[2]);
  }

  @Override
  public void setVoltage(double volts) {
    this.simVolts = MathUtil.clamp(volts,-12,12);
  }

  @Override
  public double getPose() {
    var ctsPose = Units.radiansToDegrees(sim.getAngleRads()) + 180;
    var numWraps = (int) (ctsPose / 180.0);
    if (ctsPose > 0) {
      if (numWraps % 2 == 0) {
        return (ctsPose % 180.0);
      } else {
        return -180.0 + (ctsPose % 180.0);
      }
    } else {
      if (numWraps % 2 == 0) {
        return (ctsPose % 180.0);
      } else {
        return 180.0 + (ctsPose % 180.0);
      }
    }
  }

  public double getVelocity() {
    return Units.radiansToDegrees(sim.getVelocityRadPerSec());
  }

  public boolean hasSensorFault() {
    return false;
  }

  @Override
  public void sensorFaultHandler(){

  }

  public void simulationPeriodic() {
    double armPosRads = Units.degreesToRadians(armSim.getPose());
    double pivot_x = MECH_PLOT.ARM_PIVOT_X + (armSim.m_arm.getLength()) * Math.cos(armPosRads);
    double pivot_y = MECH_PLOT.ARM_PIVOT_Y + (armSim.m_arm.getLength()) * Math.sin(armPosRads);
    simPivot.setPosition(pivot_x, pivot_y);
    // In this method, we update our simulation of what our arm is doing
    // First, we set our "inputs" (voltages)
    sim.setInput(MathUtil.clamp(this.simVolts, -12, 12));

    // Next, we update it. The standard loop time is 20ms.
    sim.update(0.020);

    // SimBattery estimates loaded battery voltages
    // Update the Mechanism Arm angle based on the simulated arm angle
    simLig.setAngle(getPose());
    simCone.update(Rotation2d.fromDegrees(getPose()));
  }
}
package frc.robot.subsystems.wrist;

import java.util.function.Function;
import org.ejml.equation.VariableType;
import frc.robot.Constants.ARM;

public enum WristState {

  //arm 0 deg is positive x axis
  // @formatter:off

  /* DEFAULT */
  FEEDER_STATION(ARM.MIN_ANGLE, -170, -110.7), 
  TRANSITION(-170, -140, 0), 
  INSIDE_ROBOT(-140, -70, 90), 
  PLACE(-70,ARM.MAX_ANGLE, 90),

  /* ALT */
  GROUND_PICK_UP(-66, -50, -90, WristControlType.ALT),
  PLACE_ON_NODE(-50, ARM.MAX_ANGLE, 0, WristControlType.ALT),

  /* MANUAL */
  UP(90, WristControlType.MANUAL), 
  DOWN(-90, WristControlType.MANUAL), 
  RIGHT(0, WristControlType.MANUAL), 
  VARIABLE(0, WristControlType.MANUAL);//goal here is unnecessary, since we will use the setWristGoal method 
  //LEFT is illegal

  // @formatter:on

  public enum WristControlType {
    ALT, DEFAULT, MANUAL;
  }

  private final double min;
  private final double max;
  public final WristControlType type;
  private double goal;

  private WristState(double goal, WristControlType type) {
    this(ARM.MIN_ANGLE, ARM.MAX_ANGLE, goal, type);
  }

  private WristState(double min, double max, double goal) {
    this(min, max, goal, WristControlType.DEFAULT);
  }

  private WristState(double min, double max, double goal, WristControlType type) {
    this.min=min;
    this.max=max;
    this.goal=goal;
    this.type=type;
  }

  public boolean inRange(double currentWrappedPos) {
    return currentWrappedPos >= min && currentWrappedPos <= max;
  }

  private void setGoal(double goal){
    this.goal=goal;
  }

  public double getGoal(){
    return goal;
  }

  //this is cursed
  public static WristState getStateWithGoal(double goal){
    VARIABLE.setGoal(goal);
    return VARIABLE;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.util;

import java.util.function.Supplier;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.CommandBase;
import edu.wpi.first.wpilibj2.command.Subsystem;

/** Add your docs here. */
public class CustomProxy extends CommandBase {
  private Supplier<Command> supplier;
  private Command command;

  public CustomProxy(Supplier<Command> supplier, Subsystem... requirements) {
    this.supplier = supplier;
    addRequirements(requirements);
  }


  // Called when the command is initially scheduled.
  @Override
  public void initialize() {
    this.command = supplier.get();
    command.initialize();
  }

  // Called every time the scheduler runs while the command is scheduled.
  @Override
  public void execute() {
    command.execute();
  }

  // Called once the command ends or is interrupted.
  @Override
  public void end(boolean interrupted) {
    command.end(interrupted);
  }

  // Returns true when the command should end.
  @Override
  public boolean isFinished() {
    return command.isFinished();
  }

}
package frc.robot.util;

import java.math.BigDecimal;
import java.math.RoundingMode;
import org.photonvision.targeting.TargetCorner;
import com.pathplanner.lib.PathConstraints;
import com.pathplanner.lib.PathPlanner;
import com.pathplanner.lib.PathPlannerTrajectory;
import com.pathplanner.lib.PathPoint;
import edu.wpi.first.math.Matrix;
import edu.wpi.first.math.Nat;
import edu.wpi.first.math.Pair;
import edu.wpi.first.math.VecBuilder;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Pose3d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Rotation3d;
import edu.wpi.first.math.geometry.Transform2d;
import edu.wpi.first.math.geometry.Transform3d;
import edu.wpi.first.math.numbers.N3;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.wpilibj.DriverStation;
import frc.robot.Constants;

public class MoreMath {

  public static double round(double value, int places) {
    if (places < 0)
      throw new IllegalArgumentException();
    if (Double.isNaN(value))
      return value;
    if (Double.isInfinite(value))
      return value;

    BigDecimal bd = new BigDecimal(Double.toString(value));
    bd = bd.setScale(places, RoundingMode.HALF_UP);
    return bd.doubleValue();
  }

  public static String pose2dToString(Pose2d pos, int places) {
    return "(" + round(pos.getX(), places) + ", " + round(pos.getY(), places) + ", "
        + round(pos.getRotation().getDegrees(), places) + ")";
    // return "X=" + pos.getX() + "; Y=" + pos.getY() + "; Deg=" + pos.getRotation().getDegrees();
  }


  public static String pose3dToString(Pose3d pose, int places) {
    return "(" + round(pose.getX(), places) + ", " + round(pose.getY(), places) + ", " + round(pose.getZ(), places)
        + ";" + " " + round(Units.radiansToDegrees(pose.getRotation().getX()), places) + ", "
        + round(Units.radiansToDegrees(pose.getRotation().getY()), places) + ", "
        + round(Units.radiansToDegrees(pose.getRotation().getZ()), places) + ")";
    // return "X=" + pos.getX() + "; Y=" + pos.getY() + "; Deg=" + pos.getRotation().getDegrees();
  }

  public static String transform3dToString(Transform3d transform, int places) {
    return "(" + round(transform.getX(), places) + ", " + round(transform.getY(), places) + ", "
        + round(transform.getZ(), places) + ";" + " "
        + round(Units.radiansToDegrees(transform.getRotation().getX()), places) + ", "
        + round(Units.radiansToDegrees(transform.getRotation().getY()), places) + ", "
        + round(Units.radiansToDegrees(transform.getRotation().getZ()), places) + ")";
    // return "X=" + pos.getX() + "; Y=" + pos.getY() + "; Deg=" + pos.getRotation().getDegrees();
  }

  public static String cornerToString(TargetCorner corner, int places) {
    return "(" + round(corner.x, places) + ", " + round(corner.y, places) + ")";
  }

  /* Pose exp for teleop drive. Takes in controller x and y axises and outputs pose exped ones */
  public static Pair<Double, Double> poseExp(double x, double y) {
    // java doesn't have an exponent operator apparently
    double mag = Math.sqrt(x * x + y * y);
    double angle = Math.atan2(y, x);

    mag *= Math.abs(mag);

    return new Pair<>(Math.cos(angle) * mag, Math.sin(angle) * mag);
  }

  public static double getClosest(double current, double desired) {
    var currentWrap = getWrap(current);
    var currentBase = currentWrap * 360;

    var desiredMod360 = mod360(desired);

    double[] possibilities = {(currentBase + desiredMod360 - 720), (currentBase + desiredMod360 - 360),
        (currentBase + desiredMod360), (currentBase + desiredMod360 + 360), (currentBase + desiredMod360 + 720)};

    var closest = (double) Integer.MIN_VALUE;
    for (var possibility : possibilities) {
      var currentDist = Math.abs(possibility - current);
      var closestDist = Math.abs(closest - current);
      if (closestDist > currentDist) {
        closest = possibility;
      }
    }
    // System.out.println(index);
    return closest;
  }

  /* find desired's closest congruence class representative to current */
  public static double getClosestRad(double current, double desired) {
    var result = getClosest(Units.radiansToDegrees(current), Units.radiansToDegrees(desired));
    return Units.degreesToRadians(result);
  }


  public static int getWrap(double angle) {
    var wrap = (int) (angle / 360.0);
    return wrap;
  }

  public static double mod360(double angle) {
    var angleMod360 = angle % 360;
    angleMod360 = angleMod360 < 0 ? angleMod360 + 360 : angleMod360;
    return angleMod360;
  }

  public static Pose2d deepCopyPose(Pose2d pose) {
    var deepCopy = new Pose2d();
    deepCopy = deepCopy.plus(new Transform2d(new Pose2d(), pose));
    return deepCopy;
  }

  public static Pose2d transformByAlliance(Pose2d pose) {
    if (DriverStation.getAlliance() == DriverStation.Alliance.Red) {
      return new Pose2d(pose.getX(), Constants.FIELD_CONSTANTS.WIDTH - pose.getY(), pose.getRotation());
    }
    return pose;
  }

  private static double calculateDifference(Pose3d x, Pose3d y) {
    return x.getTranslation().getDistance(y.getTranslation());
  }

  /* horizFOV and verFOV expected in degrees */
  public static Matrix<N3, N3> calcCamMatrix(double resWidth, double resHeight, double horizFOV, double verFOV) {
    horizFOV = Units.degreesToRadians(horizFOV);
    verFOV = Units.degreesToRadians(verFOV);


    var f_x = resWidth / (Math.tan(horizFOV / 2) * 2);
    var f_y = resHeight / (Math.tan(verFOV / 2) * 2);

    var camMatrix = new Matrix<>(Nat.N3(), Nat.N3());
    camMatrix.setColumn(0, VecBuilder.fill(f_x, 0, 0));
    camMatrix.setColumn(1, VecBuilder.fill(0, f_y, 0));
    camMatrix.setColumn(2, VecBuilder.fill(resWidth / 2, resHeight / 2, 1));

    return camMatrix;
  }

  public static Pose3d transformBy(Pose3d current, Transform3d other) {
    return new Pose3d(current.getTranslation().plus(other.getTranslation().rotateBy(current.getRotation())),
        addRotation3d(current.getRotation(), other.getRotation()));
  }

  public static Pose3d transformTwice(Pose3d current, Transform3d other, Transform3d another) {
    return transformBy(transformBy(current, other), another);
  }

  public static Rotation3d addRotation3d(Rotation3d current, Rotation3d other) {
    return new Rotation3d(current.getX() + other.getX(), current.getY() + other.getY(), current.getZ() + other.getZ());
  }

  public static Rotation2d calcHeading(Pose2d start, Pose2d end) {
    var heading = end.getTranslation().minus(start.getTranslation()).getAngle();
    return heading;
  }

  public static PathPlannerTrajectory createStraightPath(Pose2d start, Pose2d end, PathConstraints constraints) {
    var heading = calcHeading(start, end);
    var startPoint = createPathPoint(start, heading);
    var endPoint = createPathPoint(end, heading);

    var traj = PathPlanner.generatePath(constraints, startPoint, endPoint);
    return traj;
  }

  public static PathPoint createPathPoint(Pose2d pose, Rotation2d heading) {
    return new PathPoint(pose.getTranslation(), heading, pose.getRotation());
  }

  public static PathPoint createPathPoint(Pose2d pose, Rotation2d heading, double speed) {
    return new PathPoint(pose.getTranslation(), heading, pose.getRotation(), speed);
  }

  public static boolean within(double val, double firstBound, double secondBound) {
    double lowerBound;
    double upperBound;
    if (firstBound < secondBound) {
      lowerBound = firstBound;
      upperBound = secondBound;
    } else {
      lowerBound = secondBound;
      upperBound = firstBound;
    }

    return val > lowerBound && val < upperBound;
  }

  public static boolean isBlue() {
    return DriverStation.getAlliance() == DriverStation.Alliance.Blue;
  }
}
package frc.robot.util;

import org.littletonrobotics.junction.Logger;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

public class NTToAdvantageKit {
  private static void logNTNumber(String name) {
    Logger.getInstance().recordOutput(name, SmartDashboard.getNumber(name, 0));
  }

  public static void periodic() {
    logNTNumber("PPSwerveControllerCommand_rotationError");
    logNTNumber("PPSwerveControllerCommand_xError");
    logNTNumber("PPSwerveControllerCommand_yError");
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.util;

import edu.wpi.first.math.util.Units;
import edu.wpi.first.util.sendable.Sendable;
import edu.wpi.first.util.sendable.SendableBuilder;

/**
 * A helper class that computes feedforward outputs for a simple arm (modeled as a motor acting against the force of gravity on a beam suspended at an angle).
 */
public class SendableArmFeedforward implements Sendable {
  public double ks;
  public double kg;
  public double kv;
  public double ka;

  @Override
  public void initSendable(SendableBuilder b) {
    b.addDoubleProperty("kS", () -> {
      return ks;
    }, (double newKs) -> {
      ks = newKs;
    });
    b.addDoubleProperty("kG", () -> {
      return kg;
    }, (double newKg) -> {
      kg = newKg;
    });
    b.addDoubleProperty("kV", () -> {
      return kv;
    }, (double newKv) -> {
      kv = newKv;
    });
    b.addDoubleProperty("kA", () -> {
      return ka;
    }, (double newKa) -> {
      ka = newKa;
    });
  }

  /**
   * Creates a new ArmFeedforward with the specified gains. Units of the gain values will dictate units of the computed feedforward.
   *
   * @param ks The static gain.
   * @param kg The gravity gain.
   * @param kv The velocity gain.
   * @param ka The acceleration gain.
   */
  public SendableArmFeedforward(double ks, double kg, double kv, double ka) {
    this.ks = ks;
    this.kg = kg;
    this.kv = kv;
    this.ka = ka;
  }

  /**
   * Creates a new ArmFeedforward with the specified gains. Acceleration gain is defaulted to zero. Units of the gain values will dictate units of the computed feedforward.
   *
   * @param ks The static gain.
   * @param kg The gravity gain.
   * @param kv The velocity gain.
   */
  public SendableArmFeedforward(double ks, double kg, double kv) {
    this(ks, kg, kv, 0);
  }

  /**
   * Calculates the feedforward from the gains and setpoints.
   *
   * @param positionDeg The position (angle) setpoint. This angle should be measured from the horizontal (i.e. if the provided angle is 0, the arm should be parallel with
   *          the floor). If your encoder does not follow this convention, an offset should be added.
   * @param velocityDegPerSec The velocity setpoint.
   * @param accelDegPerSecSquared The acceleration setpoint.
   * @return The computed feedforward.
   */
  public double calculate(double positionDeg, double velocityDegPerSec, double accelDegPerSecSquared) {
    double positionRad = Units.degreesToRadians(positionDeg);
    double velocityRadPerSec = Units.degreesToRadians(velocityDegPerSec);
    double accelRadPerSecSquared = Units.degreesToRadians(accelDegPerSecSquared);

    return ks * Math.signum(velocityRadPerSec) + kg * Math.cos(positionRad) + kv * velocityRadPerSec
        + ka * accelRadPerSecSquared;
  }

  /**
   * Calculates the feedforward from the gains and velocity setpoint (acceleration is assumed to be zero).
   *
   * @param positionDeg The position (angle) setpoint. This angle should be measured from the horizontal (i.e. if the provided angle is 0, the arm should be parallel with
   *          the floor). If your encoder does not follow this convention, an offset should be added.
   * @param velocityDegPerSec The velocity setpoint.
   * @return The computed feedforward.
   */
  public double calculate(double positionDeg, double velocityDegPerSec) {
    return calculate(positionDeg, velocityDegPerSec, 0);
  }

  // Rearranging the main equation from the calculate() method yields the
  // formulas for the methods below:

  /**
   * Calculates the maximum achievable velocity given a maximum voltage supply, a position, and an acceleration. Useful for ensuring that velocity and acceleration
   * constraints for a trapezoidal profile are simultaneously achievable - enter the acceleration constraint, and this will give you a simultaneously-achievable velocity
   * constraint.
   *
   * @param maxVoltage The maximum voltage that can be supplied to the arm.
   * @param positionDeg The angle of the arm. This angle should be measured from the horizontal (i.e. if the provided angle is 0, the arm should be parallel with the
   *          floor). If your encoder does not follow this convention, an offset should be added.
   * @param accelDegPerSec The acceleration of the arm.
   * @return The maximum possible velocity at the given acceleration and angle.
   */
  public double maxAchievableVelocity(double maxVoltage, double positionDeg, double accelDegPerSec) {
    // Assume max velocity is positive
    double positionRad = Units.degreesToRadians(positionDeg);
    double accelRadPerSecSquared = Units.degreesToRadians(accelDegPerSec);
    return (maxVoltage - ks - Math.cos(positionRad) * kg - accelRadPerSecSquared * ka) / kv;
  }

  /**
   * Calculates the minimum achievable velocity given a maximum voltage supply, a position, and an acceleration. Useful for ensuring that velocity and acceleration
   * constraints for a trapezoidal profile are simultaneously achievable - enter the acceleration constraint, and this will give you a simultaneously-achievable velocity
   * constraint.
   *
   * @param maxVoltage The maximum voltage that can be supplied to the arm.
   * @param positionDeg The angle of the arm. This angle should be measured from the horizontal (i.e. if the provided angle is 0, the arm should be parallel with the
   *          floor). If your encoder does not follow this convention, an offset should be added.
   * @param accelDegPerSec The acceleration of the arm.
   * @return The minimum possible velocity at the given acceleration and angle.
   */
  public double minAchievableVelocity(double maxVoltage, double positionDeg, double accelDegPerSec) {
    double positionRad = Units.degreesToRadians(positionDeg);
    double accelRadPerSecSquared = Units.degreesToRadians(accelDegPerSec);
    // Assume min velocity is negative, ks flips sign
    return (-maxVoltage + ks - Math.cos(positionRad) * kg - accelRadPerSecSquared * ka) / kv;
  }

  /**
   * Calculates the maximum achievable acceleration given a maximum voltage supply, a position, and a velocity. Useful for ensuring that velocity and acceleration
   * constraints for a trapezoidal profile are simultaneously achievable - enter the velocity constraint, and this will give you a simultaneously-achievable acceleration
   * constraint.
   *
   * @param maxVoltage The maximum voltage that can be supplied to the arm.
   * @param positionDeg The angle of the arm. This angle should be measured from the horizontal (i.e. if the provided angle is 0, the arm should be parallel with the
   *          floor). If your encoder does not follow this convention, an offset should be added.
   * @param velocityDegPerSec The velocity of the arm.
   * @return The maximum possible acceleration at the given velocity.
   */
  public double maxAchievableAcceleration(double maxVoltage, double positionDeg, double velocityDegPerSec) {
    double positionRad = Units.degreesToRadians(positionDeg);
    double velocityRadPerSec = Units.degreesToRadians(velocityDegPerSec);
    return (maxVoltage - ks * Math.signum(velocityRadPerSec) - Math.cos(positionRad) * kg - velocityRadPerSec * kv)
        / ka;
  }

  /**
   * Calculates the minimum achievable acceleration given a maximum voltage supply, a position, and a velocity. Useful for ensuring that velocity and acceleration
   * constraints for a trapezoidal profile are simultaneously achievable - enter the velocity constraint, and this will give you a simultaneously-achievable acceleration
   * constraint.
   *
   * @param maxVoltage The maximum voltage that can be supplied to the arm.
   * @param positionDeg The angle of the arm. This angle should be measured from the horizontal (i.e. if the provided angle is 0, the arm should be parallel with the
   *          floor). If your encoder does not follow this convention, an offset should be added.
   * @param velocityDegPerSec The velocity of the arm.
   * @return The minimum possible acceleration at the given velocity.
   */
  public double minAchievableAcceleration(double maxVoltage, double positionDeg, double velocityDegPerSec) {
    return maxAchievableAcceleration(-maxVoltage, positionDeg, velocityDegPerSec);
  }
}
package frc.robot.util;

import com.revrobotics.SparkMaxPIDController;

import edu.wpi.first.util.sendable.Sendable;
import edu.wpi.first.util.sendable.SendableBuilder;

public class SendableSparkMaxPID implements Sendable {
  SparkMaxPIDController pid;
  double lastP, lastI, lastD, lastFF;

  public SendableSparkMaxPID(SparkMaxPIDController pid) {
    this.pid = pid;
  }

  @Override
  public void initSendable(SendableBuilder b) {
    b.addDoubleProperty("P", this::getP, this::setP);
    b.addDoubleProperty("I", this::getI, this::setI);
    b.addDoubleProperty("D", this::getD, this::setD);
    b.addDoubleProperty("FF", this::getFF, this::setFF);
  }

  public void setP(double newP) {
    lastP = newP;
    pid.setP(newP);
  }

  public void setI(double newI) {
    lastI = newI;
    pid.setI(newI);
  }

  public void setD(double newD) {
    pid.setD(newD);
  }

  public void setFF(double newFF) {
    pid.setFF(newFF);
  }

  public double getP() {
    return lastP;
  }

  public double getI() {
    return lastI;
  }

  public double getD() {
    return lastD;
  }

  public double getFF() {
    return lastFF;
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.
package frc.robot.util.sim;

import java.util.ArrayList;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Transform2d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.wpilibj.smartdashboard.Mechanism2d;
import edu.wpi.first.wpilibj.smartdashboard.MechanismLigament2d;
import edu.wpi.first.wpilibj.util.Color;
import edu.wpi.first.wpilibj.util.Color8Bit;

/** Add your docs here. */
public class Cone {
  ArrayList<Corner> corners = new ArrayList<Corner>();
  private Pose2d pose;
  private MechRootWrapper parent;
  private MechRootWrapper root;

  public Cone(MechRootWrapper parent, Pose2d pose) {
    this.parent = parent;
    this.pose = pose;
    createCone();
  }

  public ArrayList<Pose2d> calculateCornerPoses(ArrayList<Double> sideLengths) {
    ArrayList<Pose2d> cornerPoses = new ArrayList<>();
    ArrayList<Rotation2d> interiorAngles = calculateInteriorAngles(sideLengths);

    Pose2d bottomLeftCorner = new Pose2d(0, 0, new Rotation2d());
    Pose2d bottomRightCorner =
        new Pose2d(new Translation2d(sideLengths.get(0), 0), new Rotation2d(Math.PI).minus(interiorAngles.get(1)));
    Pose2d topCorner = new Pose2d(new Translation2d(sideLengths.get(1), interiorAngles.get(0)),
        new Rotation2d(Math.PI).plus(interiorAngles.get(0)));

    cornerPoses.add(bottomLeftCorner);
    cornerPoses.add(bottomRightCorner);
    cornerPoses.add(topCorner);

    double xAverage = cornerPoses.stream().mapToDouble(cornerPose -> cornerPose.getX()).average().getAsDouble();
    double yAverage = cornerPoses.stream().mapToDouble(cornerPose -> cornerPose.getY()).average().getAsDouble();

    Pose2d centroid = new Pose2d(xAverage, yAverage, new Rotation2d());

    for (int i = 0; i < 3; i++) {
      Pose2d cornerPose = cornerPoses.get(i);
      cornerPoses.set(i, cornerPose.relativeTo(centroid));
    }
    return cornerPoses;
  }

  public ArrayList<Rotation2d> calculateInteriorAngles(ArrayList<Double> sideLengths) {
    ArrayList<Rotation2d> interiorAngles = new ArrayList<>();
    for (int i = 0; i < 3; i++) {
      double currentSide = sideLengths.get((i + 1) % 3);
      double otherSide = sideLengths.get((i + 2) % 3);
      double otherSide2 = sideLengths.get((i + 3) % 3);
      double angle = Math.acos((Math.pow(currentSide, 2) - Math.pow(otherSide, 2) - Math.pow(otherSide2, 2))
          / (-2 * otherSide * otherSide2));
      interiorAngles.add(new Rotation2d(angle));
    }
    return interiorAngles;
  }

  public void createCone() {
    Mechanism2d mech = this.parent.getMechanism2d();
    this.root = new MechRootWrapper(mech, "Cone", 0, 0);

    ArrayList<Double> sideLengths = new ArrayList<Double>() {
      {
        add(5.0);
        add(5.0);
        add(5.0);
      }
    };
    ArrayList<Pose2d> cornerPoses = calculateCornerPoses(sideLengths);

    for (int i = 0; i < 3; i++) {
      corners.add(new Corner(i, root, cornerPoses.get(i), sideLengths.get(i)));
    }
  }

  public void update(Rotation2d rot) {
    Pose2d parentPos = new Pose2d(parent.getPosition().getTranslation(), rot);
    Transform2d deltaTransform = new Transform2d(this.pose.getTranslation(), this.pose.getRotation());
    Pose2d newConePose = parentPos.transformBy(deltaTransform);
    this.root.setPosition(newConePose.getX(), newConePose.getY());

    for (Corner corner : corners) {
      corner.update(rot);
    }
  }

  public class Corner {
    private MechRootWrapper root;
    private MechanismLigament2d side;
    private Pose2d pose;
    private MechRootWrapper parent;

    public Corner(int id, MechRootWrapper parent, Pose2d pose, double sideLength) {
      this.parent = parent;
      this.pose = pose;
      root = new MechRootWrapper(parent.getMechanism2d(), "Side " + id, pose.getX(), pose.getY());
      side = root.append(new MechanismLigament2d("Side " + id, 5, 0, 20.0, new Color8Bit(Color.kYellow)));
    }

    public void update(Rotation2d rot) {
      Pose2d parentPos = new Pose2d(this.parent.getPosition().getTranslation(), rot);
      Transform2d deltaTransform = new Transform2d(this.pose.getTranslation(), new Rotation2d());
      Pose2d newPose = parentPos.transformBy(deltaTransform);
      root.setPosition(newPose.getX(), newPose.getY());
      side.setAngle(rot.plus(pose.getRotation()));
    }
  }
}
package frc.robot.util.sim;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.wpilibj.smartdashboard.Mechanism2d;
import edu.wpi.first.wpilibj.smartdashboard.MechanismLigament2d;
import edu.wpi.first.wpilibj.smartdashboard.MechanismRoot2d;

public class MechRootWrapper {
  private MechanismRoot2d root;
  private double y;
  private double x;
  private Mechanism2d mech;

  public MechRootWrapper(Mechanism2d mech, String name, double x, double y) {
    this.root = mech.getRoot(name, x, y);
    this.x = x;
    this.y = y;
    this.mech = mech;
  }

  public void setPosition(double x, double y) {
    this.root.setPosition(x, y);
    this.x = x;
    this.y = y;
  }

  public Pose2d getPosition() {
    return new Pose2d(x, y, new Rotation2d());
  }

  public MechanismLigament2d append(MechanismLigament2d lig) {
    this.root.append(lig);
    return lig;
  }

  public Mechanism2d getMechanism2d() {
    return mech;
  }
}
package frc.robot.util;

import edu.wpi.first.math.filter.SlewRateLimiter;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.util.WPIUtilJNI;
import frc.robot.Constants.DRIVE;

/*
 * Limit slew rate of polar representation of speed (0-1), to try and avoid tread delamination. Adapted from
 * https://github.com/REVrobotics/MAXSwerve-Java-Template/blob/main/src/main/java/frc/robot/subsystems/DriveSubsystem.java#L125-L159
 */
public class SwerveRateLimit {
  private SlewRateLimiter magLimiter = new SlewRateLimiter(DRIVE.MAG_SLEW_RATE);
  private SlewRateLimiter rotLimiter = new SlewRateLimiter(DRIVE.ROT_SLEW_RATE);

  private double currentTranslationMag;
  private double currentTranslationDir;
  private double currentRotation;
  private double prevTime;

  public ChassisSpeeds rateLimit(ChassisSpeeds desiredSpeedPercentages) {
    // Convert XY to polar for rate limiting
    double inputTranslationDir =
        Math.atan2(desiredSpeedPercentages.vyMetersPerSecond, desiredSpeedPercentages.vxMetersPerSecond);
    double inputTranslationMag = Math.sqrt(Math.pow(desiredSpeedPercentages.vxMetersPerSecond, 2)
        + Math.pow(desiredSpeedPercentages.vyMetersPerSecond, 2));

    // Calculate the direction slew rate based on an estimate of the lateral acceleration
    double directionSlewRate;
    if (currentTranslationMag != 0.0) {
      directionSlewRate = Math.abs(DRIVE.DIRECTION_SLEW_RATE / currentTranslationMag);
    } else {
      directionSlewRate = 500.0; //some high number that means the slew rate is effectively instantaneous
    }


    double currentTime = WPIUtilJNI.now() * 1e-6;
    double elapsedTime = currentTime - prevTime;
    double angleDif = SwerveUtils.AngleDifference(inputTranslationDir, currentTranslationDir);
    if (angleDif < 0.45 * Math.PI) {
      currentTranslationDir =
          SwerveUtils.StepTowardsCircular(currentTranslationDir, inputTranslationDir, directionSlewRate * elapsedTime);
      currentTranslationMag = magLimiter.calculate(inputTranslationMag);
    } else if (angleDif > 0.85 * Math.PI) {
      if (currentTranslationMag > 1e-4) { //some small number to avoid floating-point errors with equality checking
        // keep currentTranslationDir unchanged
        currentTranslationMag = magLimiter.calculate(0.0);
      } else {
        currentTranslationDir = SwerveUtils.WrapAngle(currentTranslationDir + Math.PI);
        currentTranslationMag = magLimiter.calculate(inputTranslationMag);
      }
    } else {
      currentTranslationDir =
          SwerveUtils.StepTowardsCircular(currentTranslationDir, inputTranslationDir, directionSlewRate * elapsedTime);
      currentTranslationMag = magLimiter.calculate(0.0);
    }
    prevTime = currentTime;

    var xSpeedCommanded = currentTranslationMag * Math.cos(currentTranslationDir);
    var ySpeedCommanded = currentTranslationMag * Math.sin(currentTranslationDir);
    currentRotation = rotLimiter.calculate(desiredSpeedPercentages.omegaRadiansPerSecond);
    return new ChassisSpeeds(xSpeedCommanded, ySpeedCommanded, currentRotation);
  }
}
package frc.robot.util;

/* From https://github.com/REVrobotics/MAXSwerve-Java-Template/blob/main/src/main/java/frc/utils/SwerveUtils.java */
public class SwerveUtils {

  /**
   * Steps a value towards a target with a specified step size.
   * 
   * @param _current The current or starting value. Can be positive or negative.
   * @param _target The target value the algorithm will step towards. Can be positive or negative.
   * @param _stepsize The maximum step size that can be taken.
   * @return The new value for {@code _current} after performing the specified step towards the specified target.
   */
  public static double StepTowards(double _current, double _target, double _stepsize) {
    if (Math.abs(_current - _target) <= _stepsize) {
      return _target;
    } else if (_target < _current) {
      return _current - _stepsize;
    } else {
      return _current + _stepsize;
    }
  }

  /**
   * Steps a value (angle) towards a target (angle) taking the shortest path with a specified step size.
   * 
   * @param _current The current or starting angle (in radians). Can lie outside the 0 to 2*PI range.
   * @param _target The target angle (in radians) the algorithm will step towards. Can lie outside the 0 to 2*PI range.
   * @param _stepsize The maximum step size that can be taken (in radians).
   * @return The new angle (in radians) for {@code _current} after performing the specified step towards the specified target. This value will always lie in the range 0 to
   *         2*PI (exclusive).
   */
  public static double StepTowardsCircular(double _current, double _target, double _stepsize) {
    _current = WrapAngle(_current);
    _target = WrapAngle(_target);

    double stepDirection = Math.signum(_target - _current);
    double difference = Math.abs(_current - _target);

    if (difference <= _stepsize) {
      return _target;
    } else if (difference > Math.PI) { //does the system need to wrap over eventually?
      //handle the special case where you can reach the target in one step while also wrapping
      if (_current + 2 * Math.PI - _target < _stepsize || _target + 2 * Math.PI - _current < _stepsize) {
        return _target;
      } else {
        return WrapAngle(_current - stepDirection * _stepsize); //this will handle wrapping gracefully
      }

    } else {
      return _current + stepDirection * _stepsize;
    }
  }

  /**
   * Finds the (unsigned) minimum difference between two angles including calculating across 0.
   * 
   * @param _angleA An angle (in radians).
   * @param _angleB An angle (in radians).
   * @return The (unsigned) minimum difference between the two angles (in radians).
   */
  public static double AngleDifference(double _angleA, double _angleB) {
    double difference = Math.abs(_angleA - _angleB);
    return difference > Math.PI ? (2 * Math.PI) - difference : difference;
  }

  /**
   * Wraps an angle until it lies within the range from 0 to 2*PI (exclusive).
   * 
   * @param _angle The angle (in radians) to wrap. Can be positive or negative and can lie multiple wraps outside the output range.
   * @return An angle (in radians) from 0 and 2*PI (exclusive).
   */
  public static double WrapAngle(double _angle) {
    double twoPi = 2 * Math.PI;

    if (_angle == twoPi) { // Handle this case separately to avoid floating point errors with the floor after the division in the case below
      return 0.0;
    } else if (_angle > twoPi) {
      return _angle - twoPi * Math.floor(_angle / twoPi);
    } else if (_angle < 0.0) {
      return _angle + twoPi * (Math.floor((-_angle) / twoPi) + 1);
    } else {
      return _angle;
    }
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.util.vision;

import java.util.List;
import org.photonvision.targeting.PhotonTrackedTarget;
import edu.wpi.first.math.Matrix;
import edu.wpi.first.math.VecBuilder;
import edu.wpi.first.math.geometry.Pose3d;
import edu.wpi.first.math.numbers.N1;
import edu.wpi.first.math.numbers.N3;

/** Add your docs here. */
public class CustomEstimate {
  /** The estimated time the frame used to derive the robot pose was taken */
  public final double timestampSeconds;

  /** A list of the targets used to compute this pose */
  public final List<PhotonTrackedTarget> targetsUsed;

  public final Pose3d best;

  public Matrix<N3, N1> confidence;

  public final double ambiguity;

  /**
   * Constructs an EstimatedRobotPose
   *
   * @param estimatedPose estimated pose
   * @param timestampSeconds timestamp of the estimate
   */
  public CustomEstimate(Pose3d best, double ambiguity, double timestampSeconds, List<PhotonTrackedTarget> targetsUsed,
      Matrix<N3, N1> confidence) {
    this.best = best;
    this.ambiguity = ambiguity;
    this.timestampSeconds = timestampSeconds;
    this.targetsUsed = targetsUsed;
    this.confidence = confidence;
  }

  public CustomEstimate(Pose3d best, double ambiguity, double timestampSeconds, List<PhotonTrackedTarget> targetsUsed) {
    this(best, ambiguity, timestampSeconds, targetsUsed, VecBuilder.fill(0.9, 0.9, 0.9));
  }


  public void setConfidence(Matrix<N3, N1> confidence) {
    this.confidence = confidence;
  }
}
/*
 * MIT License
 *
 * Copyright (c) 2022 PhotonVision
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the
 * Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package frc.robot.util.vision;

import edu.wpi.first.apriltag.AprilTag;
import edu.wpi.first.apriltag.AprilTagFieldLayout;
import edu.wpi.first.math.geometry.Pose3d;
import edu.wpi.first.math.geometry.Transform3d;
import edu.wpi.first.wpilibj.DriverStation;
import frc.robot.util.MoreMath;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import org.photonvision.PhotonCamera;
import org.photonvision.estimation.VisionEstimation;
import org.photonvision.targeting.PhotonPipelineResult;
import org.photonvision.targeting.TargetCorner;

/**
 * The PhotonPoseEstimator class filters or combines readings from all the AprilTags visible at a given timestamp on the field to produce a single robot in field pose,
 * using the strategy set below. Example usage can be found in our apriltagExample example project.
 */
public class CustomEstimator {
  /** Position estimation strategies that can be used by the {@link PhotonPoseEstimator} class. */
  public enum PoseStrategy {
    /* Multi_TAG_PNP and then disambiguiate based on gyro */
    CLOSEST_TO_GYRO, CLOSEST_TO_BUFFER_POSE, CLOSEST_TO_GYRO_PRIME, CLOSEST_TO_BUFFER_POSE_PRIME, MIN_AMBIGUITY
  }

  private AprilTagFieldLayout fieldTags;
  private PoseStrategy primaryStrategy;
  private final PhotonCamera camera;
  private Transform3d robotToCamera;

  protected double poseCacheTimestampSeconds = -1;
  private final Set<Integer> reportedErrors = new HashSet<>();

  /**
   * Create a new PhotonPoseEstimator.
   *
   * @param fieldTags A WPILib {@link AprilTagFieldLayout} linking AprilTag IDs to Pose3d objects with respect to the FIRST field using the
   *          <a href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/geometry/coordinate-systems.html#field-coordinate-system">Field Coordinate
   *          System</a>.
   * @param strategy The strategy it should use to determine the best pose.
   * @param camera PhotonCamera
   * @param robotToCamera Transform3d from the center of the robot to the camera mount position (ie, robot ➔ camera) in the
   *          <a href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/geometry/coordinate-systems.html#robot-coordinate-system">Robot Coordinate
   *          System</a>.
   */
  public CustomEstimator(AprilTagFieldLayout fieldTags, PoseStrategy strategy, PhotonCamera camera,
      Transform3d robotToCamera) {
    this.fieldTags = fieldTags;
    this.primaryStrategy = strategy;
    this.camera = camera;
    this.robotToCamera = robotToCamera;
  }

  /** Invalidates the pose cache. */
  private void invalidatePoseCache() {
    poseCacheTimestampSeconds = -1;
  }

  private void checkUpdate(Object oldObj, Object newObj) {
    if (oldObj != newObj && oldObj != null && !oldObj.equals(newObj)) {
      invalidatePoseCache();
    }
  }

  /**
   * Get the AprilTagFieldLayout being used by the PositionEstimator.
   *
   * @return the AprilTagFieldLayout
   */
  public AprilTagFieldLayout getFieldTags() {
    return fieldTags;
  }

  /**
   * Set the AprilTagFieldLayout being used by the PositionEstimator.
   *
   * @param fieldTags the AprilTagFieldLayout
   */
  public void setFieldTags(AprilTagFieldLayout fieldTags) {
    checkUpdate(this.fieldTags, fieldTags);
    this.fieldTags = fieldTags;
  }

  /**
   * Get the Position Estimation Strategy being used by the Position Estimator.
   *
   * @return the strategy
   */
  public PoseStrategy getPrimaryStrategy() {
    return primaryStrategy;
  }

  /**
   * Set the Position Estimation Strategy used by the Position Estimator.
   *
   * @param strategy the strategy to set
   */
  public void setPrimaryStrategy(PoseStrategy strategy) {
    checkUpdate(this.primaryStrategy, strategy);
    this.primaryStrategy = strategy;
  }

  /** @return The current transform from the center of the robot to the camera mount position */
  public Transform3d getRobotToCameraTransform() {
    return robotToCamera;
  }

  /**
   * Useful for pan and tilt mechanisms and such.
   *
   * @param robotToCamera The current transform from the center of the robot to the camera mount position
   */
  public void setRobotToCameraTransform(Transform3d robotToCamera) {
    this.robotToCamera = robotToCamera;
  }

  /**
   * Poll data from the configured cameras and update the estimated position of the robot. Returns empty if there are no cameras set or no targets were found from the
   * cameras.
   *
   * @return an EstimatedRobotPose with an estimated pose, the timestamp, and targets used to create the estimate
   */
  public Optional<CustomEstimate> update() {
    if (camera == null) {
      DriverStation.reportError("[PhotonPoseEstimator] Missing camera!", false);
      return Optional.empty();
    }

    PhotonPipelineResult cameraResult = camera.getLatestResult();

    return update(cameraResult);
  }

  /**
   * Updates the estimated position of the robot. Returns empty if there are no cameras set or no targets were found from the cameras.
   *
   * @param cameraResult The latest pipeline result from the camera
   * @return an EstimatedRobotPose with an estimated pose, and information about the camera(s) and pipeline results used to create the estimate
   */
  public Optional<CustomEstimate> update(PhotonPipelineResult cameraResult) {
    // Time in the past -- give up, since the following if expects times > 0
    if (cameraResult.getTimestampSeconds() < 0) {
      return Optional.empty();
    }

    // If the pose cache timestamp was set, and the result is from the same timestamp, return an
    // empty result
    if (poseCacheTimestampSeconds > 0
        && Math.abs(poseCacheTimestampSeconds - cameraResult.getTimestampSeconds()) < 1e-6) {
      return Optional.empty();
    }

    // Remember the timestamp of the current result used
    poseCacheTimestampSeconds = cameraResult.getTimestampSeconds();

    // If no targets seen, trivial case -- return empty result
    if (!cameraResult.hasTargets()) {
      return Optional.empty();
    }

    return update(cameraResult, this.primaryStrategy);
  }

  private Optional<CustomEstimate> update(PhotonPipelineResult cameraResult, PoseStrategy strat) {

    cameraResult = filterTargets(cameraResult);
    Optional<CustomEstimate> estimatedPose;
    switch (strat) {
      case CLOSEST_TO_GYRO:
        estimatedPose = closestToGyroStrategy(cameraResult);
        break;
      case CLOSEST_TO_BUFFER_POSE:
        estimatedPose = closestToBufferPoseStrategy(cameraResult);
        break;
      case CLOSEST_TO_GYRO_PRIME:
        estimatedPose = closestToGyroPrimeStrategy(cameraResult);
        break;
      case CLOSEST_TO_BUFFER_POSE_PRIME:
        estimatedPose = closestToBufferPosePrimeStrategy(cameraResult);
        break;
      case MIN_AMBIGUITY:
        estimatedPose = minAmbiguityStrategy(cameraResult);
        break;
      default:
        DriverStation.reportError("[PhotonPoseEstimator] Unknown Position Estimation Strategy!", false);
        return Optional.empty();
    }

    return estimatedPose;
  }

  private PhotonPipelineResult filterTargets(PhotonPipelineResult cameraResult) {
    var filteredTargets = cameraResult.targets.stream().filter((target) -> {
      Optional<Pose3d> targetPose = fieldTags.getTagPose(target.getFiducialId());
      return targetPose.isPresent();
    }).collect(Collectors.toList());

    var filteredRes = new PhotonPipelineResult(cameraResult.getLatencyMillis(), filteredTargets);
    filteredRes.setTimestampSeconds(cameraResult.getTimestampSeconds());
    return filteredRes;
  }

  private Optional<CustomEstimate> minAmbiguityStrategy(PhotonPipelineResult cameraResult) {
    Optional<ExtendedCustomEstimate> optEstimate = getMultiTagEstimate(cameraResult);
    if (optEstimate.isEmpty()) {
      return Optional.empty();
    }
    var estimate = optEstimate.get();

    if (estimate.targetsUsed.size() > 1) {
      return Optional.of(estimate.getBestEstimate());
    } else {
      if (estimate.ambiguity < 0.15) {
        return Optional.of(estimate.getBestEstimate());
      } else {
        return Optional.empty();
      }
    }
  }

  private Optional<CustomEstimate> closestToGyroPrimeStrategy(PhotonPipelineResult cameraResult) {
    Optional<ExtendedCustomEstimate> optEstimate = getMultiTagEstimate(cameraResult);
    if (optEstimate.isEmpty()) {
      return Optional.empty();
    }
    var estimate = optEstimate.get();

    if (estimate.targetsUsed.size() > 1) {
      return Optional.of(estimate.getBestEstimate());
    } else {
      var contemporaryGyroRad =
          PoseBufferWrapper.getPoseInstance().getSample(estimate.timestampSeconds).get().gyroAngle.getRadians();

      var bestRad = estimate.best.getRotation().getZ();
      var altRad = estimate.alt.getRotation().getZ();

      var closestToBestRad = MoreMath.getClosestRad(bestRad, contemporaryGyroRad);
      var closestToAltRad = MoreMath.getClosestRad(altRad, contemporaryGyroRad);

      var distFromBest = Math.abs(bestRad - closestToBestRad);
      var distFromAlt = Math.abs(altRad - closestToAltRad);

      if (distFromBest <= distFromAlt) {
        return Optional.of(estimate.getBestEstimate());
      } else {
        return Optional.of(estimate.getAltEstimate());
      }
    }
  }

  private Optional<CustomEstimate> closestToBufferPosePrimeStrategy(PhotonPipelineResult cameraResult) {
    Optional<ExtendedCustomEstimate> optEstimate = getMultiTagEstimate(cameraResult);
    if (optEstimate.isEmpty()) {
      return Optional.empty();
    }
    var estimate = optEstimate.get();

    if (estimate.targetsUsed.size() > 1) {
      return Optional.of(estimate.getBestEstimate());
    } else {
      var contemporaryPose =
          new Pose3d(PoseBufferWrapper.getPoseInstance().getSample(estimate.timestampSeconds).get().poseMeters);
      var bestDistance = calculateDifference(contemporaryPose, estimate.best);
      var altDistance = calculateDifference(contemporaryPose, estimate.alt);

      if (bestDistance <= altDistance) {
        return Optional.of(estimate.getBestEstimate());
      } else {
        return Optional.of(estimate.getAltEstimate());
      }
    }
  }

  private Optional<CustomEstimate> closestToGyroStrategy(PhotonPipelineResult cameraResult) {
    Optional<ExtendedCustomEstimate> optEstimate = getMultiTagEstimate(cameraResult);
    if (optEstimate.isEmpty()) {
      return Optional.empty();
    }
    var estimate = optEstimate.get();

    var contemporaryGyroRad =
        PoseBufferWrapper.getPoseInstance().getSample(estimate.timestampSeconds).get().gyroAngle.getRadians();

    var bestRad = estimate.best.getRotation().getZ();
    var altRad = estimate.alt.getRotation().getZ();

    var closestToBestRad = MoreMath.getClosestRad(bestRad, contemporaryGyroRad);
    var closestToAltRad = MoreMath.getClosestRad(altRad, contemporaryGyroRad);

    var distFromBest = Math.abs(bestRad - closestToBestRad);
    var distFromAlt = Math.abs(altRad - closestToAltRad);

    if (distFromBest <= distFromAlt) {
      return Optional.of(estimate.getBestEstimate());
    } else {
      return Optional.of(estimate.getAltEstimate());
    }
  }

  private Optional<CustomEstimate> closestToBufferPoseStrategy(PhotonPipelineResult cameraResult) {
    Optional<ExtendedCustomEstimate> optEstimate = getMultiTagEstimate(cameraResult);
    if (optEstimate.isEmpty()) {
      return Optional.empty();
    }
    var estimate = optEstimate.get();

    var contemporaryPose =
        new Pose3d(PoseBufferWrapper.getPoseInstance().getSample(estimate.timestampSeconds).get().poseMeters);
    var bestDistance = calculateDifference(contemporaryPose, estimate.best);
    var altDistance = calculateDifference(contemporaryPose, estimate.alt);

    if (bestDistance <= altDistance) {
      return Optional.of(estimate.getBestEstimate());
    } else {
      return Optional.of(estimate.getAltEstimate());
    }
  }

  private Optional<ExtendedCustomEstimate> getMultiTagEstimate(PhotonPipelineResult result) {
    ExtendedCustomEstimate estimate;
    var numTargets = result.getTargets().size();
    if (numTargets == 0) {
      return Optional.empty();
    } else if (numTargets == 1) {
      var target = result.targets.get(0);

      /* make sure target exists and is valid */
      var targetPosition = fieldTags.getTagPose(target.getFiducialId()).get();

      var best =
          targetPosition.transformBy(target.getBestCameraToTarget().inverse()).transformBy(robotToCamera.inverse());

      var alt = targetPosition.transformBy(target.getAlternateCameraToTarget().inverse())
          .transformBy(robotToCamera.inverse());

      estimate = new ExtendedCustomEstimate(best, alt, target.getPoseAmbiguity(), result.getTimestampSeconds(),
          result.getTargets());

      return Optional.of(estimate);
    } else {
      var customEstimateOpt = innerMultiTag(result);
      return customEstimateOpt;
    }
  }

  private Optional<ExtendedCustomEstimate> innerMultiTag(PhotonPipelineResult result) {
    // Arrays we need declared up front
    var visCorners = new ArrayList<TargetCorner>();
    var knownVisTags = new ArrayList<AprilTag>();
    var fieldToCams = new ArrayList<Pose3d>();
    var fieldToCamsAlt = new ArrayList<Pose3d>();

    for (var target : result.getTargets()) {
      visCorners.addAll(target.getDetectedCorners());

      var tagPoseOpt = fieldTags.getTagPose(target.getFiducialId());
      if (tagPoseOpt.isEmpty()) {
        reportFiducialPoseError(target.getFiducialId());
        continue;
      }

      var tagPose = tagPoseOpt.get();

      // actual layout poses of visible tags -- not exposed, so have to recreate
      knownVisTags.add(new AprilTag(target.getFiducialId(), tagPose));

      fieldToCams.add(tagPose.transformBy(target.getBestCameraToTarget().inverse()));
      fieldToCamsAlt.add(tagPose.transformBy(target.getAlternateCameraToTarget().inverse()));
    }

    var cameraMatrixOpt = camera.getCameraMatrix();
    var distCoeffsOpt = camera.getDistCoeffs();
    boolean hasCalibData = cameraMatrixOpt.isPresent() && distCoeffsOpt.isPresent();

    // multi-target solvePNP
    if (hasCalibData) {
      var cameraMatrix = cameraMatrixOpt.get();
      var distCoeffs = distCoeffsOpt.get();
      var pnpResults = VisionEstimation.estimateCamPosePNP(cameraMatrix, distCoeffs, visCorners, knownVisTags);
      var best = new Pose3d().plus(pnpResults.best) // field-to-camera
          .plus(robotToCamera.inverse()); // field-to-robot
      var alt = new Pose3d().plus(pnpResults.alt) // field-to-camera
          .plus(robotToCamera.inverse()); // field-to-robot

      return Optional.of(new ExtendedCustomEstimate(best, alt, pnpResults.bestReprojErr / pnpResults.altReprojErr,
          result.getTimestampSeconds(), result.getTargets()));
    } else {
      // TODO fallback strategy? Should we just always do solvePNP?
      return Optional.empty();
    }
  }

  /**
   * Difference is defined as the vector magnitude between the two poses
   *
   * @return The absolute "difference" (>=0) between two Pose3ds.
   */
  private double calculateDifference(Pose3d x, Pose3d y) {
    return x.getTranslation().getDistance(y.getTranslation());
  }

  private void reportFiducialPoseError(int fiducialId) {
    if (!reportedErrors.contains(fiducialId)) {
      DriverStation.reportError("[PhotonPoseEstimator] Tried to get pose of unknown AprilTag: " + fiducialId, false);
      reportedErrors.add(fiducialId);
    }
  }
}
package frc.robot.util.vision;

import java.util.List;
import org.photonvision.targeting.PhotonTrackedTarget;
import edu.wpi.first.math.Matrix;
import edu.wpi.first.math.geometry.Pose3d;
import edu.wpi.first.math.numbers.N1;
import edu.wpi.first.math.numbers.N3;

public class ExtendedCustomEstimate extends CustomEstimate {
  public final Pose3d alt;

  public ExtendedCustomEstimate(Pose3d best, Pose3d alt, double ambiguity, double timestampSeconds,
      List<PhotonTrackedTarget> targetsUsed, Matrix<N3, N1> confidence) {
    super(best, ambiguity, timestampSeconds, targetsUsed, confidence);
    this.alt = alt;
  }

  public ExtendedCustomEstimate(Pose3d best, Pose3d alt, double ambiguity, double timestampSeconds,
      List<PhotonTrackedTarget> targetsUsed) {
    super(best, ambiguity, timestampSeconds, targetsUsed);
    this.alt = alt;
  }

  public CustomEstimate getBestEstimate() {
    return new CustomEstimate(best, ambiguity, timestampSeconds, targetsUsed);
  }

  public CustomEstimate getAltEstimate() {
    return new CustomEstimate(alt, ambiguity, timestampSeconds, targetsUsed);
  }
}
package frc.robot.util.vision;

import java.util.Arrays;
import java.util.Objects;
import edu.wpi.first.math.MathUtil;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Twist2d;
import edu.wpi.first.math.interpolation.Interpolatable;
import edu.wpi.first.math.kinematics.SwerveDriveKinematics;
import edu.wpi.first.math.kinematics.SwerveModulePosition;

/**
 * Represents an odometry record. The record contains the inputs provided as well as the pose that was observed based on these inputs, as well as the previous record and
 * its inputs.
 */
public class InterpolationRecord implements Interpolatable<InterpolationRecord> {
  // The pose observed given the current sensor inputs and the previous pose.
  public final Pose2d poseMeters;

  // The current gyro angle.
  public final Rotation2d gyroAngle;

  // The distances and rotations measured at each module.
  private final SwerveModulePosition[] modulePositions;
  private final int m_numModules = 4;

  private SwerveDriveKinematics m_kinematics;

  /**
   * Constructs an Interpolation Record with the specified parameters.
   *
   * @param pose The pose observed given the current sensor inputs and the previous pose.
   * @param gyro The current gyro angle.
   * @param wheelPositions The distances and rotations measured at each wheel.
   */
  public InterpolationRecord(Pose2d poseMeters, Rotation2d gyro, SwerveModulePosition[] modulePositions,
      SwerveDriveKinematics kinematics) {
    this.poseMeters = poseMeters;
    this.gyroAngle = gyro;
    this.modulePositions = modulePositions;
    this.m_kinematics = kinematics;
  }

  /**
   * Return the interpolated record. This object is assumed to be the starting position, or lower bound.
   *
   * @param endValue The upper bound, or end.
   * @param t How far between the lower and upper bound we are. This should be bounded in [0, 1].
   * @return The interpolated value.
   */
  @Override
  public InterpolationRecord interpolate(InterpolationRecord endValue, double t) {
    if (t < 0) {
      return this;
    } else if (t >= 1) {
      return endValue;
    } else {
      // Find the new wheel distances.
      var modulePositions = new SwerveModulePosition[m_numModules];

      // Find the distance travelled between this measurement and the interpolated measurement.
      var moduleDeltas = new SwerveModulePosition[m_numModules];

      for (int i = 0; i < m_numModules; i++) {
        double ds =
            MathUtil.interpolate(this.modulePositions[i].distanceMeters, endValue.modulePositions[i].distanceMeters, t);
        Rotation2d theta = this.modulePositions[i].angle.interpolate(endValue.modulePositions[i].angle, t);
        modulePositions[i] = new SwerveModulePosition(ds, theta);
        moduleDeltas[i] = new SwerveModulePosition(ds - this.modulePositions[i].distanceMeters, theta);
      }

      // Find the new gyro angle.
      var gyro_lerp = gyroAngle.interpolate(endValue.gyroAngle, t);

      // Create a twist to represent this change based on the interpolated sensor inputs.
      Twist2d twist = m_kinematics.toTwist2d(moduleDeltas);
      twist.dtheta = gyro_lerp.minus(gyroAngle).getRadians();

      return new InterpolationRecord(poseMeters.exp(twist), gyro_lerp, modulePositions, m_kinematics);
    }
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (!(obj instanceof InterpolationRecord)) {
      return false;
    }
    InterpolationRecord record = (InterpolationRecord) obj;
    return Objects.equals(gyroAngle, record.gyroAngle) && Arrays.equals(modulePositions, record.modulePositions)
        && Objects.equals(poseMeters, record.poseMeters);
  }

  @Override
  public int hashCode() {
    return Objects.hash(gyroAngle, Arrays.hashCode(modulePositions), poseMeters);
  }
}
package frc.robot.util.vision;

import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Supplier;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.interpolation.TimeInterpolatableBuffer;
import edu.wpi.first.math.kinematics.SwerveDriveKinematics;
import edu.wpi.first.math.kinematics.SwerveModulePosition;
import edu.wpi.first.wpilibj.Timer;

public class PoseBufferWrapper {
  private SwerveDriveKinematics kinematics;
  private Supplier<SwerveModulePosition[]> modulePoseLambda;
  private Supplier<Rotation2d> gyroLambda;
  private Supplier<Pose2d> poseLambda;
  private TimeInterpolatableBuffer<InterpolationRecord> poseBuffer;
  private static PoseBufferWrapper wheelBufferInstance;
  private static PoseBufferWrapper poseBufferInstance;

  private PoseBufferWrapper(Supplier<Pose2d> poseLambda, Supplier<SwerveModulePosition[]> modulePoseLambda,
      Supplier<Rotation2d> gyroLambda, SwerveDriveKinematics kinematics) {
    this.poseLambda = poseLambda;
    this.gyroLambda = gyroLambda;
    this.modulePoseLambda = modulePoseLambda;
    this.kinematics = kinematics;
    this.poseBuffer = TimeInterpolatableBuffer.createBuffer(1.5);
  }

  public static void createBuffers(Supplier<Pose2d> poseLambda, Supplier<Pose2d> wheelPoseLambda,
      Supplier<SwerveModulePosition[]> modulePoseLambda, Supplier<Rotation2d> gyroLambda,
      SwerveDriveKinematics kinematics, Consumer<Runnable> setResetBuffer) {
    PoseBufferWrapper.wheelBufferInstance =
        new PoseBufferWrapper(wheelPoseLambda, modulePoseLambda, gyroLambda, kinematics);
    PoseBufferWrapper.poseBufferInstance = new PoseBufferWrapper(poseLambda, modulePoseLambda, gyroLambda, kinematics);
    setResetBuffer.accept(() -> {
      PoseBufferWrapper.wheelBufferInstance.reset();
      PoseBufferWrapper.poseBufferInstance.reset();
    });
  }

  public static PoseBufferWrapper getPoseInstance() {
    return PoseBufferWrapper.poseBufferInstance;
  }

  public static PoseBufferWrapper getWheelInstance() {
    return PoseBufferWrapper.wheelBufferInstance;
  }

  public void update() {
    var pose = poseLambda.get();
    var modulePoses = modulePoseLambda.get();
    var gyro = gyroLambda.get();

    poseBuffer.addSample(Timer.getFPGATimestamp(), new InterpolationRecord(pose, gyro, modulePoses, kinematics));
  }

  public void reset() {
    poseBuffer.clear();
  }

  public Optional<InterpolationRecord> getSample(double timestamp) {
    return poseBuffer.getSample(timestamp);
  }
}
// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.util.vision;

import edu.wpi.first.math.geometry.Transform3d;

/** Add your docs here. */
public class SimCamParams {
  public double camDiagFOV;
  public int maxLEDRange;
  public int camResWidth;
  public int camResHeight;
  public int minTargetArea;
  public Transform3d robot2Cam;
  public String name;

  public SimCamParams(double camDiagFOV, int maxLEDRange, int camResolutionWidth, int camResolutionHeight,
      int minTargetArea, Transform3d robot2Cam, String name) {
    this.camDiagFOV = camDiagFOV;
    this.maxLEDRange = maxLEDRange;
    this.camResWidth = camResolutionWidth;
    this.camResHeight = camResolutionHeight;
    this.minTargetArea = minTargetArea;
    this.robot2Cam = robot2Cam;
    this.name = name;
  }
}
/*
 * MIT License
 *
 * Copyright (c) 2022 PhotonVision
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the
 * Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package frc.robot.util.vision;

import edu.wpi.first.math.Matrix;
import edu.wpi.first.math.numbers.N1;
import edu.wpi.first.math.numbers.N3;
import edu.wpi.first.math.numbers.N5;
import edu.wpi.first.networktables.NetworkTableInstance;
import java.util.Arrays;
import java.util.List;
import org.photonvision.PhotonTargetSortMode;
import org.photonvision.common.dataflow.structures.Packet;
import org.photonvision.common.networktables.NTTopicSet;
import org.photonvision.targeting.PhotonPipelineResult;
import org.photonvision.targeting.PhotonTrackedTarget;

@SuppressWarnings("unused")
public class SimPhotonCamera {
  NTTopicSet ts = new NTTopicSet();
  PhotonPipelineResult latestResult;
  private long heartbeatCounter = 0;
  private Matrix<N5, N1> distortionMat;
  private Matrix<N3, N3> cameraMatrix;

  /**
   * Constructs a Simulated PhotonCamera from a root table.
   *
   * @param instance The NetworkTableInstance to pull data from. This can be a custom instance in simulation, but should *usually* be the default NTInstance from
   *          NetworkTableInstance::getDefault
   * @param cameraName The name of the camera, as seen in the UI.
   */
  public SimPhotonCamera(NetworkTableInstance instance, String cameraName) {
    ts.removeEntries();
    ts.subTable = instance.getTable("photonvision").getSubTable(cameraName);
    ts.updateEntries();
  }

  /**
   * Publishes the camera intrinsics matrix. The matrix should be in the form: spotless:off
     * fx  0   cx
     * 0   fy  cy
     * 0   0   1
     * @param cameraMatrix The cam matrix
     * spotless:on
   */
  public void setCameraIntrinsicsMat(Matrix<N3, N3> cameraMatrix) {
    this.cameraMatrix = cameraMatrix;
    ts.cameraIntrinsicsPublisher.set(cameraMatrix.getData());
  }

  /**
   * Publishes the camera distortion matrix. The matrix should be in the form [k1 k2 p1 p2 k3]. See more:
   * https://docs.opencv.org/3.4/d4/d94/tutorial_camera_calibration.html
   *
   * @param distortionMat The distortion mat
   */
  public void setCameraDistortionMat(Matrix<N5, N1> distortionMat) {
    this.distortionMat = distortionMat;
    ts.cameraDistortionPublisher.set(distortionMat.getData());
  }

  public Matrix<N3, N3> getCameraIntrinsicsMat() {
    return cameraMatrix;
  }

  public Matrix<N5, N1> getDistortionMat() {
    return distortionMat;
  }

  /**
   * Constructs a Simulated PhotonCamera from the name of the camera.
   *
   * @param cameraName The nickname of the camera (found in the PhotonVision UI).
   */
  public SimPhotonCamera(String cameraName) {
    this(NetworkTableInstance.getDefault(), cameraName);
  }

  /**
   * Simulate one processed frame of vision data, putting one result to NT.
   *
   * @param latencyMillis Latency of the provided frame
   * @param targets Each target detected
   */
  public void submitProcessedFrame(double latencyMillis, PhotonTrackedTarget... targets) {
    submitProcessedFrame(latencyMillis, Arrays.asList(targets));
  }

  /**
   * Simulate one processed frame of vision data, putting one result to NT.
   *
   * @param latencyMillis Latency of the provided frame
   * @param sortMode Order in which to sort targets
   * @param targets Each target detected
   */
  public void submitProcessedFrame(double latencyMillis, PhotonTargetSortMode sortMode,
      PhotonTrackedTarget... targets) {
    submitProcessedFrame(latencyMillis, sortMode, Arrays.asList(targets));
  }

  /**
   * Simulate one processed frame of vision data, putting one result to NT.
   *
   * @param latencyMillis Latency of the provided frame
   * @param targetList List of targets detected
   */
  public void submitProcessedFrame(double latencyMillis, List<PhotonTrackedTarget> targetList) {
    submitProcessedFrame(latencyMillis, null, targetList);
  }

  /**
   * Simulate one processed frame of vision data, putting one result to NT.
   *
   * @param latencyMillis Latency of the provided frame
   * @param sortMode Order in which to sort targets
   * @param targetList List of targets detected
   */
  public void submitProcessedFrame(double latencyMillis, PhotonTargetSortMode sortMode,
      List<PhotonTrackedTarget> targetList) {
    ts.latencyMillisEntry.set(latencyMillis);

    if (sortMode != null) {
      targetList.sort(sortMode.getComparator());
    }

    PhotonPipelineResult newResult = new PhotonPipelineResult(latencyMillis, targetList);
    var newPacket = new Packet(newResult.getPacketSize());
    newResult.populatePacket(newPacket);
    ts.rawBytesEntry.set(newPacket.getData());

    boolean hasTargets = newResult.hasTargets();
    ts.hasTargetEntry.set(hasTargets);
    if (!hasTargets) {
      ts.targetPitchEntry.set(0.0);
      ts.targetYawEntry.set(0.0);
      ts.targetAreaEntry.set(0.0);
      ts.targetPoseEntry.set(new double[] {0.0, 0.0, 0.0});
      ts.targetSkewEntry.set(0.0);
    } else {
      var bestTarget = newResult.getBestTarget();

      ts.targetPitchEntry.set(bestTarget.getPitch());
      ts.targetYawEntry.set(bestTarget.getYaw());
      ts.targetAreaEntry.set(bestTarget.getArea());
      ts.targetSkewEntry.set(bestTarget.getSkew());

      var transform = bestTarget.getBestCameraToTarget();
      double[] poseData = {transform.getX(), transform.getY(), transform.getRotation().toRotation2d().getDegrees()};
      ts.targetPoseEntry.set(poseData);
    }

    ts.heartbeatPublisher.set(heartbeatCounter++);

    latestResult = newResult;
  }

  PhotonPipelineResult getLatestResult() {
    return latestResult;
  }
}
/*
 * MIT License
 *
 * Copyright (c) 2022 PhotonVision
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the
 * Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package frc.robot.util.vision;

import edu.wpi.first.apriltag.AprilTag;
import edu.wpi.first.apriltag.AprilTagFieldLayout;
import edu.wpi.first.math.StateSpaceUtil;
import edu.wpi.first.math.VecBuilder;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Pose3d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Rotation3d;
import edu.wpi.first.math.geometry.Transform3d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.math.geometry.Translation3d;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.wpilibj.smartdashboard.Field2d;
import edu.wpi.first.wpilibj.smartdashboard.FieldObject2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import java.util.ArrayList;
import java.util.List;

import org.photonvision.estimation.OpenCVHelp;
import org.photonvision.estimation.TargetModel;
import org.photonvision.targeting.PhotonTrackedTarget;
import org.photonvision.targeting.TargetCorner;

public class SimVisionSystem {
  SimPhotonCamera cam;

  double camHorizFOVDegrees;
  double camVertFOVDegrees;
  double cameraHeightOffGroundMeters;
  double maxLEDRangeMeters;
  int cameraResWidth;
  int cameraResHeight;
  double minTargetArea;
  Transform3d robotToCamera;

  Field2d dbgField;
  FieldObject2d dbgRobot;
  FieldObject2d dbgCamera;

  ArrayList<SimVisionTarget> tgtList;

  private double kNoise;
  public static final TargetModel kTagModel = new TargetModel(Units.inchesToMeters(6), Units.inchesToMeters(6));


  /**
   * Create a simulated vision system involving a camera and coprocessor mounted on a mobile robot running PhotonVision, detecting one or more targets scattered around the
   * field. This assumes a fairly simple and distortion-less pinhole camera model.
   *
   * @param camName Name of the PhotonVision camera to create. Align it with the settings you use in the PhotonVision GUI.
   * @param camDiagFOVDegrees Diagonal Field of View of the camera used. Align it with the manufacturer specifications, and/or whatever is configured in the PhotonVision
   *          Setting page.
   * @param robotToCamera Transform to move from the center of the robot to the camera's mount position
   * @param maxLEDRangeMeters Maximum distance at which your camera can illuminate the target and make it visible. Set to 9000 or more if your vision system does not rely
   *          on LED's.
   * @param cameraResWidth Width of your camera's image sensor in pixels
   * @param cameraResHeight Height of your camera's image sensor in pixels
   * @param minTargetArea Minimum area that that the target should be before it's recognized as a target by the camera. Match this with your contour filtering settings in
   *          the PhotonVision GUI.
   */
  public SimVisionSystem(String camName, double camDiagFOVDegrees, Transform3d robotToCamera, double maxLEDRangeMeters,
      int cameraResWidth, int cameraResHeight, double minTargetArea, double kNoise) {
    this.robotToCamera = robotToCamera;
    this.maxLEDRangeMeters = maxLEDRangeMeters;
    this.cameraResWidth = cameraResWidth;
    this.cameraResHeight = cameraResHeight;
    this.minTargetArea = minTargetArea;
    this.kNoise = kNoise;

    // Calculate horizontal/vertical FOV by similar triangles
    double hypotPixels = Math.hypot(cameraResWidth, cameraResHeight);
    this.camHorizFOVDegrees = camDiagFOVDegrees * cameraResWidth / hypotPixels;
    this.camVertFOVDegrees = camDiagFOVDegrees * cameraResHeight / hypotPixels;

    cam = new SimPhotonCamera(camName);
    tgtList = new ArrayList<>();

    dbgField = new Field2d();
    dbgRobot = dbgField.getRobotObject();
    dbgCamera = dbgField.getObject(camName + " Camera");
    SmartDashboard.putData(camName + " Sim Field", dbgField);
  }

  public SimVisionSystem(String camName, double camDiagFOVDegrees, Transform3d robotToCamera, double maxLEDRangeMeters,
      int cameraResWidth, int cameraResHeight, double minTargetArea) {
    this.robotToCamera = robotToCamera;
    this.maxLEDRangeMeters = maxLEDRangeMeters;
    this.cameraResWidth = cameraResWidth;
    this.cameraResHeight = cameraResHeight;
    this.minTargetArea = minTargetArea;
    this.kNoise = 0;

    // Calculate horizontal/vertical FOV by similar triangles
    double hypotPixels = Math.hypot(cameraResWidth, cameraResHeight);
    this.camHorizFOVDegrees = camDiagFOVDegrees * cameraResWidth / hypotPixels;
    this.camVertFOVDegrees = camDiagFOVDegrees * cameraResHeight / hypotPixels;

    cam = new SimPhotonCamera(camName);
    tgtList = new ArrayList<>();

    dbgField = new Field2d();
    dbgRobot = dbgField.getRobotObject();
    dbgCamera = dbgField.getObject(camName + " Camera");
    SmartDashboard.putData(camName + " Sim Field", dbgField);
  }

  public SimPhotonCamera getSimCam() {
    return cam;
  }

  /**
   * Add a target on the field which your vision system is designed to detect. The PhotonCamera from this system will report the location of the robot relative to the
   * subset of these targets which are visible from the given robot position.
   *
   * @param target Target to add to the simulated field
   */
  public void addSimVisionTarget(SimVisionTarget target) {
    tgtList.add(target);
    dbgField.getObject("Target " + Integer.toString(target.targetID)).setPose(target.targetPose.toPose2d());
  }

  /**
   * Adds all apriltags from the provided {@link AprilTagFieldLayout} as sim vision targets. The poses added will preserve the tag layout's alliance origin at the time of
   * calling this method.
   *
   * @param tagLayout The field tag layout to get Apriltag poses and IDs from
   */
  public void addVisionTargets(AprilTagFieldLayout tagLayout) {
    for (AprilTag tag : tagLayout.getTags()) {
      addSimVisionTarget(new SimVisionTarget(tagLayout.getTagPose(tag.ID).get(), // preserve alliance rotation
          Units.inchesToMeters(6), Units.inchesToMeters(6), tag.ID));
    }
  }

  /**
   * Clears all sim vision targets. This is useful for switching alliances and needing to repopulate the sim targets. NOTE: Old targets will still show on the Field2d
   * unless overwritten by new targets with the same ID
   */
  public void clearVisionTargets() {
    tgtList.clear();
  }

  /**
   * Adjust the camera position relative to the robot. Use this if your camera is on a gimbal or turret or some other mobile platform.
   *
   * @param newRobotToCamera New Transform from the robot to the camera
   */
  public void moveCamera(Transform3d newRobotToCamera) {
    this.robotToCamera = newRobotToCamera;
  }

  /**
   * Periodic update. Call this once per frame of image data you wish to process and send to NetworkTables
   *
   * @param robotPoseMeters current pose of the robot on the field. Will be used to calculate which targets are actually in view, where they are at relative to the robot,
   *          and relevant PhotonVision parameters.
   */
  public void processFrame(Pose2d robotPoseMeters) {
    processFrame(new Pose3d(robotPoseMeters));
  }

  public Pose3d noisify(Pose3d accPose) {
    var xNoise = StateSpaceUtil.makeWhiteNoiseVector(VecBuilder.fill(kNoise)).get(0, 0);
    var yNoise = StateSpaceUtil.makeWhiteNoiseVector(VecBuilder.fill(kNoise)).get(0, 0);
    var noiseTrl = new Translation3d(xNoise, yNoise, 0);
    return accPose.transformBy(new Transform3d(noiseTrl, new Rotation3d()));
  }

  /**
   * Periodic update. Call this once per frame of image data you wish to process and send to NetworkTables
   *
   * @param robotPoseMeters current pose of the robot in space. Will be used to calculate which targets are actually in view, where they are at relative to the robot, and
   *          relevant PhotonVision parameters.
   */
  public void processFrame(Pose3d robotPoseMeters) {
    Pose3d cameraPose = robotPoseMeters.transformBy(robotToCamera);

    dbgRobot.setPose(robotPoseMeters.toPose2d());
    dbgCamera.setPose(cameraPose.toPose2d());

    ArrayList<PhotonTrackedTarget> visibleTgtList = new ArrayList<>(tgtList.size());

    tgtList.forEach((tgt) -> {
      tgt.targetPose = noisify(tgt.targetPose);
      var camToTargetTrans = new Transform3d(cameraPose, tgt.targetPose);

      // Generate a transformation from camera to target,
      // ignoring rotation.
      var t = camToTargetTrans.getTranslation();

      // Rough approximation of the alternate solution, which is (so far) always incorrect.
      var altTrans = new Translation3d(t.getX(), -1.0 * t.getY(), t.getZ()); // mirrored across camera axis in Y direction
      var altRot = camToTargetTrans.getRotation().times(-1.0); // flipped
      var camToTargetTransAlt = new Transform3d(altTrans, altRot);

      double distMeters = t.getNorm();

      double area_px = tgt.tgtAreaMeters2 / getM2PerPx(distMeters);

      var translationAlongGround = new Translation2d(tgt.targetPose.toPose2d().getX() - cameraPose.toPose2d().getX(),
          tgt.targetPose.toPose2d().getY() - cameraPose.toPose2d().getY());

      var camAngle = cameraPose.getRotation().toRotation2d();
      var camToTgtRotation = new Rotation2d(translationAlongGround.getX(), translationAlongGround.getY());
      double yawDegrees = camToTgtRotation.minus(camAngle).getDegrees();

      double camHeightAboveGround = cameraPose.getZ();
      double tgtHeightAboveGround = tgt.targetPose.getZ();
      double camPitchDegrees = Units.radiansToDegrees(cameraPose.getRotation().getY());

      double distAlongGround = translationAlongGround.getNorm();

      double pitchDegrees =
          Units.radiansToDegrees(Math.atan2((tgtHeightAboveGround - camHeightAboveGround), distAlongGround))
              - camPitchDegrees;

      if (camCanSeeTarget(distMeters, yawDegrees, pitchDegrees, area_px)) {
        var cornerTrls = kTagModel.getFieldVertices(tgt.targetPose);
        var corners =
            OpenCVHelp.projectPoints(cam.getCameraIntrinsicsMat(), cam.getDistortionMat(), cameraPose, cornerTrls);

        // TODO simulate target corners
        visibleTgtList.add(new PhotonTrackedTarget(yawDegrees, pitchDegrees, area_px, 0.0, tgt.targetID,
            camToTargetTrans, camToTargetTransAlt, 0.0, // TODO - simulate ambiguity when straight on?
            List.of(new TargetCorner(0, 0), new TargetCorner(0, 0), new TargetCorner(0, 0), new TargetCorner(0, 0)),
            corners));
      }
    });

    cam.submitProcessedFrame(0.0, visibleTgtList);
  }

  double getM2PerPx(double dist) {
    double widthMPerPx = 2 * dist * Math.tan(Units.degreesToRadians(this.camHorizFOVDegrees) / 2) / cameraResWidth;
    double heightMPerPx = 2 * dist * Math.tan(Units.degreesToRadians(this.camVertFOVDegrees) / 2) / cameraResHeight;
    return widthMPerPx * heightMPerPx;
  }

  boolean camCanSeeTarget(double distMeters, double yaw, double pitch, double area) {
    boolean inRange = (distMeters < this.maxLEDRangeMeters);
    boolean inHorizAngle = Math.abs(yaw) < (this.camHorizFOVDegrees / 2);
    boolean inVertAngle = Math.abs(pitch) < (this.camVertFOVDegrees / 2);
    boolean targetBigEnough = area > this.minTargetArea;
    return (inRange && inHorizAngle && inVertAngle && targetBigEnough);
  }
}
/*
 * MIT License
 *
 * Copyright (c) 2022 PhotonVision
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the
 * Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package frc.robot.util.vision;

import edu.wpi.first.math.geometry.Pose3d;

public class SimVisionTarget {
  Pose3d targetPose;
  double targetWidthMeters;
  double targetHeightMeters;
  double tgtAreaMeters2;
  int targetID;

  /**
   * Describes a vision target located somewhere on the field that your SimVisionSystem can detect.
   *
   * @param targetPos Pose3d of the target in field-relative coordinates
   * @param targetWidthMeters Width of the outer bounding box of the target in meters.
   * @param targetHeightMeters Pair Height of the outer bounding box of the target in meters.
   */
  public SimVisionTarget(Pose3d targetPos, double targetWidthMeters, double targetHeightMeters, int targetID) {
    this.targetPose = targetPos;
    this.targetWidthMeters = targetWidthMeters;
    this.targetHeightMeters = targetHeightMeters;
    this.tgtAreaMeters2 = targetWidthMeters * targetHeightMeters;
    this.targetID = targetID;
  }
}
